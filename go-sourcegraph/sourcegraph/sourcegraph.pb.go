// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
Package sourcegraph is a generated protocol buffer package.

It is generated from these files:
	sourcegraph.proto

It has these top-level messages:
	Badge
	CombinedStatus
	Counter
	ListOptions
	ListResponse
	StreamResponse
	Changeset
	ChangesetReview
	ChangesetEvent
	InlineComment
	Readme
	GitHubRepo
	RepoConfig
	Repo
	BadgeList
	CounterList
	RepoBadgesCountHitsOp
	RepoBadgesCountHitsResult
	RepoListOptions
	RepoPermissions
	RepoRevSpec
	RepoSpec
	RepoStatus
	RepoStatusesCreateOp
	RepoList
	SrclibDataVersion
	RepoConfigureAppOp
	StorageBucket
	StorageKey
	StorageValue
	StoragePutOp
	StorageExists
	StorageList
	ReposCreateOp
	ReposUpdateOp
	ReposListCommitsOp
	RepoListCommitsOptions
	CommitList
	ReposListBranchesOp
	RepoListBranchesOptions
	BranchList
	ReposListTagsOp
	ReposListCommittersOp
	RepoListCommittersOptions
	CommitterList
	ChangesetCreateOp
	ChangesetCreateReviewOp
	ChangesetListReviewsOp
	ChangesetSpec
	ChangesetUpdateOp
	ChangesetMergeOp
	ChangesetUpdateAffectedOp
	RepoListTagsOptions
	TagList
	MirrorReposRefreshVCSOp
	VCSCredentials
	MirroredRepoSSHKeysCreateOp
	SSHPrivateKey
	Build
	BuildConfig
	BuildCreateOptions
	BuildGetLogOptions
	BuildListOptions
	ChangesetListOp
	BuildSpec
	BuildTask
	BuildTaskListOptions
	BuildUpdate
	BuildList
	BuildsCreateOp
	BuildsUpdateOp
	BuildsListBuildTasksOp
	BuildTaskList
	ChangesetReviewList
	ChangesetList
	ChangesetEventList
	BuildsCreateTasksOp
	BuildsUpdateTaskOp
	BuildsGetLogOp
	BuildsGetTaskLogOp
	BuildsDequeueNextOp
	EmailAddr
	LogEntries
	Org
	OrgListMembersOptions
	OrgSpec
	OrgsListMembersOp
	UserList
	UserCount
	Person
	PersonSpec
	TaskSpec
	TaskUpdate
	User
	UserSpec
	UsersListOptions
	OrgsListOp
	EmailAddrList
	OrgList
	PasswordResetToken
	PendingPasswordReset
	NewPassword
	NewAccount
	AccountInvite
	InviteSpec
	PendingInvite
	AccountInviteList
	AcceptedInvite
	SSHPublicKey
	AuthorizationCodeRequest
	AuthorizationCode
	LoginCredentials
	BearerJWT
	AccessTokenRequest
	AccessTokenResponse
	AuthInfo
	AuthorshipInfo
	Def
	DefAuthor
	DefAuthorship
	DefClient
	DefDelta
	DefGetOptions
	DefListAuthorsOptions
	DefListClientsOptions
	DefListExamplesOptions
	DefListOptions
	DefListRefsOptions
	DefSpec
	DefsGetOp
	DefList
	DefsListRefsOp
	RefList
	DefsListExamplesOp
	ExampleList
	DefsListAuthorsOp
	DefsListClientsOp
	Delta
	DeltaAffectedPerson
	DeltaDefs
	FileDiff
	Hunk
	DeltaFiles
	DeltaFilter
	DeltaListAffectedAuthorsOptions
	DeltaListAffectedClientsOptions
	DeltaListDefsOptions
	DeltaListFilesOptions
	DeltaListUnitsOptions
	DeltaSpec
	DeltasListUnitsOp
	UnitDeltaList
	DeltasListDefsOp
	DeltasListFilesOp
	DeltasListAffectedAuthorsOp
	DeltaAffectedPersonList
	DeltasListAffectedClientsOp
	Example
	FormatResult
	MarkdownData
	MarkdownOpt
	MarkdownRequestBody
	MarkdownRenderOp
	Ref
	RepoTreeGetOptions
	RepoTreeSearchOptions
	RepoTreeSearchResult
	RepoTreeGetOp
	RepoTreeSearchOp
	RepoTreeListOp
	RepoTreeListResult
	VCSSearchResultList
	TokenSearchOptions
	TextSearchOptions
	SourceCode
	SourceCodeLine
	SourceCodeToken
	TreeEntry
	TreeEntrySpec
	UnitDelta
	UnitListOptions
	UnitSpec
	RepoSourceUnitList
	DefAuthorList
	DefClientList
	Checklist
	FileToken
	ServerStatus
	ServerConfig
	RegisteredClient
	RegisteredClientSpec
	RegisteredClientCredentials
	RegisteredClientListOptions
	RegisteredClientList
	UserPermissions
	UserPermissionsList
	UserPermissionsOptions
	MetricsSnapshot
	UserEvent
	UserEventList
	NotifyGenericEvent
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto"
import diff "sourcegraph.com/sourcegraph/go-diff/diff"
import vcs "sourcegraph.com/sourcegraph/go-vcs/vcs"
import graph "sourcegraph.com/sourcegraph/srclib/graph"
import graph1 "sourcegraph.com/sourcegraph/srclib/graph"
import unit "sourcegraph.com/sourcegraph/srclib/unit"
import vcsclient "sourcegraph.com/sourcegraph/vcsstore/vcsclient"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import pbtypes2 "sourcegraph.com/sqs/pbtypes"
import inventory "src.sourcegraph.com/sourcegraph/pkg/inventory"

// discarding unused import google_api1 "google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// RegisteredClientType is the set of kinds of clients.
type RegisteredClientType int32

const (
	// Any is any type of API client. It should only be used when
	// listing and not actually set on a RegisteredClient object.
	RegisteredClientType_Any RegisteredClientType = 0
	// Other is all other kinds of clients that are not
	// SourcegraphServers.
	RegisteredClientType_Other RegisteredClientType = 1
	// SourcegraphServer indicates this client is a Sourcegraph server
	// instance.
	RegisteredClientType_SourcegraphServer RegisteredClientType = 2
)

var RegisteredClientType_name = map[int32]string{
	0: "Any",
	1: "Other",
	2: "SourcegraphServer",
}
var RegisteredClientType_value = map[string]int32{
	"Any":               0,
	"Other":             1,
	"SourcegraphServer": 2,
}

func (x RegisteredClientType) String() string {
	return proto.EnumName(RegisteredClientType_name, int32(x))
}

// TelemetryType is the format MetricsSnapshot.TelemetryData is encoded in
type TelemetryType int32

const (
	// PrometheusDelimited0dot0dot4 indicates the metrics can be decoded using
	// Prometheus 0.0.4 delimited protobuf format
	TelemetryType_PrometheusDelimited0dot0dot4 TelemetryType = 0
)

var TelemetryType_name = map[int32]string{
	0: "PrometheusDelimited0dot0dot4",
}
var TelemetryType_value = map[string]int32{
	"PrometheusDelimited0dot0dot4": 0,
}

func (x TelemetryType) String() string {
	return proto.EnumName(TelemetryType_name, int32(x))
}

type Badge struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:",omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:",omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:",omitempty"`
}

func (m *Badge) Reset()         { *m = Badge{} }
func (m *Badge) String() string { return proto.CompactTextString(m) }
func (*Badge) ProtoMessage()    {}

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	Rev string `protobuf:"bytes,4,opt,name=rev,proto3" json:",omitempty"`
	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	CommitID string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:",omitempty"`
	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:",omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=statuses" json:",omitempty"`
}

func (m *CombinedStatus) Reset()         { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()    {}

type Counter struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:",omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:",omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:",omitempty"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=per_page,proto3" json:",omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=page,proto3" json:",omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()         { *m = ListOptions{} }
func (m *ListOptions) String() string { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()    {}

// ListResponse specifies a general paginated response when fetching a list of results.
type ListResponse struct {
	// Total is the total number of results in the list.
	Total int32 `protobuf:"varint,1,opt,name=total,proto3" json:",omitempty" url:",omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}

// StreamResponse specifies a paginated response where the total number of results
// that can be returned is too expensive to compute, unbounded, or unknown.
type StreamResponse struct {
	// HasMore is true if there are more results available after the returned page.
	HasMore bool `protobuf:"varint,1,opt,name=has_more,proto3" json:",omitempty" url:",omitempty"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}

// Changeset stores information about a changeset.
type Changeset struct {
	// ID is the unique identifier for this changeset, relative to the repository
	// that contains it.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:",omitempty"`
	// Title holds a summary about this changeset.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:",omitempty"`
	// Description holds the description for this changeset.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:",omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" `
	// DeltaSpec contains information about the base and head spec for this
	// changeset.
	DeltaSpec *DeltaSpec `protobuf:"bytes,5,opt,name=delta_spec" json:",omitempty"`
	// Merged specifies whether this changeset was merged.
	Merged bool `protobuf:"varint,6,opt,name=merged,proto3" json:",omitempty"`
	// CreatedAt holds the creation time of this changeset.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=created_at" json:",omitempty"`
	// ClosedAt holds the time when this changeset was closed or merged.
	ClosedAt *pbtypes.Timestamp `protobuf:"bytes,8,opt,name=closed_at" json:",omitempty"`
}

func (m *Changeset) Reset()         { *m = Changeset{} }
func (m *Changeset) String() string { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()    {}

// ChangesetReview contains information about a review submitted on a changeset.
type ChangesetReview struct {
	// ID holds the unique identifier (with reference to the changeset) of the
	// review.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:",omitempty"`
	// Body holds the text description of the review.
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:",omitempty"`
	// Author is the spec of the user that submitted this review.
	Author UserSpec `protobuf:"bytes,3,opt,name=author" `
	// CreatedAt is the date at which this review was submitted.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,4,opt,name=created_at" json:",omitempty"`
	// EditedAt is the last time at which this review was edited. If the review
	// has never been edited, this value will be nil.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=edited_at" json:",omitempty"`
	// Comments holds any inline comments that were submitted along with this
	// review.
	Comments []*InlineComment `protobuf:"bytes,6,rep,name=comments" json:",omitempty"`
	// Deleted specifies whether this review has been removed.
	Deleted bool `protobuf:"varint,7,opt,name=deleted,proto3" json:",omitempty"`
}

func (m *ChangesetReview) Reset()         { *m = ChangesetReview{} }
func (m *ChangesetReview) String() string { return proto.CompactTextString(m) }
func (*ChangesetReview) ProtoMessage()    {}

// ChangesetEvent holds information about an update that occurred on the
// properties of a Changeset.
type ChangesetEvent struct {
	// Before holds the changeset as it was before the event.
	Before *Changeset `protobuf:"bytes,2,opt,name=before" json:",omitempty"`
	// After holds the changeset as it became after the event.
	After *Changeset `protobuf:"bytes,3,opt,name=after" json:",omitempty"`
	// Op holds the update operation that changed the state.
	Op *ChangesetUpdateOp `protobuf:"bytes,4,opt,name=op" json:",omitempty"`
	// CreatedAt is the date at which the event was created.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=created_at" json:",omitempty"`
}

func (m *ChangesetEvent) Reset()         { *m = ChangesetEvent{} }
func (m *ChangesetEvent) String() string { return proto.CompactTextString(m) }
func (*ChangesetEvent) ProtoMessage()    {}

// InlineComment represents a comment made on a line of code. It is uniquely identified
// via Filename + LineNumber + CommitID. In a Changeset, the CommitID might vary
// within the same file based on whether the comment was made on the lines that
// match the pre-index SHA-1 or the lines that match the post-index SHA-1. Pre
// and post index values may differ from Base and Head of the diff.
// For more information on indexes see http://git-scm.com/docs/git-diff-index
type InlineComment struct {
	// Filename is the name of the file where this comment was made.
	Filename string `protobuf:"bytes,1,opt,name=filename,proto3" json:",omitempty"`
	// LineNumber is the line number relative to the beginning of the file in
	// the specified commit.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,proto3" json:",omitempty"`
	// CommitID is the SHA-1 for the post-image of this file, where the comment
	// was placed. The post-image can be deduced from the file entry in the diff
	// that it belong by extracting it's extended header's index entry.
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" `
	// Body holds the body of this comment.
	Body string `protobuf:"bytes,5,opt,name=body,proto3" json:",omitempty"`
	// CreatedAt holds the creation date of this comment.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:",omitempty"`
	// EditedAt holds the time when this comment was last edited. If no edits occurred,
	// it will be null.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=edited_at" json:",omitempty"`
	// Deleted indicates whether the comment has been deleted.
	Deleted bool `protobuf:"varint,8,opt,name=deleted,proto3" json:",omitempty"`
}

func (m *InlineComment) Reset()         { *m = InlineComment{} }
func (m *InlineComment) String() string { return proto.CompactTextString(m) }
func (*InlineComment) ProtoMessage()    {}

// A Readme represents a formatted "README"-type file in a repository.
type Readme struct {
	// Path is the relative path of this readme file from the repository root.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:",omitempty"`
	// HTML is the formatted HTML of this readme.
	HTML string `protobuf:"bytes,2,opt,name=html,proto3" json:",omitempty"`
}

func (m *Readme) Reset()         { *m = Readme{} }
func (m *Readme) String() string { return proto.CompactTextString(m) }
func (*Readme) ProtoMessage()    {}

// GitHubRepo holds additional metadata about GitHub repos.
type GitHubRepo struct {
	Stars int32 `protobuf:"varint,1,opt,name=stars,proto3" json:",omitempty"`
}

func (m *GitHubRepo) Reset()         { *m = GitHubRepo{} }
func (m *GitHubRepo) String() string { return proto.CompactTextString(m) }
func (*GitHubRepo) ProtoMessage()    {}

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
type RepoConfig struct {
	// Apps is a list of app IDs denoting the applications that are
	// enabled for this repository.
	Apps []string `protobuf:"bytes,1,rep,name=apps" json:",omitempty"`
}

func (m *RepoConfig) Reset()         { *m = RepoConfig{} }
func (m *RepoConfig) String() string { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()    {}

// Repo represents a source code repository.
type Repo struct {
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
	// Origin is populated for repos fetched via federation or
	// discovery. It is the hostname of the host that owns the repo.
	Origin string `protobuf:"bytes,21,opt,name=origin,proto3" json:",omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:",omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:",omitempty"`
	// VCS is the short name of the VCS system that this repository uses: "git" or
	// "hg".
	VCS string `protobuf:"bytes,4,opt,name=vcs,proto3" json:",omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=http_clone_url,proto3" json:",omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=ssh_clone_url,proto3" json:",omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=homepage_url,proto3" json:",omitempty"`
	// HTMLURL is the URL to the repository's main page on the
	// Sourcegraph server.
	HTMLURL string `protobuf:"bytes,22,opt,name=html_url,proto3" json:",omitempty"`
	// DefaultBranch is the default VCS branch used (typically "master" for git
	// repositories and "default" for hg repositories).
	DefaultBranch string `protobuf:"bytes,8,opt,name=default_branch,proto3" json:",omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=language,proto3" json:",omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=blocked,proto3" json:",omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:",omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=fork,proto3" json:",omitempty"`
	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream.
	Mirror bool `protobuf:"varint,13,opt,name=mirror,proto3" json:",omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,14,opt,name=private,proto3" json:",omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,15,opt,name=created_at" json:",omitempty"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,16,opt,name=updated_at" json:",omitempty"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,17,opt,name=pushed_at" json:",omitempty"`
	// Permissions describes the permissions that the current user (or anonymous users,
	// if there is no current user) is granted to this repository.
	Permissions *RepoPermissions `protobuf:"bytes,18,opt,name=permissions" json:",omitempty"`
	GitHub      *GitHubRepo      `protobuf:"bytes,19,opt,name=github" json:",omitempty"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}

type BadgeList struct {
	Badges []*Badge `protobuf:"bytes,1,rep,name=badges" json:",omitempty"`
}

func (m *BadgeList) Reset()         { *m = BadgeList{} }
func (m *BadgeList) String() string { return proto.CompactTextString(m) }
func (*BadgeList) ProtoMessage()    {}

type CounterList struct {
	Counters []*Counter `protobuf:"bytes,1,rep,name=counters" json:",omitempty"`
}

func (m *CounterList) Reset()         { *m = CounterList{} }
func (m *CounterList) String() string { return proto.CompactTextString(m) }
func (*CounterList) ProtoMessage()    {}

type RepoBadgesCountHitsOp struct {
	Repo  RepoSpec           `protobuf:"bytes,1,opt,name=repo" `
	Since *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=since" json:",omitempty"`
}

func (m *RepoBadgesCountHitsOp) Reset()         { *m = RepoBadgesCountHitsOp{} }
func (m *RepoBadgesCountHitsOp) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsOp) ProtoMessage()    {}

type RepoBadgesCountHitsResult struct {
	Hits int32 `protobuf:"varint,1,opt,name=hits,proto3" json:",omitempty"`
}

func (m *RepoBadgesCountHitsResult) Reset()         { *m = RepoBadgesCountHitsResult{} }
func (m *RepoBadgesCountHitsResult) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsResult) ProtoMessage()    {}

type RepoListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty" url:",omitempty"`
	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query       string   `protobuf:"bytes,2,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	URIs        []string `protobuf:"bytes,3,rep,name=uri_s" json:",omitempty" url:",comma,omitempty"`
	Sort        string   `protobuf:"bytes,5,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string   `protobuf:"bytes,6,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	NoFork      bool     `protobuf:"varint,7,opt,name=no_fork,proto3" json:",omitempty" url:",omitempty"`
	Type        string   `protobuf:"bytes,8,opt,name=type,proto3" json:",omitempty" url:",omitempty"`
	Owner       string   `protobuf:"bytes,10,opt,name=owner,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListOptions) Reset()         { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()    {}

// RepoPermissions describes the possible permissions that a user (or an anonymous
// user) can be granted to a repository.
type RepoPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read,proto3" json:",omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:",omitempty"`
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:",omitempty"`
}

func (m *RepoPermissions) Reset()         { *m = RepoPermissions{} }
func (m *RepoPermissions) String() string { return proto.CompactTextString(m) }
func (*RepoPermissions) ProtoMessage()    {}

// RepoRevSpec specifies a repository at a specific commit (or revision specifier,
// such as a branch, which is resolved on the server side to a specific commit).
//
// Filling in CommitID is an optional optimization. It avoids the need for another
// resolution of Rev. If CommitID is filled in, the "Rev" route variable becomes
// "Rev===CommitID" (e.g., "master===af4cd6"). Handlers can parse this string to
// retrieve the pre-resolved commit ID (e.g., "af4cd6") and still return data that
// constructs URLs using the unresolved revspec (e.g., "master").
//
// Why is it important/useful to pass the resolved commit ID instead of just using
// a revspec everywhere? Consider this case. Your application wants to make a bunch
// of requests for resources relating to "master"; for example, it wants to
// retrieve a source file foo.go at master and all of the definitions and
// references contained in the file. This may consist of dozens of API calls. If
// each API call specified just "master", there would be 2 problems: (1) each API
// call would have to re-resolve "master" to its actual commit ID, which takes a
// lot of extra work; and (2) if the "master" ref changed during the API calls (if
// someone pushed in the middle of the API call, for example), then your
// application would receive data from 2 different commits. The solution is for
// your application to resolve the revspec once and pass both the original revspec
// and the resolved commit ID in all API calls it makes.
//
// And why do we want to preserve the unresolved revspec? In this case, your app
// wants to let the user continue browsing "master". If the API data all referred
// to a specific commit ID, then the user would cease browsing master the next time
// she clicked a link on your app. Preserving the revspec gives the user a choice
// whether to use the absolute commit ID or the revspec (similar to how GitHub lets
// you canonicalize a URL with 'y' but does not default to using the canonical
// URL).
type RepoRevSpec struct {
	RepoSpec `protobuf:"bytes,1,opt,name=repo_spec,embedded=repo_spec" `
	Rev      string `protobuf:"bytes,2,opt,name=rev,proto3" json:",omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
}

func (m *RepoRevSpec) Reset()         { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()    {}

// RepoSpec specifies a repository.
type RepoSpec struct {
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
}

func (m *RepoSpec) Reset()         { *m = RepoSpec{} }
func (m *RepoSpec) String() string { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()    {}

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:",omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=target_url,proto3" json:",omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:",omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=context,proto3" json:",omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" `
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=updated_at" `
}

func (m *RepoStatus) Reset()         { *m = RepoStatus{} }
func (m *RepoStatus) String() string { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()    {}

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=repo" `
	Status RepoStatus  `protobuf:"bytes,2,opt,name=status" `
}

func (m *RepoStatusesCreateOp) Reset()         { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()    {}

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=repos" json:",omitempty"`
}

func (m *RepoList) Reset()         { *m = RepoList{} }
func (m *RepoList) String() string { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()    {}

// SrclibDataVersion specifies a srclib store version.
type SrclibDataVersion struct {
	CommitID      string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:",omitempty"`
	CommitsBehind int32  `protobuf:"varint,2,opt,name=commits_behind,proto3" json:",omitempty"`
}

func (m *SrclibDataVersion) Reset()         { *m = SrclibDataVersion{} }
func (m *SrclibDataVersion) String() string { return proto.CompactTextString(m) }
func (*SrclibDataVersion) ProtoMessage()    {}

type RepoConfigureAppOp struct {
	// Repo is the repository whose applications are being configured.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// App is the app ID to enable or disable.
	App string `protobuf:"bytes,2,opt,name=app,proto3" json:",omitempty"`
	// Enable is true if the app should be enabled and false if it
	// should be disabled.
	Enable bool `protobuf:"varint,3,opt,name=enable,proto3" json:",omitempty"`
}

func (m *RepoConfigureAppOp) Reset()         { *m = RepoConfigureAppOp{} }
func (m *RepoConfigureAppOp) String() string { return proto.CompactTextString(m) }
func (*RepoConfigureAppOp) ProtoMessage()    {}

// StorageBucket represents the location where keys are stored.
//
// Understanding the name-spacing of storage objects is often helped by
// visualizing the filesystem-backed implementation, which looks like:
//
//  /repo/<Repo>/<AppName>/<Bucket>/<Key>
//  /global/<AppName>/<Bucket>/<Key>
//
type StorageBucket struct {
	// AppName is the name of the application whose data you are trying to
	// read/write, applications may read and write to each other's data assuming
	// the admin has not restricted such access.
	AppName string `protobuf:"bytes,1,opt,name=app_name,proto3" json:",omitempty"`
	// Repo is the repository URI. If specified storage is considered local to the
	// repository. Otherwise it is considered "global" (i.e. shared across all
	// repositories).
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty"`
	// Name is the bucket name. In filesystem terminology, a bucket is a 'folder'
	// and an object is a 'file'.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:",omitempty"`
}

func (m *StorageBucket) Reset()         { *m = StorageBucket{} }
func (m *StorageBucket) String() string { return proto.CompactTextString(m) }
func (*StorageBucket) ProtoMessage()    {}

// StorageKey is a storage object's key.
type StorageKey struct {
	// Bucket is the bucket name.
	Bucket *StorageBucket `protobuf:"bytes,3,opt,name=bucket" json:",omitempty"`
	// Key is the name of the storage object. In filesystem terminology, this is
	// the 'filename' and thus must be unique against all other key names in the
	// bucket.
	Key string `protobuf:"bytes,4,opt,name=key,proto3" json:",omitempty"`
}

func (m *StorageKey) Reset()         { *m = StorageKey{} }
func (m *StorageKey) String() string { return proto.CompactTextString(m) }
func (*StorageKey) ProtoMessage()    {}

// StorageValue is the value of a storage object.
type StorageValue struct {
	// Value is the value of the object.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:",omitempty"`
}

func (m *StorageValue) Reset()         { *m = StorageValue{} }
func (m *StorageValue) String() string { return proto.CompactTextString(m) }
func (*StorageValue) ProtoMessage()    {}

// StoragePutOp is the parameters for putting an object into storage.
type StoragePutOp struct {
	// Key is the key of the object to put into storage.
	Key StorageKey `protobuf:"bytes,1,opt,name=key" `
	// Value is the value of the object.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:",omitempty"`
}

func (m *StoragePutOp) Reset()         { *m = StoragePutOp{} }
func (m *StoragePutOp) String() string { return proto.CompactTextString(m) }
func (*StoragePutOp) ProtoMessage()    {}

// StorageExists is the result from checking if a storage object exists within
// a bucket.
type StorageExists struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:",omitempty"`
}

func (m *StorageExists) Reset()         { *m = StorageExists{} }
func (m *StorageExists) String() string { return proto.CompactTextString(m) }
func (*StorageExists) ProtoMessage()    {}

// StorageList is the result from listing all the keys in a storage bucket.
type StorageList struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:",omitempty"`
}

func (m *StorageList) Reset()         { *m = StorageList{} }
func (m *StorageList) String() string { return proto.CompactTextString(m) }
func (*StorageList) ProtoMessage()    {}

type ReposCreateOp struct {
	// URI is the desired URI of the new repository.
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
	// VCS is the desired VCS type of the new repository (only "git"
	// is currently supported).
	VCS string `protobuf:"bytes,2,opt,name=vcs,proto3" json:",omitempty"`
	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	CloneURL string `protobuf:"bytes,3,opt,name=clone_url,proto3" json:",omitempty"`
	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	Mirror bool `protobuf:"varint,4,opt,name=mirror,proto3" json:",omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,5,opt,name=private,proto3" json:",omitempty"`
	// Description is the description of the repository.
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:",omitempty"`
	// Language is the primary programming language of the repository.
	Language string `protobuf:"bytes,7,opt,name=language,proto3" json:",omitempty"`
}

func (m *ReposCreateOp) Reset()         { *m = ReposCreateOp{} }
func (m *ReposCreateOp) String() string { return proto.CompactTextString(m) }
func (*ReposCreateOp) ProtoMessage()    {}

// ReposUpdateOp is an operation to update a repository's metadata.
type ReposUpdateOp struct {
	// Repo is the repository to update.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// Description is the new description of the repository. If empty,
	// the description is not changed.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	// Language is the new primary programming language of the
	// repository. If empty, the language is not changed.
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:",omitempty"`
}

func (m *ReposUpdateOp) Reset()         { *m = ReposUpdateOp{} }
func (m *ReposUpdateOp) String() string { return proto.CompactTextString(m) }
func (*ReposUpdateOp) ProtoMessage()    {}

type ReposListCommitsOp struct {
	Repo RepoSpec                `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListCommitsOp) Reset()         { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()    {}

type RepoListCommitsOptions struct {
	Head         string `protobuf:"bytes,1,opt,name=head,proto3" json:",omitempty" url:",omitempty"`
	Base         string `protobuf:"bytes,2,opt,name=base,proto3" json:",omitempty" url:",omitempty"`
	ListOptions  `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
	Path         string `protobuf:"bytes,4,opt,name=path,proto3" json:",omitempty" url:",omitempty"`
	RefreshCache bool   `protobuf:"varint,5,opt,name=refresh_cache,proto3" json:",omitempty" url:",omitempty"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}

type CommitList struct {
	Commits        []*vcs.Commit `protobuf:"bytes,1,rep,name=commits" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *CommitList) Reset()         { *m = CommitList{} }
func (m *CommitList) String() string { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()    {}

type ReposListBranchesOp struct {
	Repo RepoSpec                 `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListBranchesOp) Reset()         { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()    {}

type RepoListBranchesOptions struct {
	IncludeCommit     bool   `protobuf:"varint,4,opt,name=include_commit,proto3" json:",omitempty"`
	BehindAheadBranch string `protobuf:"bytes,5,opt,name=behind_ahead_branch,proto3" json:",omitempty"`
	ContainsCommit    string `protobuf:"bytes,6,opt,name=contains_commit,proto3" json:",omitempty"`
	ListOptions       `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}

type BranchList struct {
	Branches       []*vcs.Branch `protobuf:"bytes,1,rep,name=branches" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *BranchList) Reset()         { *m = BranchList{} }
func (m *BranchList) String() string { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()    {}

type ReposListTagsOp struct {
	Repo RepoSpec             `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListTagsOp) Reset()         { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()    {}

type ReposListCommittersOp struct {
	Repo RepoSpec                   `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListCommittersOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListCommittersOp) Reset()         { *m = ReposListCommittersOp{} }
func (m *ReposListCommittersOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommittersOp) ProtoMessage()    {}

type RepoListCommittersOptions struct {
	Rev         string `protobuf:"bytes,1,opt,name=rev,proto3" json:",omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListCommittersOptions) Reset()         { *m = RepoListCommittersOptions{} }
func (m *RepoListCommittersOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommittersOptions) ProtoMessage()    {}

type CommitterList struct {
	Committers     []*vcs.Committer `protobuf:"bytes,1,rep,name=committers" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *CommitterList) Reset()         { *m = CommitterList{} }
func (m *CommitterList) String() string { return proto.CompactTextString(m) }
func (*CommitterList) ProtoMessage()    {}

type ChangesetCreateOp struct {
	Repo      RepoSpec   `protobuf:"bytes,1,opt,name=repo" `
	Changeset *Changeset `protobuf:"bytes,2,opt,name=changeset" json:",omitempty"`
}

func (m *ChangesetCreateOp) Reset()         { *m = ChangesetCreateOp{} }
func (m *ChangesetCreateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateOp) ProtoMessage()    {}

type ChangesetCreateReviewOp struct {
	Repo        RepoSpec         `protobuf:"bytes,1,opt,name=repo" `
	ChangesetID int64            `protobuf:"varint,2,opt,name=changeset_id,proto3" json:",omitempty"`
	Review      *ChangesetReview `protobuf:"bytes,3,opt,name=review" json:",omitempty"`
}

func (m *ChangesetCreateReviewOp) Reset()         { *m = ChangesetCreateReviewOp{} }
func (m *ChangesetCreateReviewOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateReviewOp) ProtoMessage()    {}

type ChangesetListReviewsOp struct {
	Repo        RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	ChangesetID int64    `protobuf:"varint,2,opt,name=changeset_id,proto3" json:",omitempty"`
}

func (m *ChangesetListReviewsOp) Reset()         { *m = ChangesetListReviewsOp{} }
func (m *ChangesetListReviewsOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListReviewsOp) ProtoMessage()    {}

type ChangesetSpec struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	ID   int64    `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
}

func (m *ChangesetSpec) Reset()         { *m = ChangesetSpec{} }
func (m *ChangesetSpec) String() string { return proto.CompactTextString(m) }
func (*ChangesetSpec) ProtoMessage()    {}

type ChangesetUpdateOp struct {
	// Repo holds the RepoSpec where the Changeset to be updated is located.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// ID holds the ID of the changeset that is to be updated.
	ID int64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
	// Title, if non-empty, will be set as the new title of the changeset.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:",omitempty"`
	// Description, if specified, will become the new description of the changeset.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:",omitempty"`
	// Open, if true, will set the changeset's ClosedAt value to nil.
	Open bool `protobuf:"varint,5,opt,name=open,proto3" json:",omitempty"`
	// Close, if true, will set the ClosedAt date.
	Close bool `protobuf:"varint,6,opt,name=close,proto3" json:",omitempty"`
	// Merged, if true, will update the changeset to indicate that it was priorly
	// merged.
	Merged bool `protobuf:"varint,7,opt,name=merged,proto3" json:",omitempty"`
	// Author is the user that initiated this event.
	Author UserSpec `protobuf:"bytes,8,opt,name=Author" `
}

func (m *ChangesetUpdateOp) Reset()         { *m = ChangesetUpdateOp{} }
func (m *ChangesetUpdateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetUpdateOp) ProtoMessage()    {}

type ChangesetMergeOp struct {
	// Repo holds the RepoSpec where the Changeset to be merged is located.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// ID holds the ID of the changeset that is to be merged.
	ID int64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
	// Message is a text template used to generate a message for the commit of
	// the resulting merge operation. Any of the fields from the changeset are
	// available to use in the template.
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:",omitempty"`
	// Squash, if true, will squash the commits of the head branch into a
	// single commit prior to merging.
	Squash bool `protobuf:"varint,4,opt,name=squash,proto3" json:",omitempty"`
}

func (m *ChangesetMergeOp) Reset()         { *m = ChangesetMergeOp{} }
func (m *ChangesetMergeOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetMergeOp) ProtoMessage()    {}

type ChangesetUpdateAffectedOp struct {
	// Repo holds the RepoSpec which received a commit.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// Branch is the name of the branch which was pushed to.
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:",omitempty"`
	// Last is the SHA1 of the last commit on the branch.
	Last string `protobuf:"bytes,3,opt,name=last,proto3" json:",omitempty"`
	// Commit is the SHA1 of the tip of the newly pushed commits on the branch.
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:",omitempty"`
}

func (m *ChangesetUpdateAffectedOp) Reset()         { *m = ChangesetUpdateAffectedOp{} }
func (m *ChangesetUpdateAffectedOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetUpdateAffectedOp) ProtoMessage()    {}

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListTagsOptions) Reset()         { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()    {}

type TagList struct {
	Tags           []*vcs.Tag `protobuf:"bytes,1,rep,name=tags" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *TagList) Reset()         { *m = TagList{} }
func (m *TagList) String() string { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()    {}

type MirrorReposRefreshVCSOp struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
}

func (m *MirrorReposRefreshVCSOp) Reset()         { *m = MirrorReposRefreshVCSOp{} }
func (m *MirrorReposRefreshVCSOp) String() string { return proto.CompactTextString(m) }
func (*MirrorReposRefreshVCSOp) ProtoMessage()    {}

// VCSCredentials for authentication during communication with VCS remotes.
type VCSCredentials struct {
	// Pass is the password provided to the VCS.
	Pass string `protobuf:"bytes,1,opt,name=pass,proto3" json:",omitempty"`
}

func (m *VCSCredentials) Reset()         { *m = VCSCredentials{} }
func (m *VCSCredentials) String() string { return proto.CompactTextString(m) }
func (*VCSCredentials) ProtoMessage()    {}

type MirroredRepoSSHKeysCreateOp struct {
	Repo RepoSpec      `protobuf:"bytes,1,opt,name=repo" `
	Key  SSHPrivateKey `protobuf:"bytes,2,opt,name=key" `
}

func (m *MirroredRepoSSHKeysCreateOp) Reset()         { *m = MirroredRepoSSHKeysCreateOp{} }
func (m *MirroredRepoSSHKeysCreateOp) String() string { return proto.CompactTextString(m) }
func (*MirroredRepoSSHKeysCreateOp) ProtoMessage()    {}

// An SSHPrivateKey is an SSH key used to access a repository.
type SSHPrivateKey struct {
	// PEM is the encoded key.
	PEM []byte `protobuf:"bytes,2,opt,name=pem,proto3" json:",omitempty"`
}

func (m *SSHPrivateKey) Reset()         { *m = SSHPrivateKey{} }
func (m *SSHPrivateKey) String() string { return proto.CompactTextString(m) }
func (*SSHPrivateKey) ProtoMessage()    {}

// A Build represents a scheduled, completed, or failed repository analysis and
// import job.
//
// A build is composed of many tasks. The worker that is responsible for a build or
// task determines whether a task failure causes the whole build to fail. (Keep
// reading to see how we determine who is responsible for a build or task.) There
// is no single kind of worker; currently there are 2 things that could be
// considered workers because they build builds or perform tasks: the builders on
// Sourcegraph.com, and anyone who runs `src push` locally.
//
// Each task has logs associated with it, and each task can be associated with a
// single source unit (or not).
//
// Builds have a Queue bool field. If a process creates a build that
// has Queue=true, that means that it relinquishes responsibility for
// it; some other queue workers (on the server, for example) will
// dequeue and complete it. If Queue=false, then the process that
// created it is responsible for completing it. The only exception to
// this is that after a certain timeout (on the order of 45 minutes),
// started but unfinished builds are marked as failed.
//
// Builds and tasks are simple "build"ing blocks (no pun intended) with simple
// behavior. As we encounter new requirements for the build system, they may
// evolve.
type Build struct {
	// Attempt is the 1-indexed number representing sequential attempts at building
	// this repository.
	Attempt uint32 `protobuf:"varint,1,opt,name=attempt,proto3" json:",omitempty"`
	// Repo is the URI of the repository this build is for.
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty"`
	// CommitID is the full resolved commit ID to build.
	CommitID    string             `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
	CreatedAt   pbtypes.Timestamp  `protobuf:"bytes,4,opt,name=created_at" `
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=started_at" json:",omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=ended_at" json:",omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=heartbeat_at" json:",omitempty"`
	Success     bool               `protobuf:"varint,8,opt,name=success,proto3" json:",omitempty"`
	Failure     bool               `protobuf:"varint,9,opt,name=failure,proto3" json:",omitempty"`
	// Killed is true if this build's worker didn't exit on its own accord. It is
	// generally set when no heartbeat has been received within a certain interval. If
	// Killed is true, then Failure must also always be set to true. Unqueued builds
	// are never killed for lack of a heartbeat.
	Killed bool `protobuf:"varint,10,opt,name=killed,proto3" json:",omitempty"`
	// Host is the hostname of the machine that is working on this build.
	Host        string `protobuf:"bytes,11,opt,name=host,proto3" json:",omitempty"`
	Purged      bool   `protobuf:"varint,12,opt,name=purged,proto3" json:",omitempty"`
	BuildConfig `protobuf:"bytes,13,opt,name=build_config,embedded=build_config" `
}

func (m *Build) Reset()         { *m = Build{} }
func (m *Build) String() string { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()    {}

// BuildConfig configures a repository build.
type BuildConfig struct {
	// Import is whether to import the build data into the database
	// when the build is complete. The data must be imported for
	// Sourcegraph's web app or API to use it.
	Import bool `protobuf:"varint,1,opt,name=import,proto3" json:",omitempty"`
	// Queue is whether this build should be enqueued. If enqueued, any worker may
	// begin running this build. If not enqueued, it is up to the client to run the
	// build and update it accordingly.
	Queue bool `protobuf:"varint,2,opt,name=queue,proto3" json:",omitempty"`
	// UseCache is whether to use cached build data files. If false, the
	// .sourcegraph-data directory will be wiped out before the build begins.
	//
	// Regardless of the value of UseCache, the build data files will be uploaded to
	// the central cache after the build ends.
	UseCache bool `protobuf:"varint,3,opt,name=use_cache,proto3" json:",omitempty"`
	// Priority of the build in the queue (higher numbers mean the build is dequeued
	// sooner).
	Priority int32 `protobuf:"varint,4,opt,name=priority,proto3" json:",omitempty"`
}

func (m *BuildConfig) Reset()         { *m = BuildConfig{} }
func (m *BuildConfig) String() string { return proto.CompactTextString(m) }
func (*BuildConfig) ProtoMessage()    {}

type BuildCreateOptions struct {
	BuildConfig `protobuf:"bytes,1,opt,name=build_config,embedded=build_config" `
	// Force creation of build. If false, the build will not be created if a build for
	// the same repository and with the same BuildConfig exists.
	//
	// TODO(bliu): test this
	Force bool `protobuf:"varint,2,opt,name=force,proto3" json:",omitempty"`
}

func (m *BuildCreateOptions) Reset()         { *m = BuildCreateOptions{} }
func (m *BuildCreateOptions) String() string { return proto.CompactTextString(m) }
func (*BuildCreateOptions) ProtoMessage()    {}

// BuildGetLogOptions specifies options for build log API methods.
type BuildGetLogOptions struct {
	// MinID indicates that only log entries whose monotonically increasing ID is
	// greater than MinID should be returned.
	//
	// To "tail -f" or watch a log for updates, set each subsequent request's MinID to
	// the MaxID of the previous request.
	MinID string `protobuf:"bytes,1,opt,name=min_id,proto3" json:",omitempty"`
}

func (m *BuildGetLogOptions) Reset()         { *m = BuildGetLogOptions{} }
func (m *BuildGetLogOptions) String() string { return proto.CompactTextString(m) }
func (*BuildGetLogOptions) ProtoMessage()    {}

type BuildListOptions struct {
	Queued      bool   `protobuf:"varint,1,opt,name=queued,proto3" json:",omitempty" url:",omitempty"`
	Active      bool   `protobuf:"varint,2,opt,name=active,proto3" json:",omitempty" url:",omitempty"`
	Ended       bool   `protobuf:"varint,3,opt,name=ended,proto3" json:",omitempty" url:",omitempty"`
	Succeeded   bool   `protobuf:"varint,4,opt,name=succeeded,proto3" json:",omitempty" url:",omitempty"`
	Failed      bool   `protobuf:"varint,5,opt,name=failed,proto3" json:",omitempty" url:",omitempty"`
	Purged      bool   `protobuf:"varint,6,opt,name=purged,proto3" json:",omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,7,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	CommitID    string `protobuf:"bytes,8,opt,name=commit_id,proto3" json:",omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,9,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,10,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *BuildListOptions) Reset()         { *m = BuildListOptions{} }
func (m *BuildListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildListOptions) ProtoMessage()    {}

type ChangesetListOp struct {
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:",omitempty"`
	// Open, when true, will only return open changesets.
	Open bool `protobuf:"varint,2,opt,name=open,proto3" json:",omitempty"`
	// Closed, when true, will only return closed changeset.
	Closed bool `protobuf:"varint,3,opt,name=closed,proto3" json:",omitempty"`
	// Head, if set, will restrict the returned list to only changesets
	// that have this branch as head.
	Head string `protobuf:"bytes,4,opt,name=head,proto3" json:",omitempty"`
	// Base, when set, will restrict the list to changesets that have this
	// branch as a base.
	Base        string `protobuf:"bytes,5,opt,name=base,proto3" json:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *ChangesetListOp) Reset()         { *m = ChangesetListOp{} }
func (m *ChangesetListOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListOp) ProtoMessage()    {}

type BuildSpec struct {
	CommitID string   `protobuf:"bytes,1,opt,name=commit_id,proto3" json:",omitempty"`
	Attempt  uint32   `protobuf:"varint,2,opt,name=attempt,proto3" json:",omitempty"`
	Repo     RepoSpec `protobuf:"bytes,3,opt,name=repo" `
}

func (m *BuildSpec) Reset()         { *m = BuildSpec{} }
func (m *BuildSpec) String() string { return proto.CompactTextString(m) }
func (*BuildSpec) ProtoMessage()    {}

// A BuildTask represents an individual step of a build.
//
// See the documentation for Build for more information about how builds and tasks
// relate to each other.
type BuildTask struct {
	// TaskID is the unique ID of this task. It is unique over all tasks, not just
	// tasks in the same build.
	TaskID int64 `protobuf:"varint,1,opt,name=task_id,proto3" json:",omitempty"`
	// Repo is the URI of the repository that this task's build is for.
	Repo     string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
	Attempt  uint32 `protobuf:"varint,4,opt,name=attempt,proto3" json:",omitempty"`
	// UnitType is the srclib source unit type of the source unit that this task is
	// associated with.
	UnitType string `protobuf:"bytes,5,opt,name=unit_type,proto3" json:",omitempty"`
	// Unit is the srclib source unit name of the source unit that this task is
	// associated with.
	Unit string `protobuf:"bytes,6,opt,name=unit,proto3" json:",omitempty"`
	// Op is the srclib toolchain operation (graph, depresolve, etc.) that this task
	// performs.
	Op string `protobuf:"bytes,7,opt,name=op,proto3" json:",omitempty"`
	// Order is the order in which this task is performed, relative to other tasks in
	// the same build. Lower-number-ordered tasks are built first. Multiple tasks may
	// have the same order.
	Order int32 `protobuf:"varint,8,opt,name=order,proto3" json:",omitempty"`
	// CreatedAt is when this task was initially created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,9,opt,name=created_at" `
	// StartedAt is when this task's execution began.
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,10,opt,name=started_at" json:",omitempty"`
	// EndedAt is when this task's execution ended (whether because it succeeded or
	// failed).
	EndedAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=ended_at" json:",omitempty"`
	// Success is whether this task's execution succeeded.
	Success bool `protobuf:"varint,13,opt,name=success,proto3" json:",omitempty"`
	// Failure is whether this task's execution failed.
	Failure bool `protobuf:"varint,14,opt,name=failure,proto3" json:",omitempty"`
}

func (m *BuildTask) Reset()         { *m = BuildTask{} }
func (m *BuildTask) String() string { return proto.CompactTextString(m) }
func (*BuildTask) ProtoMessage()    {}

type BuildTaskListOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *BuildTaskListOptions) Reset()         { *m = BuildTaskListOptions{} }
func (m *BuildTaskListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildTaskListOptions) ProtoMessage()    {}

// A BuildUpdate contains updated information to update on an existing build.
type BuildUpdate struct {
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:",omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:",omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,3,opt,name=heartbeat_at" json:",omitempty"`
	Host        string             `protobuf:"bytes,4,opt,name=host,proto3" json:",omitempty"`
	Success     bool               `protobuf:"varint,5,opt,name=success,proto3" json:",omitempty"`
	Purged      bool               `protobuf:"varint,6,opt,name=purged,proto3" json:",omitempty"`
	Failure     bool               `protobuf:"varint,7,opt,name=failure,proto3" json:",omitempty"`
	Killed      bool               `protobuf:"varint,8,opt,name=killed,proto3" json:",omitempty"`
	Priority    int32              `protobuf:"varint,9,opt,name=priority,proto3" json:",omitempty"`
}

func (m *BuildUpdate) Reset()         { *m = BuildUpdate{} }
func (m *BuildUpdate) String() string { return proto.CompactTextString(m) }
func (*BuildUpdate) ProtoMessage()    {}

type BuildList struct {
	Builds         []*Build `protobuf:"bytes,1,rep,name=builds" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *BuildList) Reset()         { *m = BuildList{} }
func (m *BuildList) String() string { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()    {}

type BuildsCreateOp struct {
	RepoRev RepoRevSpec         `protobuf:"bytes,1,opt,name=repo_rev" `
	Opt     *BuildCreateOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsCreateOp) Reset()         { *m = BuildsCreateOp{} }
func (m *BuildsCreateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateOp) ProtoMessage()    {}

type BuildsUpdateOp struct {
	Build BuildSpec   `protobuf:"bytes,1,opt,name=build" `
	Info  BuildUpdate `protobuf:"bytes,2,opt,name=info" `
}

func (m *BuildsUpdateOp) Reset()         { *m = BuildsUpdateOp{} }
func (m *BuildsUpdateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateOp) ProtoMessage()    {}

type BuildsListBuildTasksOp struct {
	Build BuildSpec             `protobuf:"bytes,1,opt,name=build" `
	Opt   *BuildTaskListOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsListBuildTasksOp) Reset()         { *m = BuildsListBuildTasksOp{} }
func (m *BuildsListBuildTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsListBuildTasksOp) ProtoMessage()    {}

type BuildTaskList struct {
	BuildTasks []*BuildTask `protobuf:"bytes,1,rep,name=build_tasks" json:",omitempty"`
}

func (m *BuildTaskList) Reset()         { *m = BuildTaskList{} }
func (m *BuildTaskList) String() string { return proto.CompactTextString(m) }
func (*BuildTaskList) ProtoMessage()    {}

type ChangesetReviewList struct {
	Reviews []*ChangesetReview `protobuf:"bytes,1,rep,name=reviews" json:",omitempty"`
}

func (m *ChangesetReviewList) Reset()         { *m = ChangesetReviewList{} }
func (m *ChangesetReviewList) String() string { return proto.CompactTextString(m) }
func (*ChangesetReviewList) ProtoMessage()    {}

type ChangesetList struct {
	Changesets []*Changeset `protobuf:"bytes,1,rep,name=changesets" json:",omitempty"`
}

func (m *ChangesetList) Reset()         { *m = ChangesetList{} }
func (m *ChangesetList) String() string { return proto.CompactTextString(m) }
func (*ChangesetList) ProtoMessage()    {}

type ChangesetEventList struct {
	Events []*ChangesetEvent `protobuf:"bytes,1,rep,name=events" json:",omitempty"`
}

func (m *ChangesetEventList) Reset()         { *m = ChangesetEventList{} }
func (m *ChangesetEventList) String() string { return proto.CompactTextString(m) }
func (*ChangesetEventList) ProtoMessage()    {}

type BuildsCreateTasksOp struct {
	Build BuildSpec    `protobuf:"bytes,1,opt,name=build" `
	Tasks []*BuildTask `protobuf:"bytes,2,rep,name=tasks" json:",omitempty"`
}

func (m *BuildsCreateTasksOp) Reset()         { *m = BuildsCreateTasksOp{} }
func (m *BuildsCreateTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateTasksOp) ProtoMessage()    {}

type BuildsUpdateTaskOp struct {
	Task TaskSpec   `protobuf:"bytes,1,opt,name=task" `
	Info TaskUpdate `protobuf:"bytes,2,opt,name=info" `
}

func (m *BuildsUpdateTaskOp) Reset()         { *m = BuildsUpdateTaskOp{} }
func (m *BuildsUpdateTaskOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateTaskOp) ProtoMessage()    {}

type BuildsGetLogOp struct {
	Build BuildSpec           `protobuf:"bytes,1,opt,name=build" `
	Opt   *BuildGetLogOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsGetLogOp) Reset()         { *m = BuildsGetLogOp{} }
func (m *BuildsGetLogOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetLogOp) ProtoMessage()    {}

type BuildsGetTaskLogOp struct {
	Task TaskSpec            `protobuf:"bytes,1,opt,name=task" `
	Opt  *BuildGetLogOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsGetTaskLogOp) Reset()         { *m = BuildsGetTaskLogOp{} }
func (m *BuildsGetTaskLogOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetTaskLogOp) ProtoMessage()    {}

type BuildsDequeueNextOp struct {
}

func (m *BuildsDequeueNextOp) Reset()         { *m = BuildsDequeueNextOp{} }
func (m *BuildsDequeueNextOp) String() string { return proto.CompactTextString(m) }
func (*BuildsDequeueNextOp) ProtoMessage()    {}

// EmailAddr is an email address associated with a user.
type EmailAddr struct {
	// the email address (case-insensitively compared in the DB and API)
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// whether this email address has been verified
	Verified bool `protobuf:"varint,2,opt,name=verified,proto3" json:",omitempty"`
	// indicates this is the user's primary email (only 1 email can be primary per user)
	Primary bool `protobuf:"varint,3,opt,name=primary,proto3" json:",omitempty"`
	// whether Sourcegraph inferred via public data that this is an email for the user
	Guessed bool `protobuf:"varint,4,opt,name=guessed,proto3" json:",omitempty"`
	// indicates that this email should not be associated with the user (even if guessed in the future)
	Blacklisted bool `protobuf:"varint,5,opt,name=blacklisted,proto3" json:",omitempty"`
}

func (m *EmailAddr) Reset()         { *m = EmailAddr{} }
func (m *EmailAddr) String() string { return proto.CompactTextString(m) }
func (*EmailAddr) ProtoMessage()    {}

type LogEntries struct {
	MaxID   string   `protobuf:"bytes,1,opt,name=max_id,proto3" json:",omitempty"`
	Entries []string `protobuf:"bytes,2,rep,name=entries" json:",omitempty"`
}

func (m *LogEntries) Reset()         { *m = LogEntries{} }
func (m *LogEntries) String() string { return proto.CompactTextString(m) }
func (*LogEntries) ProtoMessage()    {}

type Org struct {
	User `protobuf:"bytes,1,opt,name=user,embedded=user" `
}

func (m *Org) Reset()         { *m = Org{} }
func (m *Org) String() string { return proto.CompactTextString(m) }
func (*Org) ProtoMessage()    {}

type OrgListMembersOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *OrgListMembersOptions) Reset()         { *m = OrgListMembersOptions{} }
func (m *OrgListMembersOptions) String() string { return proto.CompactTextString(m) }
func (*OrgListMembersOptions) ProtoMessage()    {}

// OrgSpec specifies an organization. At least one of Email, Login, and UID must be
// nonempty.
type OrgSpec struct {
	Org string `protobuf:"bytes,1,opt,name=org,proto3" json:",omitempty"`
	UID int32  `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
}

func (m *OrgSpec) Reset()         { *m = OrgSpec{} }
func (m *OrgSpec) String() string { return proto.CompactTextString(m) }
func (*OrgSpec) ProtoMessage()    {}

type OrgsListMembersOp struct {
	Org OrgSpec                `protobuf:"bytes,1,opt,name=org" `
	Opt *OrgListMembersOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *OrgsListMembersOp) Reset()         { *m = OrgsListMembersOp{} }
func (m *OrgsListMembersOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListMembersOp) ProtoMessage()    {}

type UserList struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:",omitempty"`
}

func (m *UserList) Reset()         { *m = UserList{} }
func (m *UserList) String() string { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()    {}

type UserCount struct {
	Count int32 `protobuf:"varint,1,opt,name=Count,proto3" json:",omitempty"`
}

func (m *UserCount) Reset()         { *m = UserCount{} }
func (m *UserCount) String() string { return proto.CompactTextString(m) }
func (*UserCount) ProtoMessage()    {}

// A Person represents either a registered user or a committer to a repository
// (typically when their commit email can't be resolved to a user).
type Person struct {
	// PersonSpec is an identifier for the person. If the person was resolved to a
	// user, then both Login and UID are set. Otherwise only Email is set, and it may
	// be obfuscated (to protect privacy).
	PersonSpec `protobuf:"bytes,1,opt,name=person_spec,embedded=person_spec" `
	// FullName is the (possibly empty) full name of the person.
	FullName string `protobuf:"bytes,2,opt,name=full_name,proto3" json:",omitempty"`
	// AvatarURL is the URL to the user's avatar image.
	AvatarURL string `protobuf:"bytes,3,opt,name=avatar_url,proto3" json:",omitempty"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}

// PersonSpec specifies a person. At least one of Email, Login, and UID must be
// nonempty.
type PersonSpec struct {
	// Email is a person's email address. It may be obfuscated (to protect privacy).
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// Login is a user's login.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:",omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,3,opt,name=uid,proto3" json:",omitempty"`
}

func (m *PersonSpec) Reset()         { *m = PersonSpec{} }
func (m *PersonSpec) String() string { return proto.CompactTextString(m) }
func (*PersonSpec) ProtoMessage()    {}

type TaskSpec struct {
	BuildSpec `protobuf:"bytes,1,opt,name=build_spec,embedded=build_spec" `
	TaskID    int64 `protobuf:"varint,2,opt,name=task_id,proto3" json:",omitempty"`
}

func (m *TaskSpec) Reset()         { *m = TaskSpec{} }
func (m *TaskSpec) String() string { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()    {}

// A TaskUpdate contains updated information to update on an existing task.
type TaskUpdate struct {
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:",omitempty"`
	EndedAt   *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:",omitempty"`
	Success   bool               `protobuf:"varint,3,opt,name=success,proto3" json:",omitempty"`
	Failure   bool               `protobuf:"varint,4,opt,name=failure,proto3" json:",omitempty"`
}

func (m *TaskUpdate) Reset()         { *m = TaskUpdate{} }
func (m *TaskUpdate) String() string { return proto.CompactTextString(m) }
func (*TaskUpdate) ProtoMessage()    {}

// User represents a registered user.
type User struct {
	// UID is the numeric primary key for a user.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	// Login is the user's username.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:",omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
	// Name is the (possibly empty) full name of the user.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:",omitempty"`
	// IsOrganization is whether this user represents an organization.
	IsOrganization bool `protobuf:"varint,5,opt,name=is_organization,proto3" json:",omitempty"`
	// AvatarURL is the URL to an avatar image specified by the user.
	AvatarURL string `protobuf:"bytes,6,opt,name=avatar_url,proto3" json:",omitempty"`
	// Location is the user's physical location.
	Location string `protobuf:"bytes,7,opt,name=location,proto3" json:",omitempty"`
	// Company is the user's company.
	Company string `protobuf:"bytes,8,opt,name=company,proto3" json:",omitempty"`
	// HomepageURL is the user's homepage or blog URL.
	HomepageURL string `protobuf:"bytes,9,opt,name=homepage_url,proto3" json:",omitempty"`
	// Disabled is whether the user account is disabled.
	Disabled bool `protobuf:"varint,10,opt,name=disabled,proto3" json:",omitempty"`
	// Admin is whether the user is a site admin for the site named by
	// the Domain field.
	Admin bool `protobuf:"varint,12,opt,name=admin,proto3" json:",omitempty"`
	// Write is whether the user has write access for the site named by
	// the Domain field.
	Write bool `protobuf:"varint,13,opt,name=write,proto3" json:",omitempty"`
	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	RegisteredAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=registered_at" json:",omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
type UserSpec struct {
	// Login is a user's login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
}

func (m *UserSpec) Reset()         { *m = UserSpec{} }
func (m *UserSpec) String() string { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()    {}

// UsersListOptions specifies options for the UsersService.List method.
type UsersListOptions struct {
	// Query filters the results to only those whose logins match. The search algorithm
	// is an implementation detail (currently it is a prefix match).
	Query       string `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,2,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,3,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" `
}

func (m *UsersListOptions) Reset()         { *m = UsersListOptions{} }
func (m *UsersListOptions) String() string { return proto.CompactTextString(m) }
func (*UsersListOptions) ProtoMessage()    {}

type OrgsListOp struct {
	Member      UserSpec `protobuf:"bytes,1,opt,name=member" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *OrgsListOp) Reset()         { *m = OrgsListOp{} }
func (m *OrgsListOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListOp) ProtoMessage()    {}

type EmailAddrList struct {
	EmailAddrs []*EmailAddr `protobuf:"bytes,1,rep,name=email_addrs" json:",omitempty"`
}

func (m *EmailAddrList) Reset()         { *m = EmailAddrList{} }
func (m *EmailAddrList) String() string { return proto.CompactTextString(m) }
func (*EmailAddrList) ProtoMessage()    {}

type OrgList struct {
	Orgs []*Org `protobuf:"bytes,1,rep,name=orgs" json:",omitempty"`
}

func (m *OrgList) Reset()         { *m = OrgList{} }
func (m *OrgList) String() string { return proto.CompactTextString(m) }
func (*OrgList) ProtoMessage()    {}

type PasswordResetToken struct {
	// token is the hard to guess token that allows a user to set a new password.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:",omitempty"`
}

func (m *PasswordResetToken) Reset()         { *m = PasswordResetToken{} }
func (m *PasswordResetToken) String() string { return proto.CompactTextString(m) }
func (*PasswordResetToken) ProtoMessage()    {}

type PendingPasswordReset struct {
	// Link is the URL for resetting password using this token.
	// It is set in the response only if the request was made
	// by an admin user.
	Link string `protobuf:"bytes,1,opt,name=link,proto3" json:",omitempty"`
	// Token is the hard to guess token that allows a user to
	// set a new password.
	// It is set in the response only if the request was made
	// by an admin user.
	Token *PasswordResetToken `protobuf:"bytes,2,opt,name=token" json:",omitempty"`
	// EmailSent is set if the password reset link was emailed to
	// the user.
	EmailSent bool `protobuf:"varint,3,opt,name=email_sent,proto3" json:",omitempty"`
	// Login is the login name of user for whom this request is created.
	Login string `protobuf:"bytes,4,opt,name=login,proto3" json:",omitempty"`
}

func (m *PendingPasswordReset) Reset()         { *m = PendingPasswordReset{} }
func (m *PendingPasswordReset) String() string { return proto.CompactTextString(m) }
func (*PendingPasswordReset) ProtoMessage()    {}

type NewPassword struct {
	// password is the new password for the user who requested the password reset
	// token.
	Password string              `protobuf:"bytes,1,opt,name=password,proto3" json:",omitempty"`
	Token    *PasswordResetToken `protobuf:"bytes,2,opt,name=token" json:",omitempty"`
}

func (m *NewPassword) Reset()         { *m = NewPassword{} }
func (m *NewPassword) String() string { return proto.CompactTextString(m) }
func (*NewPassword) ProtoMessage()    {}

type NewAccount struct {
	// Login is the desired login for the new user account.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	// Password is the password for the new user account.
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:",omitempty"`
	// UID is the desired UID for the new user account.
	UID int32 `protobuf:"varint,4,opt,name=uid,proto3" json:",omitempty"`
}

func (m *NewAccount) Reset()         { *m = NewAccount{} }
func (m *NewAccount) String() string { return proto.CompactTextString(m) }
func (*NewAccount) ProtoMessage()    {}

type AccountInvite struct {
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// Write, if set, will grant write access to the user.
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:",omitempty"`
	// Admin, if set, will grant admin access to the user.
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:",omitempty"`
}

func (m *AccountInvite) Reset()         { *m = AccountInvite{} }
func (m *AccountInvite) String() string { return proto.CompactTextString(m) }
func (*AccountInvite) ProtoMessage()    {}

// An InviteSpec specifies an existing invite.
type InviteSpec struct {
	// Email is the email address for which the invite was generated.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
}

func (m *InviteSpec) Reset()         { *m = InviteSpec{} }
func (m *InviteSpec) String() string { return proto.CompactTextString(m) }
func (*InviteSpec) ProtoMessage()    {}

type PendingInvite struct {
	// Link is the URL for signing up using this invite.
	Link string `protobuf:"bytes,1,opt,name=link,proto3" json:",omitempty"`
	// Token identifies the pending invite.
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:",omitempty"`
	// EmailSent is set if the invite link was emailed to the user.
	EmailSent bool `protobuf:"varint,3,opt,name=email_sent,proto3" json:",omitempty"`
}

func (m *PendingInvite) Reset()         { *m = PendingInvite{} }
func (m *PendingInvite) String() string { return proto.CompactTextString(m) }
func (*PendingInvite) ProtoMessage()    {}

type AccountInviteList struct {
	Invites []*AccountInvite `protobuf:"bytes,1,rep,name=invites" json:",omitempty"`
}

func (m *AccountInviteList) Reset()         { *m = AccountInviteList{} }
func (m *AccountInviteList) String() string { return proto.CompactTextString(m) }
func (*AccountInviteList) ProtoMessage()    {}

type AcceptedInvite struct {
	// Account holds the desired account details.
	Account *NewAccount `protobuf:"bytes,1,opt,name=account" json:",omitempty"`
	// Token identifies the pending invite.
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:",omitempty"`
}

func (m *AcceptedInvite) Reset()         { *m = AcceptedInvite{} }
func (m *AcceptedInvite) String() string { return proto.CompactTextString(m) }
func (*AcceptedInvite) ProtoMessage()    {}

// SSHPublicKey that users to authenticate with for SSH git access.
type SSHPublicKey struct {
	// Key is the serialized key data in SSH wire format, with the name prefix.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:",omitempty"`
}

func (m *SSHPublicKey) Reset()         { *m = SSHPublicKey{} }
func (m *SSHPublicKey) String() string { return proto.CompactTextString(m) }
func (*SSHPublicKey) ProtoMessage()    {}

// AuthorizationCodeRequest: see
// https://tools.ietf.org/html/rfc6749#section-4.1.1.
type AuthorizationCodeRequest struct {
	ResponseType string   `protobuf:"bytes,1,opt,name=response_type,proto3" json:",omitempty"`
	ClientID     string   `protobuf:"bytes,2,opt,name=client_id,proto3" json:",omitempty"`
	RedirectURI  string   `protobuf:"bytes,3,opt,name=redirect_uri,proto3" json:",omitempty"`
	Scope        []string `protobuf:"bytes,4,rep,name=scope" json:",omitempty"`
	// UID is the UID of the user who will be presented with the code.
	UID int32 `protobuf:"varint,5,opt,name=uid,proto3" json:",omitempty"`
}

func (m *AuthorizationCodeRequest) Reset()         { *m = AuthorizationCodeRequest{} }
func (m *AuthorizationCodeRequest) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCodeRequest) ProtoMessage()    {}

// AuthorizationCode represents an access token request using the
// authorization_code OAuth2 grant type. See
// http://tools.ietf.org/html/rfc6749#section-4.1.3 for more
// information.
//
// The client_id field is not set in this message; it is taken from
// the authenticated client for the request (which must exist).
type AuthorizationCode struct {
	Code        string `protobuf:"bytes,1,opt,name=code,proto3" json:",omitempty"`
	RedirectURI string `protobuf:"bytes,2,opt,name=redirect_uri,proto3" json:",omitempty"`
}

func (m *AuthorizationCode) Reset()         { *m = AuthorizationCode{} }
func (m *AuthorizationCode) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCode) ProtoMessage()    {}

// LoginCredentials is the information a user submits to log in.
type LoginCredentials struct {
	// Login is the user's claimed login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// Password is the password (possibly) corresponding to the login.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:",omitempty"`
}

func (m *LoginCredentials) Reset()         { *m = LoginCredentials{} }
func (m *LoginCredentials) String() string { return proto.CompactTextString(m) }
func (*LoginCredentials) ProtoMessage()    {}

// BearerJWT is a Bearer JSON Web Token, which is used for client
// authentication during an authentication grant. See
// https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12#section-2.1
// for more information.
type BearerJWT struct {
	// Assertion is a JWT.
	Assertion string `protobuf:"bytes,1,opt,name=assertion,proto3" json:",omitempty"`
}

func (m *BearerJWT) Reset()         { *m = BearerJWT{} }
func (m *BearerJWT) String() string { return proto.CompactTextString(m) }
func (*BearerJWT) ProtoMessage()    {}

// AccessTokenRequest contains the information necessary to
// request an OAuth2 access token. It supports a subset of
// authorization grant types specified in
// http://tools.ietf.org/html/rfc6749#section-4.
type AccessTokenRequest struct {
	// See http://tools.ietf.org/html/rfc6749#section-1.3 for more
	// information on OAuth2 authorization grant types.
	//
	// Types that are valid to be assigned to AuthorizationGrant:
	//	*AccessTokenRequest_AuthorizationCode
	//	*AccessTokenRequest_ResourceOwnerPassword
	//	*AccessTokenRequest_BearerJWT
	AuthorizationGrant isAccessTokenRequest_AuthorizationGrant `protobuf_oneof:"authorization_grant"`
	// TokenURL is the token endpoint URL on the OAuth2 authorization
	// server that the client is requesting an access token from.
	TokenURL string   `protobuf:"bytes,9,opt,name=token_url,proto3" json:",omitempty"`
	Scope    []string `protobuf:"bytes,17,rep,name=scope" json:",omitempty"`
}

func (m *AccessTokenRequest) Reset()         { *m = AccessTokenRequest{} }
func (m *AccessTokenRequest) String() string { return proto.CompactTextString(m) }
func (*AccessTokenRequest) ProtoMessage()    {}

type isAccessTokenRequest_AuthorizationGrant interface {
	isAccessTokenRequest_AuthorizationGrant()
}

type AccessTokenRequest_AuthorizationCode struct {
	AuthorizationCode *AuthorizationCode `protobuf:"bytes,1,opt,name=authorization_code,oneof"`
}
type AccessTokenRequest_ResourceOwnerPassword struct {
	ResourceOwnerPassword *LoginCredentials `protobuf:"bytes,2,opt,name=resource_owner_password,oneof"`
}
type AccessTokenRequest_BearerJWT struct {
	BearerJWT *BearerJWT `protobuf:"bytes,3,opt,name=bearer_jwt,oneof"`
}

func (*AccessTokenRequest_AuthorizationCode) isAccessTokenRequest_AuthorizationGrant()     {}
func (*AccessTokenRequest_ResourceOwnerPassword) isAccessTokenRequest_AuthorizationGrant() {}
func (*AccessTokenRequest_BearerJWT) isAccessTokenRequest_AuthorizationGrant()             {}

func (m *AccessTokenRequest) GetAuthorizationGrant() isAccessTokenRequest_AuthorizationGrant {
	if m != nil {
		return m.AuthorizationGrant
	}
	return nil
}

func (m *AccessTokenRequest) GetAuthorizationCode() *AuthorizationCode {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_AuthorizationCode); ok {
		return x.AuthorizationCode
	}
	return nil
}

func (m *AccessTokenRequest) GetResourceOwnerPassword() *LoginCredentials {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_ResourceOwnerPassword); ok {
		return x.ResourceOwnerPassword
	}
	return nil
}

func (m *AccessTokenRequest) GetBearerJWT() *BearerJWT {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_BearerJWT); ok {
		return x.BearerJWT
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessTokenRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _AccessTokenRequest_OneofMarshaler, _AccessTokenRequest_OneofUnmarshaler, []interface{}{
		(*AccessTokenRequest_AuthorizationCode)(nil),
		(*AccessTokenRequest_ResourceOwnerPassword)(nil),
		(*AccessTokenRequest_BearerJWT)(nil),
	}
}

func _AccessTokenRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessTokenRequest)
	// authorization_grant
	switch x := m.AuthorizationGrant.(type) {
	case *AccessTokenRequest_AuthorizationCode:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AuthorizationCode); err != nil {
			return err
		}
	case *AccessTokenRequest_ResourceOwnerPassword:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResourceOwnerPassword); err != nil {
			return err
		}
	case *AccessTokenRequest_BearerJWT:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BearerJWT); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessTokenRequest.AuthorizationGrant has unexpected type %T", x)
	}
	return nil
}

func _AccessTokenRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessTokenRequest)
	switch tag {
	case 1: // authorization_grant.authorization_code
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AuthorizationCode)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_AuthorizationCode{msg}
		return true, err
	case 2: // authorization_grant.resource_owner_password
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoginCredentials)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_ResourceOwnerPassword{msg}
		return true, err
	case 3: // authorization_grant.bearer_jwt
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BearerJWT)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_BearerJWT{msg}
		return true, err
	default:
		return false, nil
	}
}

// AccessTokenResponse is a successful access token response. See
// http://tools.ietf.org/html/rfc6749#section-5.1 for more
// information.
type AccessTokenResponse struct {
	AccessToken  string   `protobuf:"bytes,1,opt,name=access_token,proto3" json:",omitempty"`
	TokenType    string   `protobuf:"bytes,2,opt,name=token_type,proto3" json:",omitempty"`
	ExpiresInSec int32    `protobuf:"varint,3,opt,name=expires_in_sec,proto3" json:",omitempty"`
	RefreshToken string   `protobuf:"bytes,4,opt,name=refresh_token,proto3" json:",omitempty"`
	Scope        []string `protobuf:"bytes,5,rep,name=scope" json:",omitempty"`
}

func (m *AccessTokenResponse) Reset()         { *m = AccessTokenResponse{} }
func (m *AccessTokenResponse) String() string { return proto.CompactTextString(m) }
func (*AccessTokenResponse) ProtoMessage()    {}

// AuthInfo describes the currently authenticated client and/or user
// (if any).
type AuthInfo struct {
	// ClientID is the client ID of the currently authenticated
	// client. If a user is authenticated using an access token,
	// ClientID is the client ID of the registered client that the
	// access token was granted to.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,proto3" json:",omitempty"`
	// UID is the UID of the currently authenticated user (if any).
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	// Domain is the domain of the currently authenticated user (if
	// any), or blank if the user account was registered on the
	// current server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
	// Login is the login of the currently authenticated user (if any).
	Login string `protobuf:"bytes,4,opt,name=login,proto3" json:",omitempty"`
	// Write is set if the user (if any) has write access on this server.
	Write bool `protobuf:"varint,5,opt,name=write,proto3" json:",omitempty"`
	// Admin is set if the user (if any) has admin access on this server.
	Admin bool `protobuf:"varint,6,opt,name=admin,proto3" json:",omitempty"`
	// Scopes represent the permissions granted to the authenticated
	// user (if any).
	Scopes []string `protobuf:"bytes,7,rep,name=scopes" json:",omitempty"`
}

func (m *AuthInfo) Reset()         { *m = AuthInfo{} }
func (m *AuthInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()    {}

type AuthorshipInfo struct {
	AuthorEmail    string            `protobuf:"bytes,1,opt,name=author_email,proto3" json:",omitempty"`
	LastCommitDate pbtypes.Timestamp `protobuf:"bytes,2,opt,name=last_commit_date" `
	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	LastCommitID string `protobuf:"bytes,3,opt,name=last_commit_id,proto3" json:",omitempty"`
}

func (m *AuthorshipInfo) Reset()         { *m = AuthorshipInfo{} }
func (m *AuthorshipInfo) String() string { return proto.CompactTextString(m) }
func (*AuthorshipInfo) ProtoMessage()    {}

// Def is a code def returned by the Sourcegraph API.
type Def struct {
	graph.Def  `protobuf:"bytes,1,opt,name=def,embedded=def" json:""`
	DocHTML    *pbtypes2.HTML          `protobuf:"bytes,2,opt,name=doc_html" json:",omitempty"`
	FmtStrings *graph.DefFormatStrings `protobuf:"bytes,3,opt,name=fmt_strings" json:",omitempty"`
}

func (m *Def) Reset()         { *m = Def{} }
func (m *Def) String() string { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()    {}

type DefAuthor struct {
	UID           int32  `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	Email         string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	DefAuthorship `protobuf:"bytes,3,opt,name=def_authorship,embedded=def_authorship" `
}

func (m *DefAuthor) Reset()         { *m = DefAuthor{} }
func (m *DefAuthor) String() string { return proto.CompactTextString(m) }
func (*DefAuthor) ProtoMessage()    {}

type DefAuthorship struct {
	AuthorshipInfo `protobuf:"bytes,1,opt,name=authorship_info,embedded=authorship_info" `
	// Exported is whether the def is exported.
	Exported        bool    `protobuf:"varint,2,opt,name=exported,proto3" json:",omitempty"`
	Bytes           int32   `protobuf:"varint,3,opt,name=bytes,proto3" json:",omitempty"`
	BytesProportion float64 `protobuf:"fixed64,4,opt,name=bytes_proportion,proto3" json:",omitempty"`
}

func (m *DefAuthorship) Reset()         { *m = DefAuthorship{} }
func (m *DefAuthorship) String() string { return proto.CompactTextString(m) }
func (*DefAuthorship) ProtoMessage()    {}

type DefClient struct {
	UID            int32  `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	Email          string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	AuthorshipInfo `protobuf:"bytes,3,opt,name=authorship_info,embedded=authorship_info" `
	// UseCount is the number of times this person referred to the def.
	UseCount int32 `protobuf:"varint,4,opt,name=use_count,proto3" json:",omitempty"`
}

func (m *DefClient) Reset()         { *m = DefClient{} }
func (m *DefClient) String() string { return proto.CompactTextString(m) }
func (*DefClient) ProtoMessage()    {}

// A DefDelta represents a single definition that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the def was changed from base to head. Otherwise, one of the fields being
// nil means that the def did not exist in that revision (e.g., it was added or
// deleted from base to head).
type DefDelta struct {
	// the def in the base commit (if nil, this def was added in the head)
	Base *Def `protobuf:"bytes,1,opt,name=base" json:",omitempty"`
	// the def in the head commit (if nil, this def was deleted in the head)
	Head *Def `protobuf:"bytes,2,opt,name=head" json:",omitempty"`
}

func (m *DefDelta) Reset()         { *m = DefDelta{} }
func (m *DefDelta) String() string { return proto.CompactTextString(m) }
func (*DefDelta) ProtoMessage()    {}

// DefGetOptions specifies options for DefsService.Get.
type DefGetOptions struct {
	Doc bool `protobuf:"varint,1,opt,name=doc,proto3" json:",omitempty" url:",omitempty"`
}

func (m *DefGetOptions) Reset()         { *m = DefGetOptions{} }
func (m *DefGetOptions) String() string { return proto.CompactTextString(m) }
func (*DefGetOptions) ProtoMessage()    {}

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
type DefListAuthorsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *DefListAuthorsOptions) Reset()         { *m = DefListAuthorsOptions{} }
func (m *DefListAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListAuthorsOptions) ProtoMessage()    {}

// DefListClientsOptions specifies options for DefsService.ListClients.
type DefListClientsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *DefListClientsOptions) Reset()         { *m = DefListClientsOptions{} }
func (m *DefListClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListClientsOptions) ProtoMessage()    {}

// DefListExamplesOptions specifies options for DefsService.ListExamples.
type DefListExamplesOptions struct {
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty" url:",omitempty"`
	// Filter by a specific Repo URI
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:",omitempty" url:",omitempty"`
	ListOptions     `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" `
}

func (m *DefListExamplesOptions) Reset()         { *m = DefListExamplesOptions{} }
func (m *DefListExamplesOptions) String() string { return proto.CompactTextString(m) }
func (*DefListExamplesOptions) ProtoMessage()    {}

// DefListOptions specifies options for DefsService.List.
type DefListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty" url:",omitempty"`
	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteStart uint32 `protobuf:"varint,3,opt,name=byte_start,proto3" json:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteEnd uint32 `protobuf:"varint,4,opt,name=byte_end,proto3" json:",omitempty"`
	// DefKeys, if set, will return the definitions that match the given DefKey
	DefKeys []*graph.DefKey `protobuf:"bytes,5,rep,name=def_keys" json:",omitempty"`
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,6,rep,name=repo_revs" json:",omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,7,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,8,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	Path     string   `protobuf:"bytes,9,opt,name=path,proto3" json:",omitempty" url:",omitempty"`
	// File, if specified, will restrict the results to only defs defined in the
	// specified file.
	File string `protobuf:"bytes,10,opt,name=file,proto3" json:",omitempty" url:",omitempty"`
	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	FilePathPrefix string   `protobuf:"bytes,11,opt,name=file_path_prefix,proto3" json:",omitempty" url:",omitempty"`
	Kinds          []string `protobuf:"bytes,12,rep,name=kinds" json:",omitempty" url:",omitempty,comma"`
	Exported       bool     `protobuf:"varint,13,opt,name=exported,proto3" json:",omitempty" url:",omitempty"`
	Nonlocal       bool     `protobuf:"varint,14,opt,name=nonlocal,proto3" json:",omitempty" url:",omitempty"`
	// IncludeTest is whether the results should include definitions in test files.
	IncludeTest bool `protobuf:"varint,15,opt,name=include_test,proto3" json:",omitempty" url:",omitempty"`
	// Enhancements
	Doc   bool `protobuf:"varint,16,opt,name=doc,proto3" json:",omitempty" url:",omitempty"`
	Fuzzy bool `protobuf:"varint,17,opt,name=fuzzy,proto3" json:",omitempty" url:",omitempty"`
	// Sorting
	Sort      string `protobuf:"bytes,18,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction string `protobuf:"bytes,19,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,20,opt,name=list_options,embedded=list_options" `
}

func (m *DefListOptions) Reset()         { *m = DefListOptions{} }
func (m *DefListOptions) String() string { return proto.CompactTextString(m) }
func (*DefListOptions) ProtoMessage()    {}

type DefListRefsOptions struct {
	Authorship  bool   `protobuf:"varint,1,opt,name=authorship,proto3" json:",omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *DefListRefsOptions) Reset()         { *m = DefListRefsOptions{} }
func (m *DefListRefsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListRefsOptions) ProtoMessage()    {}

// DefSpec specifies a def.
type DefSpec struct {
	Repo     string `protobuf:"bytes,1,opt,name=repo,proto3" json:",omitempty"`
	CommitID string `protobuf:"bytes,2,opt,name=commit_id,proto3" json:",omitempty"`
	UnitType string `protobuf:"bytes,3,opt,name=unit_type,proto3" json:",omitempty"`
	Unit     string `protobuf:"bytes,4,opt,name=unit,proto3" json:",omitempty"`
	Path     string `protobuf:"bytes,5,opt,name=path,proto3" json:",omitempty"`
}

func (m *DefSpec) Reset()         { *m = DefSpec{} }
func (m *DefSpec) String() string { return proto.CompactTextString(m) }
func (*DefSpec) ProtoMessage()    {}

type DefsGetOp struct {
	Def DefSpec        `protobuf:"bytes,1,opt,name=def" `
	Opt *DefGetOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsGetOp) Reset()         { *m = DefsGetOp{} }
func (m *DefsGetOp) String() string { return proto.CompactTextString(m) }
func (*DefsGetOp) ProtoMessage()    {}

type DefList struct {
	Defs         []*Def `protobuf:"bytes,1,rep,name=defs" json:",omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" `
}

func (m *DefList) Reset()         { *m = DefList{} }
func (m *DefList) String() string { return proto.CompactTextString(m) }
func (*DefList) ProtoMessage()    {}

type DefsListRefsOp struct {
	Def DefSpec             `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListRefsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListRefsOp) Reset()         { *m = DefsListRefsOp{} }
func (m *DefsListRefsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListRefsOp) ProtoMessage()    {}

type RefList struct {
	Refs           []*Ref `protobuf:"bytes,1,rep,name=refs" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *RefList) Reset()         { *m = RefList{} }
func (m *RefList) String() string { return proto.CompactTextString(m) }
func (*RefList) ProtoMessage()    {}

type DefsListExamplesOp struct {
	Def DefSpec `protobuf:"bytes,1,opt,name=def" `
	// If set, source code in the examples will be linked to this branch, rather
	// than to the commit ID.
	Rev string                  `protobuf:"bytes,2,opt,name=rev,proto3" json:",omitempty"`
	Opt *DefListExamplesOptions `protobuf:"bytes,3,opt,name=opt" json:",omitempty"`
}

func (m *DefsListExamplesOp) Reset()         { *m = DefsListExamplesOp{} }
func (m *DefsListExamplesOp) String() string { return proto.CompactTextString(m) }
func (*DefsListExamplesOp) ProtoMessage()    {}

type ExampleList struct {
	Examples       []*Example `protobuf:"bytes,1,rep,name=examples" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *ExampleList) Reset()         { *m = ExampleList{} }
func (m *ExampleList) String() string { return proto.CompactTextString(m) }
func (*ExampleList) ProtoMessage()    {}

type DefsListAuthorsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListAuthorsOp) Reset()         { *m = DefsListAuthorsOp{} }
func (m *DefsListAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListAuthorsOp) ProtoMessage()    {}

type DefsListClientsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListClientsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListClientsOp) Reset()         { *m = DefsListClientsOp{} }
func (m *DefsListClientsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListClientsOp) ProtoMessage()    {}

// Delta represents the difference between two commits (possibly in 2 separate
// repositories).
type Delta struct {
	Base       RepoRevSpec `protobuf:"bytes,1,opt,name=base" `
	Head       RepoRevSpec `protobuf:"bytes,2,opt,name=head" `
	BaseCommit *vcs.Commit `protobuf:"bytes,3,opt,name=base_commit" json:",omitempty"`
	HeadCommit *vcs.Commit `protobuf:"bytes,4,opt,name=head_commit" json:",omitempty"`
	BaseRepo   *Repo       `protobuf:"bytes,5,opt,name=base_repo" json:",omitempty"`
	HeadRepo   *Repo       `protobuf:"bytes,6,opt,name=head_repo" json:",omitempty"`
}

func (m *Delta) Reset()         { *m = Delta{} }
func (m *Delta) String() string { return proto.CompactTextString(m) }
func (*Delta) ProtoMessage()    {}

// DeltaAffectedPerson describes a person (registered user or committer email
// address) that is affected by a delta. It includes fields for the person affected
// as well as the defs that are the reason why we consider them to be affected.
//
// The person's relationship to the Defs depends on what method returned this
// DeltaAffectedPerson. If it was returned by a method that lists authors, then the
// Defs are definitions that the Person committed. If it was returned by a method
// that lists clients (a.k.a users), then the Defs are definitions that the Person
// uses.
type DeltaAffectedPerson struct {
	// the affected person
	Person `protobuf:"bytes,1,opt,name=person,embedded=person" `
	// the defs they authored or use (the reason why they're affected)
	Defs []*Def `protobuf:"bytes,2,rep,name=defs" json:",omitempty"`
}

func (m *DeltaAffectedPerson) Reset()         { *m = DeltaAffectedPerson{} }
func (m *DeltaAffectedPerson) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPerson) ProtoMessage()    {}

// DeltaDefs describes definitions added/changed/deleted in a delta.
type DeltaDefs struct {
	// added/changed/deleted defs
	Defs []*DefDelta `protobuf:"bytes,1,rep,name=defs" json:",omitempty"`
	// overall diffstat (not subject to pagination)
	DiffStat diff.Stat `protobuf:"bytes,2,opt,name=diff_stat" `
}

func (m *DeltaDefs) Reset()         { *m = DeltaDefs{} }
func (m *DeltaDefs) String() string { return proto.CompactTextString(m) }
func (*DeltaDefs) ProtoMessage()    {}

// FileDiff holds data about a diff, and additionally stores extended
// information about its hunks.
type FileDiff struct {
	diff.FileDiff `protobuf:"bytes,1,opt,name=file_diff,embedded=file_diff" `
	FileDiffHunks []*Hunk `protobuf:"bytes,2,rep,name=file_diff_hunks" json:",omitempty"`
	// PreImage is the CommitID at which this file was before the change occurred.
	PreImage string `protobuf:"bytes,3,opt,name=pre_image,proto3" json:",omitempty"`
	// PostImage is the CommitID at which this file was after the change occurred.
	PostImage string `protobuf:"bytes,4,opt,name=post_image,proto3" json:",omitempty"`
	// Stat contains statistics about additions and deletions to this diff.
	Stats diff.Stat `protobuf:"bytes,5,opt,name=stats" `
}

func (m *FileDiff) Reset()         { *m = FileDiff{} }
func (m *FileDiff) String() string { return proto.CompactTextString(m) }
func (*FileDiff) ProtoMessage()    {}

// Hunk holds data about a hunk in a diff.
type Hunk struct {
	diff.Hunk `protobuf:"bytes,1,opt,name=hunk,embedded=hunk" `
	// LinePrefixes holds a string where each character's index corresponds
	// to a line in the BodySource, and its value reflects whether the line
	// is an addition, deletion, or change ('+', '-', ' ').
	LinePrefixes string `protobuf:"bytes,2,opt,name=line_prefixes,proto3" json:",omitempty"`
	// BaseSource holds the source code for the original hunk, having all
	// lines starting from the original line down to the end of the hunk.
	BaseSource *SourceCode `protobuf:"bytes,3,opt,name=base_source" json:",omitempty"`
	// HeadSource contains the source code for the new hunk, holding
	// all consecutive lines from the start to the end.
	HeadSource *SourceCode `protobuf:"bytes,4,opt,name=head_source" json:",omitempty"`
	// BodySource contains the source code for the Hunk body and is a mix
	// of both additions and deletions.
	BodySource *SourceCode `protobuf:"bytes,5,opt,name=body_source" json:",omitempty"`
}

func (m *Hunk) Reset()         { *m = Hunk{} }
func (m *Hunk) String() string { return proto.CompactTextString(m) }
func (*Hunk) ProtoMessage()    {}

// DeltaFiles describes files added/changed/deleted in a delta.
type DeltaFiles struct {
	FileDiffs []*FileDiff `protobuf:"bytes,1,rep,name=file_diffs" json:",omitempty"`
	Delta     *Delta      `protobuf:"bytes,2,opt,name=delta" json:",omitempty"`
	Stats     diff.Stat   `protobuf:"bytes,3,opt,name=stats" `
	// OverThreshold will be true when the source code contents of the diff
	// have not been tokenized and linked. This occurs when the 'MaxSize'
	// limit in DeltaListFilesOptions has been met.
	OverThreshold bool `protobuf:"varint,4,opt,name=over_threshold,proto3" json:",omitempty"`
}

func (m *DeltaFiles) Reset()         { *m = DeltaFiles{} }
func (m *DeltaFiles) String() string { return proto.CompactTextString(m) }
func (*DeltaFiles) ProtoMessage()    {}

// DeltaFilter specifies criteria by which to filter results from DeltaListXxx
// methods.
type DeltaFilter struct {
	Unit     string `protobuf:"bytes,1,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	UnitType string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
}

func (m *DeltaFilter) Reset()         { *m = DeltaFilter{} }
func (m *DeltaFilter) String() string { return proto.CompactTextString(m) }
func (*DeltaFilter) ProtoMessage()    {}

// DeltaListAffectedAuthorsOptions specifies options for ListAffectedAuthors.
type DeltaListAffectedAuthorsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListAffectedAuthorsOptions) Reset()         { *m = DeltaListAffectedAuthorsOptions{} }
func (m *DeltaListAffectedAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedAuthorsOptions) ProtoMessage()    {}

// DeltaListAffectedClientsOptions specifies options for ListAffectedClients.
type DeltaListAffectedClientsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListAffectedClientsOptions) Reset()         { *m = DeltaListAffectedClientsOptions{} }
func (m *DeltaListAffectedClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedClientsOptions) ProtoMessage()    {}

// DeltaListDefsOptions specifies options for ListDefs.
type DeltaListDefsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListDefsOptions) Reset()         { *m = DeltaListDefsOptions{} }
func (m *DeltaListDefsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListDefsOptions) ProtoMessage()    {}

// DeltaListFilesOptions specifies options for ListFiles.
type DeltaListFilesOptions struct {
	// Formatted is whether the files should have their contents code-formatted
	// (syntax-highlighted and reference-linked) if they contain code.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty" url:",omitempty"`
	// Filter filters the list of returned files to those whose name matches Filter.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:",omitempty" url:",omitempty"`
	// Tokenized, when set, will tokenize the whole source code
	// contained in the diff, returning 3 versions for each hunk: Head
	// revision, Base revision and Hunk body. For more information,
	// see sourcegraph.Hunk.
	Tokenized bool `protobuf:"varint,3,opt,name=tokenized,proto3" json:",omitempty" url:",omitempty"`
	// MaxSize stores the maximum number of bytes that will be accepted for tokenizing
	// the diff. If the size of the diff exceeds this value, the returned structure
	// will not contain the linked and tokenized source code.
	// This option is useful when one wishes to present the data in a browser and it
	// may be too large for that. DeltaFiles structure size can be up to 4 times the
	// size of the raw diff when tokenized and linked.
	MaxSize     int32 `protobuf:"varint,4,opt,name=max_size,proto3" json:",omitempty" url:",omitempty"`
	DeltaFilter `protobuf:"bytes,5,opt,name=delta_filter,embedded=delta_filter" `
}

func (m *DeltaListFilesOptions) Reset()         { *m = DeltaListFilesOptions{} }
func (m *DeltaListFilesOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListFilesOptions) ProtoMessage()    {}

// DeltaListUnitsOptions specifies options for ListUnits.
type DeltaListUnitsOptions struct {
}

func (m *DeltaListUnitsOptions) Reset()         { *m = DeltaListUnitsOptions{} }
func (m *DeltaListUnitsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListUnitsOptions) ProtoMessage()    {}

// A DeltaSpec specifies a delta.
type DeltaSpec struct {
	Base RepoRevSpec `protobuf:"bytes,1,opt,name=base" `
	Head RepoRevSpec `protobuf:"bytes,2,opt,name=head" `
}

func (m *DeltaSpec) Reset()         { *m = DeltaSpec{} }
func (m *DeltaSpec) String() string { return proto.CompactTextString(m) }
func (*DeltaSpec) ProtoMessage()    {}

type DeltasListUnitsOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListUnitsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListUnitsOp) Reset()         { *m = DeltasListUnitsOp{} }
func (m *DeltasListUnitsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListUnitsOp) ProtoMessage()    {}

type UnitDeltaList struct {
	UnitDeltas []*UnitDelta `protobuf:"bytes,1,rep,name=unit_deltas" json:",omitempty"`
}

func (m *UnitDeltaList) Reset()         { *m = UnitDeltaList{} }
func (m *UnitDeltaList) String() string { return proto.CompactTextString(m) }
func (*UnitDeltaList) ProtoMessage()    {}

type DeltasListDefsOp struct {
	Ds  DeltaSpec             `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListDefsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListDefsOp) Reset()         { *m = DeltasListDefsOp{} }
func (m *DeltasListDefsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListDefsOp) ProtoMessage()    {}

type DeltasListFilesOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListFilesOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListFilesOp) Reset()         { *m = DeltasListFilesOp{} }
func (m *DeltasListFilesOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListFilesOp) ProtoMessage()    {}

type DeltasListAffectedAuthorsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListAffectedAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListAffectedAuthorsOp) Reset()         { *m = DeltasListAffectedAuthorsOp{} }
func (m *DeltasListAffectedAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedAuthorsOp) ProtoMessage()    {}

type DeltaAffectedPersonList struct {
	DeltaAffectedPersons []*DeltaAffectedPerson `protobuf:"bytes,1,rep,name=delta_affected_persons" json:",omitempty"`
}

func (m *DeltaAffectedPersonList) Reset()         { *m = DeltaAffectedPersonList{} }
func (m *DeltaAffectedPersonList) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPersonList) ProtoMessage()    {}

type DeltasListAffectedClientsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListAffectedClientsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListAffectedClientsOp) Reset()         { *m = DeltasListAffectedClientsOp{} }
func (m *DeltasListAffectedClientsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedClientsOp) ProtoMessage()    {}

// Example is a usage example of a def.
type Example struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	// SrcHTML is the formatted HTML source code of the example, with links to
	// definitions.
	SrcHTML string `protobuf:"bytes,2,opt,name=src_html,proto3" json:",omitempty"`
	// SourceCode contains the parsed source for this example, if requested via
	// DefListExamplesOptions.
	SourceCode *SourceCode `protobuf:"bytes,3,opt,name=source_code" json:",omitempty"`
	// The line that the given example starts on
	StartLine int32 `protobuf:"varint,4,opt,name=start_line,proto3" json:",omitempty"`
	// The line that the given example ends on
	EndLine int32 `protobuf:"varint,5,opt,name=end_line,proto3" json:",omitempty"`
	// Error is whether an error occurred while fetching this example.
	Error bool `protobuf:"varint,6,opt,name=error,proto3" json:",omitempty"`
	// If the example has been requested by revision name (ie. branch, tag), this
	// value will be set.
	Rev string `protobuf:"bytes,7,opt,name=rev,proto3" json:",omitempty"`
}

func (m *Example) Reset()         { *m = Example{} }
func (m *Example) String() string { return proto.CompactTextString(m) }
func (*Example) ProtoMessage()    {}

// FormatResult contains information about and warnings from the formatting
// operation (if Formatted is true in the options).
type FormatResult struct {
	// TooManyRefs indicates that the file being formatted exceeded the maximum number
	// of refs that are linked. Only the first NumRefs refs are linked.
	TooManyRefs bool `protobuf:"varint,1,opt,name=too_many_refs,proto3" json:",omitempty"`
	// NumRefs is the number of refs that were linked in this file. If the total number
	// of refs in the file exceeds the (server-defined) limit, NumRefs is capped at the
	// limit.
	NumRefs int32 `protobuf:"varint,2,opt,name=num_refs,proto3" json:",omitempty"`
	// LineStartByteOffsets is the byte offset of each line's first byte.
	LineStartByteOffsets []int32 `protobuf:"varint,3,rep,name=line_start_byte_offsets" json:",omitempty"`
}

func (m *FormatResult) Reset()         { *m = FormatResult{} }
func (m *FormatResult) String() string { return proto.CompactTextString(m) }
func (*FormatResult) ProtoMessage()    {}

type MarkdownData struct {
	Rendered  []byte     `protobuf:"bytes,1,opt,name=rendered,proto3" json:",omitempty"`
	Checklist *Checklist `protobuf:"bytes,2,opt,name=checklist" json:",omitempty"`
}

func (m *MarkdownData) Reset()         { *m = MarkdownData{} }
func (m *MarkdownData) String() string { return proto.CompactTextString(m) }
func (*MarkdownData) ProtoMessage()    {}

type MarkdownOpt struct {
	EnableCheckboxes bool `protobuf:"varint,1,opt,name=enable_checkboxes,proto3" json:",omitempty"`
}

func (m *MarkdownOpt) Reset()         { *m = MarkdownOpt{} }
func (m *MarkdownOpt) String() string { return proto.CompactTextString(m) }
func (*MarkdownOpt) ProtoMessage()    {}

type MarkdownRequestBody struct {
	Markdown    []byte `protobuf:"bytes,1,opt,name=markdown,proto3" json:",omitempty"`
	MarkdownOpt `protobuf:"bytes,2,opt,name=markdown_opt,embedded=markdown_opt" `
}

func (m *MarkdownRequestBody) Reset()         { *m = MarkdownRequestBody{} }
func (m *MarkdownRequestBody) String() string { return proto.CompactTextString(m) }
func (*MarkdownRequestBody) ProtoMessage()    {}

type MarkdownRenderOp struct {
	Markdown []byte      `protobuf:"bytes,1,opt,name=markdown,proto3" json:",omitempty"`
	Opt      MarkdownOpt `protobuf:"bytes,2,opt,name=opt" `
}

func (m *MarkdownRenderOp) Reset()         { *m = MarkdownRenderOp{} }
func (m *MarkdownRenderOp) String() string { return proto.CompactTextString(m) }
func (*MarkdownRenderOp) ProtoMessage()    {}

type Ref struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	Authorship *AuthorshipInfo `protobuf:"bytes,2,opt,name=authorship" json:",omitempty"`
}

func (m *Ref) Reset()         { *m = Ref{} }
func (m *Ref) String() string { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()    {}

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
type RepoTreeGetOptions struct {
	// Formatted is whether the specified entry, if it's a file, should have its
	// Contents code-formatted using HTML.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty"`
	// HighlightStrings is a list of fixed strings that should be wrapped in a <span
	// class="highlight"> in the returned HTML. It only takes effect if Formatted is
	// true.
	HighlightStrings []string `protobuf:"bytes,2,rep,name=highlight_strings" json:",omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource          bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:",omitempty" url:",omitempty"`
	ContentsAsString         bool `protobuf:"varint,4,opt,name=contents_as_string,proto3" json:",omitempty" url:",omitempty"`
	vcsclient.GetFileOptions `protobuf:"bytes,5,opt,name=get_file_options,embedded=get_file_options" `
}

func (m *RepoTreeGetOptions) Reset()         { *m = RepoTreeGetOptions{} }
func (m *RepoTreeGetOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOptions) ProtoMessage()    {}

type RepoTreeSearchOptions struct {
	vcs.SearchOptions `protobuf:"bytes,1,opt,name=search_options,embedded=search_options" `
	Formatted         bool `protobuf:"varint,2,opt,name=formatted,proto3" json:",omitempty"`
}

func (m *RepoTreeSearchOptions) Reset()         { *m = RepoTreeSearchOptions{} }
func (m *RepoTreeSearchOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOptions) ProtoMessage()    {}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
type RepoTreeSearchResult struct {
	vcs.SearchResult `protobuf:"bytes,1,opt,name=search_result,embedded=search_result" `
	RepoRev          RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
}

func (m *RepoTreeSearchResult) Reset()         { *m = RepoTreeSearchResult{} }
func (m *RepoTreeSearchResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchResult) ProtoMessage()    {}

type RepoTreeGetOp struct {
	Entry TreeEntrySpec       `protobuf:"bytes,1,opt,name=entry" `
	Opt   *RepoTreeGetOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *RepoTreeGetOp) Reset()         { *m = RepoTreeGetOp{} }
func (m *RepoTreeGetOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOp) ProtoMessage()    {}

type RepoTreeSearchOp struct {
	Rev RepoRevSpec            `protobuf:"bytes,1,opt,name=rev" `
	Opt *RepoTreeSearchOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *RepoTreeSearchOp) Reset()         { *m = RepoTreeSearchOp{} }
func (m *RepoTreeSearchOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOp) ProtoMessage()    {}

type RepoTreeListOp struct {
	Rev RepoRevSpec `protobuf:"bytes,1,opt,name=rev" `
}

func (m *RepoTreeListOp) Reset()         { *m = RepoTreeListOp{} }
func (m *RepoTreeListOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeListOp) ProtoMessage()    {}

type RepoTreeListResult struct {
	Files []string `protobuf:"bytes,1,rep,name=files" json:",omitempty"`
}

func (m *RepoTreeListResult) Reset()         { *m = RepoTreeListResult{} }
func (m *RepoTreeListResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeListResult) ProtoMessage()    {}

type VCSSearchResultList struct {
	SearchResults []*vcs.SearchResult `protobuf:"bytes,1,rep,name=search_results" json:",omitempty"`
	ListResponse  `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" `
}

func (m *VCSSearchResultList) Reset()         { *m = VCSSearchResultList{} }
func (m *VCSSearchResultList) String() string { return proto.CompactTextString(m) }
func (*VCSSearchResultList) ProtoMessage()    {}

type TokenSearchOptions struct {
	Query       string      `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:"q" schema:"q"`
	RepoRev     RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *TokenSearchOptions) Reset()         { *m = TokenSearchOptions{} }
func (m *TokenSearchOptions) String() string { return proto.CompactTextString(m) }
func (*TokenSearchOptions) ProtoMessage()    {}

type TextSearchOptions struct {
	Query       string      `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:"q" schema:"q"`
	RepoRev     RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *TextSearchOptions) Reset()         { *m = TextSearchOptions{} }
func (m *TextSearchOptions) String() string { return proto.CompactTextString(m) }
func (*TextSearchOptions) ProtoMessage()    {}

// SourceCode contains a snippet of code with linked and classed tokens, along with
// other information about the contents.
//
// This data structure is useful when one desires to take full control of rendering
// and manipulating the contents of the requested TreeEntry or snippet, rather than
// dealing with an (annotated) string or parsing text. To obtain this structure in
// the TreeEntry, TokenizedSource must be set to "true" in the RepoTreeGetOptions.
type SourceCode struct {
	// Lines contains all the lines of the contained code snippet.
	Lines       []*SourceCodeLine `protobuf:"bytes,1,rep,name=lines" json:",omitempty"`
	NumRefs     int32             `protobuf:"varint,2,opt,name=num_refs,proto3" json:",omitempty"`
	TooManyRefs bool              `protobuf:"varint,3,opt,name=too_many_refs,proto3" json:",omitempty"`
}

func (m *SourceCode) Reset()         { *m = SourceCode{} }
func (m *SourceCode) String() string { return proto.CompactTextString(m) }
func (*SourceCode) ProtoMessage()    {}

// SourceCodeLine contains all tokens on this line along with other information
// such as byte offsets in original source.
type SourceCodeLine struct {
	// StartByte and EndByte are the start and end offsets in bytes, in the original
	// file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:",omitempty"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:",omitempty"`
	// Tokens contains any tokens that may be on this line, including whitespace. New
	// lines ('\n') are not present.
	Tokens []*SourceCodeToken `protobuf:"bytes,3,rep,name=tokens" json:",omitempty"`
}

func (m *SourceCodeLine) Reset()         { *m = SourceCodeLine{} }
func (m *SourceCodeLine) String() string { return proto.CompactTextString(m) }
func (*SourceCodeLine) ProtoMessage()    {}

// SourceCodeToken contains information about a code token.
type SourceCodeToken struct {
	// Start and end byte offsets in original file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"-"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:"-"`
	// If the token is a reference URL contains the DefKey-based URLs for all the
	// definitions at this position.
	URL []string `protobuf:"bytes,3,rep,name=url" json:",omitempty"`
	// IsDef specifies whether the token is a definition.
	IsDef bool `protobuf:"varint,4,opt,name=is_def,proto3" json:",omitempty"`
	// Class specifies the token type as per
	// [google-code-prettify](https://code.google.com/p/google-code-prettify/).
	// All tokens except Whitespace will have this field.
	Class string `protobuf:"bytes,5,opt,name=class,proto3" json:",omitempty"`
	// ExtraClasses may additionally contain other classes for this token, such as
	// for example highlighting in a diff.
	ExtraClasses string `protobuf:"bytes,6,opt,name=extraClasses,proto3" json:",omitempty"`
	// Label is non-whitespace HTML encoded source code.
	Label string `protobuf:"bytes,7,opt,name=label,proto3" json:",omitempty"`
}

func (m *SourceCodeToken) Reset()         { *m = SourceCodeToken{} }
func (m *SourceCodeToken) String() string { return proto.CompactTextString(m) }
func (*SourceCodeToken) ProtoMessage()    {}

// TreeEntry is a file or directory in a repository, with additional feedback from
// the formatting operation (if Formatted is true in the options).
type TreeEntry struct {
	*vcsclient.TreeEntry `protobuf:"bytes,1,opt,name=tree_entry,embedded=tree_entry" json:""`
	*vcsclient.FileRange `protobuf:"bytes,2,opt,name=file_range,embedded=file_range" json:",omitempty"`
	ContentsString       string `protobuf:"bytes,3,opt,name=contents_string,proto3" json:",omitempty"`
	// SourceCode is set when TokenizedSource is enabled in RepoTreeGetOptions.
	SourceCode *SourceCode `protobuf:"bytes,4,opt,name=source_code" json:",omitempty"`
	// FormatResult is only set if this TreeEntry is a file.
	FormatResult *FormatResult `protobuf:"bytes,5,opt,name=format_result" json:",omitempty"`
}

func (m *TreeEntry) Reset()         { *m = TreeEntry{} }
func (m *TreeEntry) String() string { return proto.CompactTextString(m) }
func (*TreeEntry) ProtoMessage()    {}

type TreeEntrySpec struct {
	RepoRev RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev" `
	Path    string      `protobuf:"bytes,2,opt,name=path,proto3" json:",omitempty"`
}

func (m *TreeEntrySpec) Reset()         { *m = TreeEntrySpec{} }
func (m *TreeEntrySpec) String() string { return proto.CompactTextString(m) }
func (*TreeEntrySpec) ProtoMessage()    {}

// A UnitDelta represents a single source unit that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the unit was changed from base to head. Otherwise, one of the fields being
// nil means that the unit did not exist in that revision (e.g., it was added or
// deleted from base to head).
type UnitDelta struct {
	Base *unit.RepoSourceUnit `protobuf:"bytes,1,opt,name=base" json:",omitempty"`
	Head *unit.RepoSourceUnit `protobuf:"bytes,2,opt,name=head" json:",omitempty"`
}

func (m *UnitDelta) Reset()         { *m = UnitDelta{} }
func (m *UnitDelta) String() string { return proto.CompactTextString(m) }
func (*UnitDelta) ProtoMessage()    {}

// UnitListOptions specifies options for UnitsService.List.
type UnitListOptions struct {
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,1,rep,name=repo_revs" json:",omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,3,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	// NameQuery specifies a full-text search query over the unit name.
	NameQuery string `protobuf:"bytes,4,opt,name=name_query,proto3" json:",omitempty" url:",omitempty"`
	// Query specifies a full-text search query over the repo URI, unit name, and unit
	// data.
	Query string `protobuf:"bytes,5,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,6,opt,name=list_options,embedded=list_options" `
}

func (m *UnitListOptions) Reset()         { *m = UnitListOptions{} }
func (m *UnitListOptions) String() string { return proto.CompactTextString(m) }
func (*UnitListOptions) ProtoMessage()    {}

// UnitSpec specifies a source unit.
type UnitSpec struct {
	RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev_spec,embedded=repo_rev_spec" `
	UnitType    string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty"`
	Unit        string `protobuf:"bytes,3,opt,name=unit,proto3" json:",omitempty"`
}

func (m *UnitSpec) Reset()         { *m = UnitSpec{} }
func (m *UnitSpec) String() string { return proto.CompactTextString(m) }
func (*UnitSpec) ProtoMessage()    {}

type RepoSourceUnitList struct {
	Units []*unit.RepoSourceUnit `protobuf:"bytes,1,rep,name=units" json:",omitempty"`
}

func (m *RepoSourceUnitList) Reset()         { *m = RepoSourceUnitList{} }
func (m *RepoSourceUnitList) String() string { return proto.CompactTextString(m) }
func (*RepoSourceUnitList) ProtoMessage()    {}

type DefAuthorList struct {
	DefAuthors []*DefAuthor `protobuf:"bytes,1,rep,name=def_authors" json:",omitempty"`
}

func (m *DefAuthorList) Reset()         { *m = DefAuthorList{} }
func (m *DefAuthorList) String() string { return proto.CompactTextString(m) }
func (*DefAuthorList) ProtoMessage()    {}

type DefClientList struct {
	DefClients []*DefClient `protobuf:"bytes,1,rep,name=def_clients" json:",omitempty"`
}

func (m *DefClientList) Reset()         { *m = DefClientList{} }
func (m *DefClientList) String() string { return proto.CompactTextString(m) }
func (*DefClientList) ProtoMessage()    {}

type Checklist struct {
	// number of tasks to be done (unchecked)
	Todo int32 `protobuf:"varint,1,opt,name=todo,proto3" json:",omitempty"`
	// number of tasks that are done (checked)
	Done int32 `protobuf:"varint,2,opt,name=done,proto3" json:",omitempty"`
}

func (m *Checklist) Reset()         { *m = Checklist{} }
func (m *Checklist) String() string { return proto.CompactTextString(m) }
func (*Checklist) ProtoMessage()    {}

type FileToken struct {
	Path  string               `protobuf:"bytes,1,opt,name=path,proto3" json:",omitempty"`
	Entry *vcsclient.TreeEntry `protobuf:"bytes,2,opt,name=entry" json:",omitempty"`
}

func (m *FileToken) Reset()         { *m = FileToken{} }
func (m *FileToken) String() string { return proto.CompactTextString(m) }
func (*FileToken) ProtoMessage()    {}

// ServerStatus describes the server's status.
type ServerStatus struct {
	// Info contains arbitrary human-readable status information about
	// the server.
	Info string `protobuf:"bytes,1,opt,name=info,proto3" json:",omitempty"`
}

func (m *ServerStatus) Reset()         { *m = ServerStatus{} }
func (m *ServerStatus) String() string { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()    {}

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
type ServerConfig struct {
	// Version is the version of Sourcegraph that this server is
	// running.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:",omitempty"`
	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	AppURL string `protobuf:"bytes,2,opt,name=app_url,proto3" json:",omitempty"`
	// FederationRootURL is the --fed.root-url CLI flag's value. It is
	// the URL of the federation root server, or blank if this server
	// is itself a federation root (in which case IsFederationRoot is
	// true).
	FederationRootURL string `protobuf:"bytes,5,opt,name=federation_root_url,proto3" json:",omitempty"`
	// IsFederationRoot is whether this server is itself a federation
	// root. If true, then FederationRootURL is empty.
	IsFederationRoot bool `protobuf:"varint,6,opt,name=is_federation_root,proto3" json:",omitempty"`
	// IDKey is the server's identity key (ID key).
	IDKey string `protobuf:"bytes,7,opt,name=id_key,proto3" json:",omitempty"`
	// AllowAnonymousReaders is whether anonymous (unauthenticated)
	// users may perform "read" operations, such as viewing
	// repositories.
	AllowAnonymousReaders bool `protobuf:"varint,9,opt,name=allow_anonymous_readers,proto3" json:",omitempty"`
	// AuthSource is which mode of authentication is set up on the
	// server (local|oauth|ldap).
	AuthSource string `protobuf:"bytes,10,opt,name=auth_source,proto3" json:",omitempty"`
}

func (m *ServerConfig) Reset()         { *m = ServerConfig{} }
func (m *ServerConfig) String() string { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()    {}

// A RegisteredClient is a registered API client.
//
// Many fields correspond to those listed at
// http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata.
//
// It's called RegisteredClient instead of Client to avoid a name
// conflict with the existing Client (Go) type.
type RegisteredClient struct {
	// ID is a unique identifier for this client.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
	// RedirectURIs is a list of allowed redirect URIs.
	RedirectURIs []string `protobuf:"bytes,2,rep,name=redirect_uris" json:",omitempty"`
	// ClientName is the name of the client to be presented to the
	// end-user.
	ClientName string `protobuf:"bytes,3,opt,name=client_name,proto3" json:",omitempty"`
	// LogoURI is a URL to this client's logo.
	LogoURI string `protobuf:"bytes,4,opt,name=logo_uri,proto3" json:",omitempty"`
	// ClientURI is a URL to this client's homepage.
	ClientURI string `protobuf:"bytes,5,opt,name=client_uri,proto3" json:",omitempty"`
	// JWKS is the client's JSON Web Key Set. It contains the client's
	// public keys, if any.
	JWKS string `protobuf:"bytes,6,opt,name=jwks,proto3" json:",omitempty"`
	// ClientSecret is the secret value that authenticates the
	// client. It may be empty (e.g., if JWKS keys are used for
	// authentication instead).
	ClientSecret string `protobuf:"bytes,7,opt,name=client_secret,proto3" json:",omitempty"`
	// Description is a human-readable description of this API client
	// that's shown to the user during, e.g., OAuth2 authentication.
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:",omitempty"`
	// Meta holds arbitrary metadata about this API client. The
	// structure is defined by the API client and is opaque to the
	// server.
	Meta map[string]string `protobuf:"bytes,9,rep,name=meta" json:",omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// RegisteredClientType describes this client's type.
	Type RegisteredClientType `protobuf:"varint,10,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:",omitempty"`
	// CreatedAt is when this API client's record was created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,11,opt,name=created_at" `
	// UpdatedAt is when this API client's record was last updated.
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,12,opt,name=updated_at" `
}

func (m *RegisteredClient) Reset()         { *m = RegisteredClient{} }
func (m *RegisteredClient) String() string { return proto.CompactTextString(m) }
func (*RegisteredClient) ProtoMessage()    {}

// A RegisteredClientSpec uniquely identifies a RegisteredClient.
type RegisteredClientSpec struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
}

func (m *RegisteredClientSpec) Reset()         { *m = RegisteredClientSpec{} }
func (m *RegisteredClientSpec) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientSpec) ProtoMessage()    {}

// A RegisteredClientCredentials authenticates a RegisteredClient.
type RegisteredClientCredentials struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
	// Secret is the client's secret.
	Secret string `protobuf:"bytes,2,opt,name=secret,proto3" json:",omitempty"`
}

func (m *RegisteredClientCredentials) Reset()         { *m = RegisteredClientCredentials{} }
func (m *RegisteredClientCredentials) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientCredentials) ProtoMessage()    {}

// RegisteredClientListOptions configures a call to
// RegisteredClients.List.
type RegisteredClientListOptions struct {
	Type        RegisteredClientType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:",omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *RegisteredClientListOptions) Reset()         { *m = RegisteredClientListOptions{} }
func (m *RegisteredClientListOptions) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientListOptions) ProtoMessage()    {}

// RegisteredClientList holds a list of clients.
type RegisteredClientList struct {
	Clients        []*RegisteredClient `protobuf:"bytes,1,rep,name=clients" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *RegisteredClientList) Reset()         { *m = RegisteredClientList{} }
func (m *RegisteredClientList) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientList) ProtoMessage()    {}

type UserPermissions struct {
	// UID is a user's UID.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	// ClientID is the ID of the client whose whitelist is to
	// be fetched and/or modified.
	ClientID string `protobuf:"bytes,2,opt,name=client_id,proto3" json:",omitempty"`
	// Read is true if the user has read permissions on the client.
	Read bool `protobuf:"varint,3,opt,name=read,proto3" json:",omitempty"`
	// Write is true if the user has write permissions on the client.
	Write bool `protobuf:"varint,4,opt,name=write,proto3" json:",omitempty"`
	// Admin is true if the user should be considered an admin on
	// the client.
	Admin bool `protobuf:"varint,5,opt,name=admin,proto3" json:",omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}

type UserPermissionsList struct {
	UserPermissions []*UserPermissions `protobuf:"bytes,1,rep,name=user_permissions" json:",omitempty"`
}

func (m *UserPermissionsList) Reset()         { *m = UserPermissionsList{} }
func (m *UserPermissionsList) String() string { return proto.CompactTextString(m) }
func (*UserPermissionsList) ProtoMessage()    {}

type UserPermissionsOptions struct {
	ClientSpec *RegisteredClientSpec `protobuf:"bytes,1,opt,name=client_spec" json:",omitempty"`
	UID        int32                 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
}

func (m *UserPermissionsOptions) Reset()         { *m = UserPermissionsOptions{} }
func (m *UserPermissionsOptions) String() string { return proto.CompactTextString(m) }
func (*UserPermissionsOptions) ProtoMessage()    {}

// MetricsSnapshots encodes
type MetricsSnapshot struct {
	// Type is the encoding of TelemetryData
	Type TelemetryType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.TelemetryType" json:",omitempty"`
	// TelemetryData is the encoded metrics
	TelemetryData []byte `protobuf:"bytes,2,opt,name=telemetry_data,proto3" json:",omitempty"`
}

func (m *MetricsSnapshot) Reset()         { *m = MetricsSnapshot{} }
func (m *MetricsSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetricsSnapshot) ProtoMessage()    {}

// UserEvent encodes any user initiated event on the local instance.
type UserEvent struct {
	Type     string `protobuf:"bytes,1,opt,name=type,proto3" json:",omitempty"`
	UID      int32  `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	ClientID string `protobuf:"bytes,3,opt,name=client_id,proto3" json:",omitempty"`
	Service  string `protobuf:"bytes,4,opt,name=service,proto3" json:",omitempty"`
	Method   string `protobuf:"bytes,5,opt,name=method,proto3" json:",omitempty"`
	Result   string `protobuf:"bytes,6,opt,name=result,proto3" json:",omitempty"`
	// CreatedAt holds the time when this event was logged.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=created_at" json:",omitempty"`
	Message   string             `protobuf:"bytes,8,opt,name=message,proto3" json:",omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,9,opt,name=version,proto3" json:",omitempty"`
	// URL holds the http request url.
	URL string `protobuf:"bytes,10,opt,name=url,proto3" json:",omitempty"`
}

func (m *UserEvent) Reset()         { *m = UserEvent{} }
func (m *UserEvent) String() string { return proto.CompactTextString(m) }
func (*UserEvent) ProtoMessage()    {}

type UserEventList struct {
	Events []*UserEvent `protobuf:"bytes,1,rep,name=events" json:",omitempty"`
}

func (m *UserEventList) Reset()         { *m = UserEventList{} }
func (m *UserEventList) String() string { return proto.CompactTextString(m) }
func (*UserEventList) ProtoMessage()    {}

// NotifyGenericEvent describes an action being done against an object. For
// example reviewing a changeset.
type NotifyGenericEvent struct {
	// Actor is the User who did the action
	Actor *UserSpec `protobuf:"bytes,1,opt,name=actor" json:",omitempty"`
	// Recipients is who should be notified of the action
	Recipients []*UserSpec `protobuf:"bytes,2,rep,name=recipients" json:",omitempty"`
	// ActionType example: "reviewed"
	ActionType string `protobuf:"bytes,3,opt,name=action_type,proto3" json:",omitempty"`
	// ActionContent example: "Please add tests for the new functionality"
	ActionContent string `protobuf:"bytes,4,opt,name=action_content,proto3" json:",omitempty"`
	// ObjectID example: 71
	ObjectID int64 `protobuf:"varint,5,opt,name=object_id,proto3" json:",omitempty"`
	// ObjectRepo example: "gorilla/mux"
	ObjectRepo string `protobuf:"bytes,6,opt,name=object_repo,proto3" json:",omitempty"`
	// ObjectType example: "changeset"
	ObjectType string `protobuf:"bytes,7,opt,name=object_type,proto3" json:",omitempty"`
	// ObjectTitle example: "search: Simplify tokenizer"
	ObjectTitle string `protobuf:"bytes,8,opt,name=object_title,proto3" json:",omitempty"`
	// ObjectURL example: "https://src.sourcegraph.com/sourcegraph/.changesets/71"
	ObjectURL string `protobuf:"bytes,9,opt,name=object_url,proto3" json:",omitempty"`
	// SlackMsg, if present, will override the Slack message for this event.
	SlackMsg string `protobuf:"bytes,10,opt,name=slack_msg,proto3" json:",omitempty"`
	// EmailHTML, if present, will override the notification email body for this event.
	EmailHTML string `protobuf:"bytes,11,opt,name=email_html,proto3" json:",omitempty"`
	// NoEmail turns off the email notification for this event.
	NoEmail bool `protobuf:"varint,13,opt,name=no_email,proto3" json:",omitempty"`
}

func (m *NotifyGenericEvent) Reset()         { *m = NotifyGenericEvent{} }
func (m *NotifyGenericEvent) String() string { return proto.CompactTextString(m) }
func (*NotifyGenericEvent) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("sourcegraph.RegisteredClientType", RegisteredClientType_name, RegisteredClientType_value)
	proto.RegisterEnum("sourcegraph.TelemetryType", TelemetryType_name, TelemetryType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for RepoBadges service

type RepoBadgesClient interface {
	// ListBadges lists the available badges for repo.
	ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error)
}

type repoBadgesClient struct {
	cc *grpc.ClientConn
}

func NewRepoBadgesClient(cc *grpc.ClientConn) RepoBadgesClient {
	return &repoBadgesClient{cc}
}

func (c *repoBadgesClient) ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error) {
	out := new(BadgeList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListBadges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error) {
	out := new(CounterList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListCounters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/RecordHit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error) {
	out := new(RepoBadgesCountHitsResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/CountHits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoBadges service

type RepoBadgesServer interface {
	// ListBadges lists the available badges for repo.
	ListBadges(context.Context, *RepoSpec) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(context.Context, *RepoSpec) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(context.Context, *RepoBadgesCountHitsOp) (*RepoBadgesCountHitsResult, error)
}

func RegisterRepoBadgesServer(s *grpc.Server, srv RepoBadgesServer) {
	s.RegisterService(&_RepoBadges_serviceDesc, srv)
}

func _RepoBadges_ListBadges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListBadges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_ListCounters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListCounters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_RecordHit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).RecordHit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_CountHits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoBadgesCountHitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).CountHits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoBadges_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoBadges",
	HandlerType: (*RepoBadgesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBadges",
			Handler:    _RepoBadges_ListBadges_Handler,
		},
		{
			MethodName: "ListCounters",
			Handler:    _RepoBadges_ListCounters_Handler,
		},
		{
			MethodName: "RecordHit",
			Handler:    _RepoBadges_RecordHit_Handler,
		},
		{
			MethodName: "CountHits",
			Handler:    _RepoBadges_CountHits_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// Create creates a new repository.
	Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error)
	// Update updates a repository.
	Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error)
	// Delete removes a repository.
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error) {
	out := new(Readme)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetReadme", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error) {
	out := new(RepoConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error) {
	out := new(CommitterList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommitters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error) {
	out := new(SrclibDataVersion)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetSrclibDataVersionForPath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ConfigureApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error) {
	out := new(inventory.Inventory)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetInventory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// Create creates a new repository.
	Create(context.Context, *ReposCreateOp) (*Repo, error)
	// Update updates a repository.
	Update(context.Context, *ReposUpdateOp) (*Repo, error)
	// Delete removes a repository.
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(context.Context, *RepoRevSpec) (*Readme, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(context.Context, *RepoSpec) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(context.Context, *ReposListCommittersOp) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(context.Context, *TreeEntrySpec) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(context.Context, *RepoConfigureAppOp) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(context.Context, *RepoRevSpec) (*inventory.Inventory, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetReadme_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetReadme(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetConfig(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommitters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommittersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommitters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetSrclibDataVersionForPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TreeEntrySpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetSrclibDataVersionForPath(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ConfigureApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoConfigureAppOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ConfigureApp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetInventory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Repos_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "GetReadme",
			Handler:    _Repos_GetReadme_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Repos_GetConfig_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
		{
			MethodName: "ListCommitters",
			Handler:    _Repos_ListCommitters_Handler,
		},
		{
			MethodName: "GetSrclibDataVersionForPath",
			Handler:    _Repos_GetSrclibDataVersionForPath_Handler,
		},
		{
			MethodName: "ConfigureApp",
			Handler:    _Repos_ConfigureApp_Handler,
		},
		{
			MethodName: "GetInventory",
			Handler:    _Repos_GetInventory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Storage service

type StorageClient interface {
	// Get gets the value of a storage object.
	//
	// If the specified object does not exist, a NotFound error is returned.
	Get(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageValue, error)
	// Put puts an object into storage overwriting the old object (if any).
	Put(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// PutNoOverwrite puts an object into storage, returning a AlreadyExists error
	// if the object already exists.
	PutNoOverwrite(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete deletes the specific storage object or, if no key is specified, all
	// objects in the bucket.
	//
	// If the given key or bucket does not exist, this function is no-op.
	Delete(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Exists tells if the given key exists in the bucket or not.
	//
	// If the object does not exist, no error is returned, only exists=false is
	// returned.
	Exists(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageExists, error)
	// List lists all objects in the bucket. It ignores the 'key' field of the
	// storage name parameter.
	//
	// If the bucket does not exist, no error is returned, only an empty list is
	// returned.
	List(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageList, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) Get(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageValue, error) {
	out := new(StorageValue)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Put(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) PutNoOverwrite(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/PutNoOverwrite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Exists(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageExists, error) {
	out := new(StorageExists)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Exists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) List(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageList, error) {
	out := new(StorageList)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Storage service

type StorageServer interface {
	// Get gets the value of a storage object.
	//
	// If the specified object does not exist, a NotFound error is returned.
	Get(context.Context, *StorageKey) (*StorageValue, error)
	// Put puts an object into storage overwriting the old object (if any).
	Put(context.Context, *StoragePutOp) (*pbtypes1.Void, error)
	// PutNoOverwrite puts an object into storage, returning a AlreadyExists error
	// if the object already exists.
	PutNoOverwrite(context.Context, *StoragePutOp) (*pbtypes1.Void, error)
	// Delete deletes the specific storage object or, if no key is specified, all
	// objects in the bucket.
	//
	// If the given key or bucket does not exist, this function is no-op.
	Delete(context.Context, *StorageKey) (*pbtypes1.Void, error)
	// Exists tells if the given key exists in the bucket or not.
	//
	// If the object does not exist, no error is returned, only exists=false is
	// returned.
	Exists(context.Context, *StorageKey) (*StorageExists, error)
	// List lists all objects in the bucket. It ignores the 'key' field of the
	// storage name parameter.
	//
	// If the bucket does not exist, no error is returned, only an empty list is
	// returned.
	List(context.Context, *StorageKey) (*StorageList, error)
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StoragePutOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Put(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_PutNoOverwrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StoragePutOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).PutNoOverwrite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Exists(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Storage_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Storage_Put_Handler,
		},
		{
			MethodName: "PutNoOverwrite",
			Handler:    _Storage_PutNoOverwrite_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _Storage_Exists_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Storage_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Changesets service

type ChangesetsClient interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error)
	// List lists changesets for a repository.
	List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error)
	// Update updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error)
	// Merge merges the head branch of a changeset into its base branch and
	// pushes the resulting merged base. It returns the resulting update event.
	// If no merge occurred, it returns nil.
	Merge(ctx context.Context, in *ChangesetMergeOp, opts ...grpc.CallOption) (*ChangesetEvent, error)
	// UpdateAffected updates all changesets which may be affected
	// by new commits to a branch and returns the list of update
	// events for all affected changesets.
	UpdateAffected(ctx context.Context, in *ChangesetUpdateAffectedOp, opts ...grpc.CallOption) (*ChangesetEventList, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error)
}

type changesetsClient struct {
	cc *grpc.ClientConn
}

func NewChangesetsClient(cc *grpc.ClientConn) ChangesetsClient {
	return &changesetsClient{cc}
}

func (c *changesetsClient) Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error) {
	out := new(ChangesetList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error) {
	out := new(ChangesetEvent)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Merge(ctx context.Context, in *ChangesetMergeOp, opts ...grpc.CallOption) (*ChangesetEvent, error) {
	out := new(ChangesetEvent)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Merge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) UpdateAffected(ctx context.Context, in *ChangesetUpdateAffectedOp, opts ...grpc.CallOption) (*ChangesetEventList, error) {
	out := new(ChangesetEventList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/UpdateAffected", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error) {
	out := new(ChangesetReview)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/CreateReview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error) {
	out := new(ChangesetReviewList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListReviews", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error) {
	out := new(ChangesetEventList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Changesets service

type ChangesetsServer interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(context.Context, *ChangesetCreateOp) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(context.Context, *ChangesetSpec) (*Changeset, error)
	// List lists changesets for a repository.
	List(context.Context, *ChangesetListOp) (*ChangesetList, error)
	// Update updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(context.Context, *ChangesetUpdateOp) (*ChangesetEvent, error)
	// Merge merges the head branch of a changeset into its base branch and
	// pushes the resulting merged base. It returns the resulting update event.
	// If no merge occurred, it returns nil.
	Merge(context.Context, *ChangesetMergeOp) (*ChangesetEvent, error)
	// UpdateAffected updates all changesets which may be affected
	// by new commits to a branch and returns the list of update
	// events for all affected changesets.
	UpdateAffected(context.Context, *ChangesetUpdateAffectedOp) (*ChangesetEventList, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(context.Context, *ChangesetCreateReviewOp) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(context.Context, *ChangesetListReviewsOp) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(context.Context, *ChangesetSpec) (*ChangesetEventList, error)
}

func RegisterChangesetsServer(s *grpc.Server, srv ChangesetsServer) {
	s.RegisterService(&_Changesets_serviceDesc, srv)
}

func _Changesets_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Merge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetMergeOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Merge(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_UpdateAffected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetUpdateAffectedOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).UpdateAffected(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_CreateReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetCreateReviewOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).CreateReview(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListReviews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetListReviewsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListReviews(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListEvents(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Changesets_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Changesets",
	HandlerType: (*ChangesetsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Changesets_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Changesets_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Changesets_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Changesets_Update_Handler,
		},
		{
			MethodName: "Merge",
			Handler:    _Changesets_Merge_Handler,
		},
		{
			MethodName: "UpdateAffected",
			Handler:    _Changesets_UpdateAffected_Handler,
		},
		{
			MethodName: "CreateReview",
			Handler:    _Changesets_CreateReview_Handler,
		},
		{
			MethodName: "ListReviews",
			Handler:    _Changesets_ListReviews_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _Changesets_ListEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *MirrorReposRefreshVCSOp) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirrorReposRefreshVCSOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysClient interface {
	Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error)
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirroredRepoSSHKeysClient struct {
	cc *grpc.ClientConn
}

func NewMirroredRepoSSHKeysClient(cc *grpc.ClientConn) MirroredRepoSSHKeysClient {
	return &mirroredRepoSSHKeysClient{cc}
}

func (c *mirroredRepoSSHKeysClient) Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error) {
	out := new(SSHPrivateKey)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysServer interface {
	Create(context.Context, *MirroredRepoSSHKeysCreateOp) (*pbtypes1.Void, error)
	Get(context.Context, *RepoSpec) (*SSHPrivateKey, error)
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
}

func RegisterMirroredRepoSSHKeysServer(s *grpc.Server, srv MirroredRepoSSHKeysServer) {
	s.RegisterService(&_MirroredRepoSSHKeys_serviceDesc, srv)
}

func _MirroredRepoSSHKeys_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirroredRepoSSHKeysCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirroredRepoSSHKeys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirroredRepoSSHKeys",
	HandlerType: (*MirroredRepoSSHKeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MirroredRepoSSHKeys_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MirroredRepoSSHKeys_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MirroredRepoSSHKeys_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Builds service

type BuildsClient interface {
	// Get fetches a build.
	Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error)
	// GetRepoBuild returns the build for the repo at the given exact
	// commit or branch head commit.
	//
	// NOTE: Previously, this method looked at the build and commit
	// history to find the "best recent build." This method no longer
	// implements that functionality. Refer to
	// Repos.GetSrclibDataVersionForPath.
	GetRepoBuild(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Build, error)
	// List builds.
	List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error)
	// GetLog gets log entries associated with a build.
	GetLog(ctx context.Context, in *BuildsGetLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error)
}

type buildsClient struct {
	cc *grpc.ClientConn
}

func NewBuildsClient(cc *grpc.ClientConn) BuildsClient {
	return &buildsClient{cc}
}

func (c *buildsClient) Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetRepoBuild(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetRepoBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/ListBuildTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/CreateTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error) {
	out := new(BuildTask)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/UpdateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetLog(ctx context.Context, in *BuildsGetLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetTaskLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/DequeueNext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Builds service

type BuildsServer interface {
	// Get fetches a build.
	Get(context.Context, *BuildSpec) (*Build, error)
	// GetRepoBuild returns the build for the repo at the given exact
	// commit or branch head commit.
	//
	// NOTE: Previously, this method looked at the build and commit
	// history to find the "best recent build." This method no longer
	// implements that functionality. Refer to
	// Repos.GetSrclibDataVersionForPath.
	GetRepoBuild(context.Context, *RepoRevSpec) (*Build, error)
	// List builds.
	List(context.Context, *BuildListOptions) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(context.Context, *BuildsCreateOp) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(context.Context, *BuildsUpdateOp) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(context.Context, *BuildsListBuildTasksOp) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(context.Context, *BuildsCreateTasksOp) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(context.Context, *BuildsUpdateTaskOp) (*BuildTask, error)
	// GetLog gets log entries associated with a build.
	GetLog(context.Context, *BuildsGetLogOp) (*LogEntries, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(context.Context, *BuildsGetTaskLogOp) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(context.Context, *BuildsDequeueNextOp) (*Build, error)
}

func RegisterBuildsServer(s *grpc.Server, srv BuildsServer) {
	s.RegisterService(&_Builds_serviceDesc, srv)
}

func _Builds_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetRepoBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetRepoBuild(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_ListBuildTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsListBuildTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).ListBuildTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_CreateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).CreateTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateTaskOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).UpdateTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsGetLogOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetTaskLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsGetTaskLogOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetTaskLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_DequeueNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsDequeueNextOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).DequeueNext(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Builds_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Builds",
	HandlerType: (*BuildsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Builds_Get_Handler,
		},
		{
			MethodName: "GetRepoBuild",
			Handler:    _Builds_GetRepoBuild_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Builds_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Builds_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Builds_Update_Handler,
		},
		{
			MethodName: "ListBuildTasks",
			Handler:    _Builds_ListBuildTasks_Handler,
		},
		{
			MethodName: "CreateTasks",
			Handler:    _Builds_CreateTasks_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Builds_UpdateTask_Handler,
		},
		{
			MethodName: "GetLog",
			Handler:    _Builds_GetLog_Handler,
		},
		{
			MethodName: "GetTaskLog",
			Handler:    _Builds_GetTaskLog_Handler,
		},
		{
			MethodName: "DequeueNext",
			Handler:    _Builds_DequeueNext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Orgs service

type OrgsClient interface {
	// Get fetches an organization.
	Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error)
	// List lists organizations that a user is a member of.
	List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error)
}

type orgsClient struct {
	cc *grpc.ClientConn
}

func NewOrgsClient(cc *grpc.ClientConn) OrgsClient {
	return &orgsClient{cc}
}

func (c *orgsClient) Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error) {
	out := new(Org)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error) {
	out := new(OrgList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/ListMembers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Orgs service

type OrgsServer interface {
	// Get fetches an organization.
	Get(context.Context, *OrgSpec) (*Org, error)
	// List lists organizations that a user is a member of.
	List(context.Context, *OrgsListOp) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(context.Context, *OrgsListMembersOp) (*UserList, error)
}

func RegisterOrgsServer(s *grpc.Server, srv OrgsServer) {
	s.RegisterService(&_Orgs_serviceDesc, srv)
}

func _Orgs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_ListMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListMembersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).ListMembers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Orgs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Orgs",
	HandlerType: (*OrgsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Orgs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Orgs_List_Handler,
		},
		{
			MethodName: "ListMembers",
			Handler:    _Orgs_ListMembers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for People service

type PeopleClient interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error)
}

type peopleClient struct {
	cc *grpc.ClientConn
}

func NewPeopleClient(cc *grpc.ClientConn) PeopleClient {
	return &peopleClient{cc}
}

func (c *peopleClient) Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error) {
	out := new(Person)
	err := grpc.Invoke(ctx, "/sourcegraph.People/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for People service

type PeopleServer interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(context.Context, *PersonSpec) (*Person, error)
}

func RegisterPeopleServer(s *grpc.Server, srv PeopleServer) {
	s.RegisterService(&_People_serviceDesc, srv)
}

func _People_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PeopleServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _People_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.People",
	HandlerType: (*PeopleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _People_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Accounts service

type AccountsClient interface {
	// Create creates a new user account.
	Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Invite creates a pending invite and notifies the recipient via email.
	Invite(ctx context.Context, in *AccountInvite, opts ...grpc.CallOption) (*PendingInvite, error)
	// AcceptInvite uses a pending invite to create a new user account.
	AcceptInvite(ctx context.Context, in *AcceptedInvite, opts ...grpc.CallOption) (*UserSpec, error)
	// ListInvites lists the pending invites on this server.
	ListInvites(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AccountInviteList, error)
	// DeleteInvite deletes an existing invite.
	DeleteInvite(ctx context.Context, in *InviteSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type accountsClient struct {
	cc *grpc.ClientConn
}

func NewAccountsClient(cc *grpc.ClientConn) AccountsClient {
	return &accountsClient{cc}
}

func (c *accountsClient) Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error) {
	out := new(PendingPasswordReset)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/RequestPasswordReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ResetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Invite(ctx context.Context, in *AccountInvite, opts ...grpc.CallOption) (*PendingInvite, error) {
	out := new(PendingInvite)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Invite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) AcceptInvite(ctx context.Context, in *AcceptedInvite, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/AcceptInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ListInvites(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AccountInviteList, error) {
	out := new(AccountInviteList)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ListInvites", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) DeleteInvite(ctx context.Context, in *InviteSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/DeleteInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Accounts service

type AccountsServer interface {
	// Create creates a new user account.
	Create(context.Context, *NewAccount) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(context.Context, *PersonSpec) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(context.Context, *NewPassword) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(context.Context, *User) (*pbtypes1.Void, error)
	// Invite creates a pending invite and notifies the recipient via email.
	Invite(context.Context, *AccountInvite) (*PendingInvite, error)
	// AcceptInvite uses a pending invite to create a new user account.
	AcceptInvite(context.Context, *AcceptedInvite) (*UserSpec, error)
	// ListInvites lists the pending invites on this server.
	ListInvites(context.Context, *pbtypes1.Void) (*AccountInviteList, error)
	// DeleteInvite deletes an existing invite.
	DeleteInvite(context.Context, *InviteSpec) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(context.Context, *PersonSpec) (*pbtypes1.Void, error)
}

func RegisterAccountsServer(s *grpc.Server, srv AccountsServer) {
	s.RegisterService(&_Accounts_serviceDesc, srv)
}

func _Accounts_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).RequestPasswordReset(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ResetPassword(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Invite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AccountInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Invite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_AcceptInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AcceptedInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).AcceptInvite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ListInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ListInvites(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_DeleteInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InviteSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).DeleteInvite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Accounts_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Accounts",
	HandlerType: (*AccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Accounts_Create_Handler,
		},
		{
			MethodName: "RequestPasswordReset",
			Handler:    _Accounts_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _Accounts_ResetPassword_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Accounts_Update_Handler,
		},
		{
			MethodName: "Invite",
			Handler:    _Accounts_Invite_Handler,
		},
		{
			MethodName: "AcceptInvite",
			Handler:    _Accounts_AcceptInvite_Handler,
		},
		{
			MethodName: "ListInvites",
			Handler:    _Accounts_ListInvites_Handler,
		},
		{
			MethodName: "DeleteInvite",
			Handler:    _Accounts_DeleteInvite_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Accounts_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Users service

type UsersClient interface {
	// Get fetches a user.
	Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error)
	// List users.
	List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/GetWithEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error) {
	out := new(EmailAddrList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/ListEmails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error) {
	out := new(UserCount)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Count", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Users service

type UsersServer interface {
	// Get fetches a user.
	Get(context.Context, *UserSpec) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(context.Context, *EmailAddr) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(context.Context, *UserSpec) (*EmailAddrList, error)
	// List users.
	List(context.Context, *UsersListOptions) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(context.Context, *pbtypes1.Void) (*UserCount, error)
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_GetWithEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EmailAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).GetWithEmail(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_ListEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).ListEmails(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UsersListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Count(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Users_Get_Handler,
		},
		{
			MethodName: "GetWithEmail",
			Handler:    _Users_GetWithEmail_Handler,
		},
		{
			MethodName: "ListEmails",
			Handler:    _Users_ListEmails_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Users_List_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Users_Count_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for UserKeys service

type UserKeysClient interface {
	// AddKey adds an SSH public key for the user, enabling them to use git over SSH.
	AddKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// LookupUser looks up a user based on the given public key.
	LookupUser(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*UserSpec, error)
	// DeleteKey deletes the user's SSH public key.
	DeleteKey(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type userKeysClient struct {
	cc *grpc.ClientConn
}

func NewUserKeysClient(cc *grpc.ClientConn) UserKeysClient {
	return &userKeysClient{cc}
}

func (c *userKeysClient) AddKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/AddKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) LookupUser(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/LookupUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) DeleteKey(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/DeleteKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserKeys service

type UserKeysServer interface {
	// AddKey adds an SSH public key for the user, enabling them to use git over SSH.
	AddKey(context.Context, *SSHPublicKey) (*pbtypes1.Void, error)
	// LookupUser looks up a user based on the given public key.
	LookupUser(context.Context, *SSHPublicKey) (*UserSpec, error)
	// DeleteKey deletes the user's SSH public key.
	DeleteKey(context.Context, *pbtypes1.Void) (*pbtypes1.Void, error)
}

func RegisterUserKeysServer(s *grpc.Server, srv UserKeysServer) {
	s.RegisterService(&_UserKeys_serviceDesc, srv)
}

func _UserKeys_AddKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SSHPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).AddKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_LookupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SSHPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).LookupUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).DeleteKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UserKeys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.UserKeys",
	HandlerType: (*UserKeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddKey",
			Handler:    _UserKeys_AddKey_Handler,
		},
		{
			MethodName: "LookupUser",
			Handler:    _UserKeys_LookupUser_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _UserKeys_DeleteKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Auth service

type AuthClient interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error) {
	out := new(AuthorizationCode)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAuthorizationCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error) {
	out := new(AccessTokenResponse)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error) {
	out := new(AuthInfo)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/Identify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(context.Context, *AuthorizationCodeRequest) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(context.Context, *AccessTokenRequest) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(context.Context, *pbtypes1.Void) (*AuthInfo, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_GetAuthorizationCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AuthorizationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAuthorizationCode(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAccessToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_Identify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).Identify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthorizationCode",
			Handler:    _Auth_GetAuthorizationCode_Handler,
		},
		{
			MethodName: "GetAccessToken",
			Handler:    _Auth_GetAccessToken_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Auth_Identify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Defs service

type DefsClient interface {
	// Get fetches a def.
	Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error)
	// List defs.
	List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error)
}

type defsClient struct {
	cc *grpc.ClientConn
}

func NewDefsClient(cc *grpc.ClientConn) DefsClient {
	return &defsClient{cc}
}

func (c *defsClient) Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error) {
	out := new(Def)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error) {
	out := new(RefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error) {
	out := new(ExampleList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListExamples", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error) {
	out := new(DefAuthorList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error) {
	out := new(DefClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Defs service

type DefsServer interface {
	// Get fetches a def.
	Get(context.Context, *DefsGetOp) (*Def, error)
	// List defs.
	List(context.Context, *DefListOptions) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(context.Context, *DefsListRefsOp) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(context.Context, *DefsListExamplesOp) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(context.Context, *DefsListAuthorsOp) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(context.Context, *DefsListClientsOp) (*DefClientList, error)
}

func RegisterDefsServer(s *grpc.Server, srv DefsServer) {
	s.RegisterService(&_Defs_serviceDesc, srv)
}

func _Defs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListExamplesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListExamples(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListClientsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Defs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Defs",
	HandlerType: (*DefsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Defs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Defs_List_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Defs_ListRefs_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Defs_ListExamples_Handler,
		},
		{
			MethodName: "ListAuthors",
			Handler:    _Defs_ListAuthors_Handler,
		},
		{
			MethodName: "ListClients",
			Handler:    _Defs_ListClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Deltas service

type DeltasClient interface {
	// Get fetches a summary of a delta.
	Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
}

type deltasClient struct {
	cc *grpc.ClientConn
}

func NewDeltasClient(cc *grpc.ClientConn) DeltasClient {
	return &deltasClient{cc}
}

func (c *deltasClient) Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error) {
	out := new(Delta)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error) {
	out := new(UnitDeltaList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListUnits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error) {
	out := new(DeltaDefs)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListDefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error) {
	out := new(DeltaFiles)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Deltas service

type DeltasServer interface {
	// Get fetches a summary of a delta.
	Get(context.Context, *DeltaSpec) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(context.Context, *DeltasListUnitsOp) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(context.Context, *DeltasListDefsOp) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(context.Context, *DeltasListFilesOp) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(context.Context, *DeltasListAffectedAuthorsOp) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(context.Context, *DeltasListAffectedClientsOp) (*DeltaAffectedPersonList, error)
}

func RegisterDeltasServer(s *grpc.Server, srv DeltasServer) {
	s.RegisterService(&_Deltas_serviceDesc, srv)
}

func _Deltas_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltaSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListUnitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListUnits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListDefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListDefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListDefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListFilesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListFiles(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListAffectedAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListAffectedClientsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Deltas_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Deltas",
	HandlerType: (*DeltasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Deltas_Get_Handler,
		},
		{
			MethodName: "ListUnits",
			Handler:    _Deltas_ListUnits_Handler,
		},
		{
			MethodName: "ListDefs",
			Handler:    _Deltas_ListDefs_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _Deltas_ListFiles_Handler,
		},
		{
			MethodName: "ListAffectedAuthors",
			Handler:    _Deltas_ListAffectedAuthors_Handler,
		},
		{
			MethodName: "ListAffectedClients",
			Handler:    _Deltas_ListAffectedClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Markdown service

type MarkdownClient interface {
	Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error)
}

type markdownClient struct {
	cc *grpc.ClientConn
}

func NewMarkdownClient(cc *grpc.ClientConn) MarkdownClient {
	return &markdownClient{cc}
}

func (c *markdownClient) Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error) {
	out := new(MarkdownData)
	err := grpc.Invoke(ctx, "/sourcegraph.Markdown/Render", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Markdown service

type MarkdownServer interface {
	Render(context.Context, *MarkdownRenderOp) (*MarkdownData, error)
}

func RegisterMarkdownServer(s *grpc.Server, srv MarkdownServer) {
	s.RegisterService(&_Markdown_serviceDesc, srv)
}

func _Markdown_Render_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MarkdownRenderOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MarkdownServer).Render(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Markdown_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Markdown",
	HandlerType: (*MarkdownServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Render",
			Handler:    _Markdown_Render_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoTree service

type RepoTreeClient interface {
	Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error)
	Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error)
}

type repoTreeClient struct {
	cc *grpc.ClientConn
}

func NewRepoTreeClient(cc *grpc.ClientConn) RepoTreeClient {
	return &repoTreeClient{cc}
}

func (c *repoTreeClient) Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error) {
	out := new(TreeEntry)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error) {
	out := new(RepoTreeListResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoTree service

type RepoTreeServer interface {
	Get(context.Context, *RepoTreeGetOp) (*TreeEntry, error)
	Search(context.Context, *RepoTreeSearchOp) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(context.Context, *RepoTreeListOp) (*RepoTreeListResult, error)
}

func RegisterRepoTreeServer(s *grpc.Server, srv RepoTreeServer) {
	s.RegisterService(&_RepoTree_serviceDesc, srv)
}

func _RepoTree_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeSearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoTree_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoTree",
	HandlerType: (*RepoTreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RepoTree_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _RepoTree_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RepoTree_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Search service

type SearchClient interface {
	// SearchTokens searches the index of tokens.
	SearchTokens(ctx context.Context, in *TokenSearchOptions, opts ...grpc.CallOption) (*DefList, error)
	// SearchText searches the content of files in the repo tree.
	SearchText(ctx context.Context, in *TextSearchOptions, opts ...grpc.CallOption) (*VCSSearchResultList, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) SearchTokens(ctx context.Context, in *TokenSearchOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/SearchTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) SearchText(ctx context.Context, in *TextSearchOptions, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/SearchText", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	// SearchTokens searches the index of tokens.
	SearchTokens(context.Context, *TokenSearchOptions) (*DefList, error)
	// SearchText searches the content of files in the repo tree.
	SearchText(context.Context, *TextSearchOptions) (*VCSSearchResultList, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_SearchTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TokenSearchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).SearchTokens(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_SearchText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TextSearchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).SearchText(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchTokens",
			Handler:    _Search_SearchTokens_Handler,
		},
		{
			MethodName: "SearchText",
			Handler:    _Search_SearchText_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Units service

type UnitsClient interface {
	// Get fetches a unit.
	Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error)
	// List units.
	List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error)
}

type unitsClient struct {
	cc *grpc.ClientConn
}

func NewUnitsClient(cc *grpc.ClientConn) UnitsClient {
	return &unitsClient{cc}
}

func (c *unitsClient) Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error) {
	out := new(unit.RepoSourceUnit)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitsClient) List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error) {
	out := new(RepoSourceUnitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Units service

type UnitsServer interface {
	// Get fetches a unit.
	Get(context.Context, *UnitSpec) (*unit.RepoSourceUnit, error)
	// List units.
	List(context.Context, *UnitListOptions) (*RepoSourceUnitList, error)
}

func RegisterUnitsServer(s *grpc.Server, srv UnitsServer) {
	s.RegisterService(&_Units_serviceDesc, srv)
}

func _Units_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Units_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Units_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Units",
	HandlerType: (*UnitsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Units_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Units_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Meta service

type MetaClient interface {
	// Status returns status information from the server's point of
	// view.
	Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error) {
	out := new(ServerStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error) {
	out := new(ServerConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Config", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	// Status returns status information from the server's point of
	// view.
	Status(context.Context, *pbtypes1.Void) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(context.Context, *pbtypes1.Void) (*ServerConfig, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Status(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Config(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Meta_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _Meta_Config_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RegisteredClients service

type RegisteredClientsClient interface {
	// Get retrieves an API client's record given its client ID.
	Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Create registers an API client.
	Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error)
	// Get the permissions of the user on the specified client.
	GetUserPermissions(ctx context.Context, in *UserPermissionsOptions, opts ...grpc.CallOption) (*UserPermissions, error)
	// Set the permissions of the user on the specified client.
	SetUserPermissions(ctx context.Context, in *UserPermissions, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// List the permissions of all users that are registered on this client.
	ListUserPermissions(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*UserPermissionsList, error)
}

type registeredClientsClient struct {
	cc *grpc.ClientConn
}

func NewRegisteredClientsClient(cc *grpc.ClientConn) RegisteredClientsClient {
	return &registeredClientsClient{cc}
}

func (c *registeredClientsClient) Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/GetCurrent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error) {
	out := new(RegisteredClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) GetUserPermissions(ctx context.Context, in *UserPermissionsOptions, opts ...grpc.CallOption) (*UserPermissions, error) {
	out := new(UserPermissions)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/GetUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) SetUserPermissions(ctx context.Context, in *UserPermissions, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/SetUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) ListUserPermissions(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*UserPermissionsList, error) {
	out := new(UserPermissionsList)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/ListUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RegisteredClients service

type RegisteredClientsServer interface {
	// Get retrieves an API client's record given its client ID.
	Get(context.Context, *RegisteredClientSpec) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(context.Context, *pbtypes1.Void) (*RegisteredClient, error)
	// Create registers an API client.
	Create(context.Context, *RegisteredClient) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(context.Context, *RegisteredClient) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(context.Context, *RegisteredClientSpec) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(context.Context, *RegisteredClientListOptions) (*RegisteredClientList, error)
	// Get the permissions of the user on the specified client.
	GetUserPermissions(context.Context, *UserPermissionsOptions) (*UserPermissions, error)
	// Set the permissions of the user on the specified client.
	SetUserPermissions(context.Context, *UserPermissions) (*pbtypes1.Void, error)
	// List the permissions of all users that are registered on this client.
	ListUserPermissions(context.Context, *RegisteredClientSpec) (*UserPermissionsList, error)
}

func RegisterRegisteredClientsServer(s *grpc.Server, srv RegisteredClientsServer) {
	s.RegisterService(&_RegisteredClients_serviceDesc, srv)
}

func _RegisteredClients_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_GetCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).GetCurrent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_GetUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserPermissionsOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).GetUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_SetUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).SetUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_ListUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).ListUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RegisteredClients_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RegisteredClients",
	HandlerType: (*RegisteredClientsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RegisteredClients_Get_Handler,
		},
		{
			MethodName: "GetCurrent",
			Handler:    _RegisteredClients_GetCurrent_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RegisteredClients_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegisteredClients_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegisteredClients_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegisteredClients_List_Handler,
		},
		{
			MethodName: "GetUserPermissions",
			Handler:    _RegisteredClients_GetUserPermissions_Handler,
		},
		{
			MethodName: "SetUserPermissions",
			Handler:    _RegisteredClients_SetUserPermissions_Handler,
		},
		{
			MethodName: "ListUserPermissions",
			Handler:    _RegisteredClients_ListUserPermissions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for GraphUplink service

type GraphUplinkClient interface {
	// Push sends the latest metrics to the upstream instance
	Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// PushEvents flushes the local event logs to the upstream
	// instance
	PushEvents(ctx context.Context, in *UserEventList, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type graphUplinkClient struct {
	cc *grpc.ClientConn
}

func NewGraphUplinkClient(cc *grpc.ClientConn) GraphUplinkClient {
	return &graphUplinkClient{cc}
}

func (c *graphUplinkClient) Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.GraphUplink/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graphUplinkClient) PushEvents(ctx context.Context, in *UserEventList, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.GraphUplink/PushEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GraphUplink service

type GraphUplinkServer interface {
	// Push sends the latest metrics to the upstream instance
	Push(context.Context, *MetricsSnapshot) (*pbtypes1.Void, error)
	// PushEvents flushes the local event logs to the upstream
	// instance
	PushEvents(context.Context, *UserEventList) (*pbtypes1.Void, error)
}

func RegisterGraphUplinkServer(s *grpc.Server, srv GraphUplinkServer) {
	s.RegisterService(&_GraphUplink_serviceDesc, srv)
}

func _GraphUplink_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MetricsSnapshot)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GraphUplinkServer).Push(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GraphUplink_PushEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserEventList)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GraphUplinkServer).PushEvents(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _GraphUplink_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.GraphUplink",
	HandlerType: (*GraphUplinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _GraphUplink_Push_Handler,
		},
		{
			MethodName: "PushEvents",
			Handler:    _GraphUplink_PushEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Notify service

type NotifyClient interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type notifyClient struct {
	cc *grpc.ClientConn
}

func NewNotifyClient(cc *grpc.ClientConn) NotifyClient {
	return &notifyClient{cc}
}

func (c *notifyClient) GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Notify/GenericEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Notify service

type NotifyServer interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(context.Context, *NotifyGenericEvent) (*pbtypes1.Void, error)
}

func RegisterNotifyServer(s *grpc.Server, srv NotifyServer) {
	s.RegisterService(&_Notify_serviceDesc, srv)
}

func _Notify_GenericEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NotifyGenericEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotifyServer).GenericEvent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Notify_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Notify",
	HandlerType: (*NotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenericEvent",
			Handler:    _Notify_GenericEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
