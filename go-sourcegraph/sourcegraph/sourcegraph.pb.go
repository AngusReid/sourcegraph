// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
	Package sourcegraph is a generated protocol buffer package.

	It is generated from these files:
		sourcegraph.proto

	It has these top-level messages:
		Badge
		CombinedStatus
		Counter
		ListOptions
		ListResponse
		StreamResponse
		Changeset
		ChangesetReview
		ChangesetEvent
		InlineComment
		Readme
		GitHubRepo
		RepoConfig
		Repo
		BadgeList
		CounterList
		RepoBadgesCountHitsOp
		RepoBadgesCountHitsResult
		RepoListOptions
		RepoPermissions
		RepoRevSpec
		RepoSpec
		RepoStatus
		RepoStatusesCreateOp
		RepoList
		SrclibDataVersion
		RepoConfigureAppOp
		StorageBucket
		StorageKey
		StorageValue
		StoragePutOp
		StorageExists
		StorageList
		ReposCreateOp
		ReposUpdateOp
		ReposListCommitsOp
		RepoListCommitsOptions
		CommitList
		ReposListBranchesOp
		RepoListBranchesOptions
		BranchList
		ReposListTagsOp
		ReposListCommittersOp
		RepoListCommittersOptions
		CommitterList
		ChangesetCreateOp
		ChangesetCreateReviewOp
		ChangesetListReviewsOp
		ChangesetSpec
		ChangesetUpdateOp
		ChangesetMergeOp
		ChangesetUpdateAffectedOp
		RepoListTagsOptions
		TagList
		MirrorReposRefreshVCSOp
		VCSCredentials
		MirroredRepoSSHKeysCreateOp
		SSHPrivateKey
		Build
		BuildConfig
		BuildGetLogOptions
		BuildListOptions
		ChangesetListOp
		BuildSpec
		BuildTask
		BuildTaskListOptions
		BuildUpdate
		BuildList
		BuildsCreateOp
		BuildsUpdateOp
		BuildsListBuildTasksOp
		BuildTaskList
		ChangesetReviewList
		ChangesetList
		ChangesetEventList
		BuildsCreateTasksOp
		BuildsUpdateTaskOp
		BuildsGetTaskLogOp
		BuildsDequeueNextOp
		EmailAddr
		LogEntries
		Org
		OrgListMembersOptions
		OrgSpec
		OrgsListMembersOp
		UserList
		UserCount
		Person
		PersonSpec
		TaskSpec
		TaskUpdate
		User
		UserSpec
		UsersListOptions
		OrgsListOp
		EmailAddrList
		OrgList
		PasswordResetToken
		PendingPasswordReset
		NewPassword
		NewAccount
		AccountInvite
		InviteSpec
		PendingInvite
		AccountInviteList
		AcceptedInvite
		SSHKeyList
		SSHPublicKey
		AuthorizationCodeRequest
		AuthorizationCode
		LoginCredentials
		BearerJWT
		AccessTokenRequest
		AccessTokenResponse
		AuthInfo
		AuthorshipInfo
		Def
		DefAuthor
		DefAuthorship
		DefClient
		DefDelta
		DefGetOptions
		DefListAuthorsOptions
		DefListClientsOptions
		DefListExamplesOptions
		DefListOptions
		DefListRefsOptions
		DefSpec
		DefsGetOp
		DefList
		DefsListRefsOp
		RefList
		DefsListExamplesOp
		ExampleList
		DefsListAuthorsOp
		DefsListClientsOp
		Delta
		DeltaAffectedPerson
		DeltaDefs
		FileDiff
		Hunk
		DeltaFiles
		DeltaFilter
		DeltaListAffectedAuthorsOptions
		DeltaListAffectedClientsOptions
		DeltaListDefsOptions
		DeltaListFilesOptions
		DeltaListUnitsOptions
		DeltaSpec
		DeltasListUnitsOp
		UnitDeltaList
		DeltasListDefsOp
		DeltasListFilesOp
		DeltasListAffectedAuthorsOp
		DeltaAffectedPersonList
		DeltasListAffectedClientsOp
		Example
		FormatResult
		MarkdownData
		MarkdownOpt
		MarkdownRequestBody
		MarkdownRenderOp
		Ref
		RepoTreeGetOptions
		RepoTreeSearchOptions
		RepoTreeSearchResult
		RepoTreeGetOp
		RepoTreeSearchOp
		RepoTreeListOp
		RepoTreeListResult
		VCSSearchResultList
		TokenSearchOptions
		TextSearchOptions
		SourceCode
		SourceCodeLine
		SourceCodeToken
		TreeEntry
		TreeEntrySpec
		UnitDelta
		UnitListOptions
		UnitSpec
		RepoSourceUnitList
		DefAuthorList
		DefClientList
		Checklist
		FileToken
		ServerStatus
		ServerConfig
		RegisteredClient
		RegisteredClientSpec
		RegisteredClientCredentials
		RegisteredClientListOptions
		RegisteredClientList
		UserPermissions
		UserPermissionsList
		UserPermissionsOptions
		MetricsSnapshot
		UserEvent
		UserEventList
		Event
		EventList
		NotifyGenericEvent
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto"
import diff "sourcegraph.com/sourcegraph/go-diff/diff"
import vcs "sourcegraph.com/sourcegraph/go-vcs/vcs"
import graph "sourcegraph.com/sourcegraph/srclib/graph"
import graph1 "sourcegraph.com/sourcegraph/srclib/graph"
import unit "sourcegraph.com/sourcegraph/srclib/unit"
import vcsclient "sourcegraph.com/sourcegraph/vcsstore/vcsclient"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import pbtypes2 "sourcegraph.com/sqs/pbtypes"
import inventory "src.sourcegraph.com/sourcegraph/pkg/inventory"

// discarding unused import google_api1 "github.com/gengo/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// RegisteredClientType is the set of kinds of clients.
type RegisteredClientType int32

const (
	// Any is any type of API client. It should only be used when
	// listing and not actually set on a RegisteredClient object.
	RegisteredClientType_Any RegisteredClientType = 0
	// Other is all other kinds of clients that are not
	// SourcegraphServers.
	RegisteredClientType_Other RegisteredClientType = 1
	// SourcegraphServer indicates this client is a Sourcegraph server
	// instance.
	RegisteredClientType_SourcegraphServer RegisteredClientType = 2
)

var RegisteredClientType_name = map[int32]string{
	0: "Any",
	1: "Other",
	2: "SourcegraphServer",
}
var RegisteredClientType_value = map[string]int32{
	"Any":               0,
	"Other":             1,
	"SourcegraphServer": 2,
}

func (x RegisteredClientType) String() string {
	return proto.EnumName(RegisteredClientType_name, int32(x))
}

// TelemetryType is the format MetricsSnapshot.TelemetryData is encoded in
type TelemetryType int32

const (
	// PrometheusDelimited0dot0dot4 indicates the metrics can be decoded using
	// Prometheus 0.0.4 delimited protobuf format
	TelemetryType_PrometheusDelimited0dot0dot4 TelemetryType = 0
)

var TelemetryType_name = map[int32]string{
	0: "PrometheusDelimited0dot0dot4",
}
var TelemetryType_value = map[string]int32{
	"PrometheusDelimited0dot0dot4": 0,
}

func (x TelemetryType) String() string {
	return proto.EnumName(TelemetryType_name, int32(x))
}

type Badge struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:",omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:",omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:",omitempty"`
}

func (m *Badge) Reset()         { *m = Badge{} }
func (m *Badge) String() string { return proto.CompactTextString(m) }
func (*Badge) ProtoMessage()    {}

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	Rev string `protobuf:"bytes,4,opt,name=rev,proto3" json:",omitempty"`
	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	CommitID string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:",omitempty"`
	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:",omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=statuses" json:",omitempty"`
}

func (m *CombinedStatus) Reset()         { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()    {}

type Counter struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:",omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:",omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:",omitempty"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=per_page,proto3" json:",omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=page,proto3" json:",omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()         { *m = ListOptions{} }
func (m *ListOptions) String() string { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()    {}

// ListResponse specifies a general paginated response when fetching a list of results.
type ListResponse struct {
	// Total is the total number of results in the list.
	Total int32 `protobuf:"varint,1,opt,name=total,proto3" json:",omitempty" url:",omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}

// StreamResponse specifies a paginated response where the total number of results
// that can be returned is too expensive to compute, unbounded, or unknown.
type StreamResponse struct {
	// HasMore is true if there are more results available after the returned page.
	HasMore bool `protobuf:"varint,1,opt,name=has_more,proto3" json:",omitempty" url:",omitempty"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}

// Changeset stores information about a changeset.
type Changeset struct {
	// ID is the unique identifier for this changeset, relative to the repository
	// that contains it.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:",omitempty"`
	// Title holds a summary about this changeset.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:",omitempty"`
	// Description holds the description for this changeset.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:",omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" `
	// DeltaSpec contains information about the base and head spec for this
	// changeset.
	DeltaSpec *DeltaSpec `protobuf:"bytes,5,opt,name=delta_spec" json:",omitempty"`
	// Merged specifies whether this changeset was merged.
	Merged bool `protobuf:"varint,6,opt,name=merged,proto3" json:",omitempty"`
	// CreatedAt holds the creation time of this changeset.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=created_at" json:",omitempty"`
	// ClosedAt holds the time when this changeset was closed or merged.
	ClosedAt *pbtypes.Timestamp `protobuf:"bytes,8,opt,name=closed_at" json:",omitempty"`
}

func (m *Changeset) Reset()         { *m = Changeset{} }
func (m *Changeset) String() string { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()    {}

// ChangesetReview contains information about a review submitted on a changeset.
type ChangesetReview struct {
	// ID holds the unique identifier (with reference to the changeset) of the
	// review.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:",omitempty"`
	// Body holds the text description of the review.
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:",omitempty"`
	// Author is the spec of the user that submitted this review.
	Author UserSpec `protobuf:"bytes,3,opt,name=author" `
	// CreatedAt is the date at which this review was submitted.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,4,opt,name=created_at" json:",omitempty"`
	// EditedAt is the last time at which this review was edited. If the review
	// has never been edited, this value will be nil.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=edited_at" json:",omitempty"`
	// Comments holds any inline comments that were submitted along with this
	// review.
	Comments []*InlineComment `protobuf:"bytes,6,rep,name=comments" json:",omitempty"`
	// Deleted specifies whether this review has been removed.
	Deleted bool `protobuf:"varint,7,opt,name=deleted,proto3" json:",omitempty"`
}

func (m *ChangesetReview) Reset()         { *m = ChangesetReview{} }
func (m *ChangesetReview) String() string { return proto.CompactTextString(m) }
func (*ChangesetReview) ProtoMessage()    {}

// ChangesetEvent holds information about an update that occurred on the
// properties of a Changeset.
type ChangesetEvent struct {
	// Before holds the changeset as it was before the event.
	Before *Changeset `protobuf:"bytes,2,opt,name=before" json:",omitempty"`
	// After holds the changeset as it became after the event.
	After *Changeset `protobuf:"bytes,3,opt,name=after" json:",omitempty"`
	// Op holds the update operation that changed the state.
	Op *ChangesetUpdateOp `protobuf:"bytes,4,opt,name=op" json:",omitempty"`
	// CreatedAt is the date at which the event was created.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=created_at" json:",omitempty"`
}

func (m *ChangesetEvent) Reset()         { *m = ChangesetEvent{} }
func (m *ChangesetEvent) String() string { return proto.CompactTextString(m) }
func (*ChangesetEvent) ProtoMessage()    {}

// InlineComment represents a comment made on a line of code. It is uniquely identified
// via Filename + LineNumber + CommitID. In a Changeset, the CommitID might vary
// within the same file based on whether the comment was made on the lines that
// match the pre-index SHA-1 or the lines that match the post-index SHA-1. Pre
// and post index values may differ from Base and Head of the diff.
// For more information on indexes see http://git-scm.com/docs/git-diff-index
type InlineComment struct {
	// Filename is the name of the file where this comment was made.
	Filename string `protobuf:"bytes,1,opt,name=filename,proto3" json:",omitempty"`
	// LineNumber is the line number relative to the beginning of the file in
	// the specified commit.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,proto3" json:",omitempty"`
	// CommitID is the SHA-1 for the post-image of this file, where the comment
	// was placed. The post-image can be deduced from the file entry in the diff
	// that it belong by extracting it's extended header's index entry.
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" `
	// Body holds the body of this comment.
	Body string `protobuf:"bytes,5,opt,name=body,proto3" json:",omitempty"`
	// CreatedAt holds the creation date of this comment.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:",omitempty"`
	// EditedAt holds the time when this comment was last edited. If no edits occurred,
	// it will be null.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=edited_at" json:",omitempty"`
	// Deleted indicates whether the comment has been deleted.
	Deleted bool `protobuf:"varint,8,opt,name=deleted,proto3" json:",omitempty"`
}

func (m *InlineComment) Reset()         { *m = InlineComment{} }
func (m *InlineComment) String() string { return proto.CompactTextString(m) }
func (*InlineComment) ProtoMessage()    {}

// A Readme represents a formatted "README"-type file in a repository.
type Readme struct {
	// Path is the relative path of this readme file from the repository root.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:",omitempty"`
	// HTML is the formatted HTML of this readme.
	HTML string `protobuf:"bytes,2,opt,name=html,proto3" json:",omitempty"`
}

func (m *Readme) Reset()         { *m = Readme{} }
func (m *Readme) String() string { return proto.CompactTextString(m) }
func (*Readme) ProtoMessage()    {}

// GitHubRepo holds additional metadata about GitHub repos.
type GitHubRepo struct {
	Stars int32 `protobuf:"varint,1,opt,name=stars,proto3" json:",omitempty"`
}

func (m *GitHubRepo) Reset()         { *m = GitHubRepo{} }
func (m *GitHubRepo) String() string { return proto.CompactTextString(m) }
func (*GitHubRepo) ProtoMessage()    {}

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
type RepoConfig struct {
	// Apps is a list of app IDs denoting the applications that are
	// enabled for this repository.
	Apps []string `protobuf:"bytes,1,rep,name=apps" json:",omitempty"`
}

func (m *RepoConfig) Reset()         { *m = RepoConfig{} }
func (m *RepoConfig) String() string { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()    {}

// Repo represents a source code repository.
type Repo struct {
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
	// Origin is populated for repos fetched via federation or
	// discovery. It is the hostname of the host that owns the repo.
	Origin string `protobuf:"bytes,21,opt,name=origin,proto3" json:",omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:",omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:",omitempty"`
	// VCS is the short name of the VCS system that this repository uses: "git" or
	// "hg".
	VCS string `protobuf:"bytes,4,opt,name=vcs,proto3" json:",omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=http_clone_url,proto3" json:",omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=ssh_clone_url,proto3" json:",omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=homepage_url,proto3" json:",omitempty"`
	// HTMLURL is the URL to the repository's main page on the
	// Sourcegraph server.
	HTMLURL string `protobuf:"bytes,22,opt,name=html_url,proto3" json:",omitempty"`
	// DefaultBranch is the default VCS branch used (typically "master" for git
	// repositories and "default" for hg repositories).
	DefaultBranch string `protobuf:"bytes,8,opt,name=default_branch,proto3" json:",omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=language,proto3" json:",omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=blocked,proto3" json:",omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:",omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=fork,proto3" json:",omitempty"`
	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream.
	Mirror bool `protobuf:"varint,13,opt,name=mirror,proto3" json:",omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,14,opt,name=private,proto3" json:",omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,15,opt,name=created_at" json:",omitempty"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,16,opt,name=updated_at" json:",omitempty"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,17,opt,name=pushed_at" json:",omitempty"`
	// Permissions describes the permissions that the current user (or anonymous users,
	// if there is no current user) is granted to this repository.
	Permissions *RepoPermissions `protobuf:"bytes,18,opt,name=permissions" json:",omitempty"`
	GitHub      *GitHubRepo      `protobuf:"bytes,19,opt,name=github" json:",omitempty"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}

type BadgeList struct {
	Badges []*Badge `protobuf:"bytes,1,rep,name=badges" json:",omitempty"`
}

func (m *BadgeList) Reset()         { *m = BadgeList{} }
func (m *BadgeList) String() string { return proto.CompactTextString(m) }
func (*BadgeList) ProtoMessage()    {}

type CounterList struct {
	Counters []*Counter `protobuf:"bytes,1,rep,name=counters" json:",omitempty"`
}

func (m *CounterList) Reset()         { *m = CounterList{} }
func (m *CounterList) String() string { return proto.CompactTextString(m) }
func (*CounterList) ProtoMessage()    {}

type RepoBadgesCountHitsOp struct {
	Repo  RepoSpec           `protobuf:"bytes,1,opt,name=repo" `
	Since *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=since" json:",omitempty"`
}

func (m *RepoBadgesCountHitsOp) Reset()         { *m = RepoBadgesCountHitsOp{} }
func (m *RepoBadgesCountHitsOp) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsOp) ProtoMessage()    {}

type RepoBadgesCountHitsResult struct {
	Hits int32 `protobuf:"varint,1,opt,name=hits,proto3" json:",omitempty"`
}

func (m *RepoBadgesCountHitsResult) Reset()         { *m = RepoBadgesCountHitsResult{} }
func (m *RepoBadgesCountHitsResult) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsResult) ProtoMessage()    {}

type RepoListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty" url:",omitempty"`
	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query       string   `protobuf:"bytes,2,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	URIs        []string `protobuf:"bytes,3,rep,name=uri_s" json:",omitempty" url:",comma,omitempty"`
	Sort        string   `protobuf:"bytes,5,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string   `protobuf:"bytes,6,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	NoFork      bool     `protobuf:"varint,7,opt,name=no_fork,proto3" json:",omitempty" url:",omitempty"`
	Type        string   `protobuf:"bytes,8,opt,name=type,proto3" json:",omitempty" url:",omitempty"`
	Owner       string   `protobuf:"bytes,10,opt,name=owner,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListOptions) Reset()         { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()    {}

// RepoPermissions describes the possible permissions that a user (or an anonymous
// user) can be granted to a repository.
type RepoPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read,proto3" json:",omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:",omitempty"`
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:",omitempty"`
}

func (m *RepoPermissions) Reset()         { *m = RepoPermissions{} }
func (m *RepoPermissions) String() string { return proto.CompactTextString(m) }
func (*RepoPermissions) ProtoMessage()    {}

// RepoRevSpec specifies a repository at a specific commit (or revision specifier,
// such as a branch, which is resolved on the server side to a specific commit).
//
// Filling in CommitID is an optional optimization. It avoids the need for another
// resolution of Rev. If CommitID is filled in, the "Rev" route variable becomes
// "Rev===CommitID" (e.g., "master===af4cd6"). Handlers can parse this string to
// retrieve the pre-resolved commit ID (e.g., "af4cd6") and still return data that
// constructs URLs using the unresolved revspec (e.g., "master").
//
// Why is it important/useful to pass the resolved commit ID instead of just using
// a revspec everywhere? Consider this case. Your application wants to make a bunch
// of requests for resources relating to "master"; for example, it wants to
// retrieve a source file foo.go at master and all of the definitions and
// references contained in the file. This may consist of dozens of API calls. If
// each API call specified just "master", there would be 2 problems: (1) each API
// call would have to re-resolve "master" to its actual commit ID, which takes a
// lot of extra work; and (2) if the "master" ref changed during the API calls (if
// someone pushed in the middle of the API call, for example), then your
// application would receive data from 2 different commits. The solution is for
// your application to resolve the revspec once and pass both the original revspec
// and the resolved commit ID in all API calls it makes.
//
// And why do we want to preserve the unresolved revspec? In this case, your app
// wants to let the user continue browsing "master". If the API data all referred
// to a specific commit ID, then the user would cease browsing master the next time
// she clicked a link on your app. Preserving the revspec gives the user a choice
// whether to use the absolute commit ID or the revspec (similar to how GitHub lets
// you canonicalize a URL with 'y' but does not default to using the canonical
// URL).
type RepoRevSpec struct {
	RepoSpec `protobuf:"bytes,1,opt,name=repo_spec,embedded=repo_spec" `
	Rev      string `protobuf:"bytes,2,opt,name=rev,proto3" json:",omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
}

func (m *RepoRevSpec) Reset()         { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()    {}

// RepoSpec specifies a repository.
type RepoSpec struct {
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
}

func (m *RepoSpec) Reset()         { *m = RepoSpec{} }
func (m *RepoSpec) String() string { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()    {}

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:",omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=target_url,proto3" json:",omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:",omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=context,proto3" json:",omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" `
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=updated_at" `
}

func (m *RepoStatus) Reset()         { *m = RepoStatus{} }
func (m *RepoStatus) String() string { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()    {}

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=repo" `
	Status RepoStatus  `protobuf:"bytes,2,opt,name=status" `
}

func (m *RepoStatusesCreateOp) Reset()         { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()    {}

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=repos" json:",omitempty"`
}

func (m *RepoList) Reset()         { *m = RepoList{} }
func (m *RepoList) String() string { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()    {}

// SrclibDataVersion specifies a srclib store version.
type SrclibDataVersion struct {
	CommitID      string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:",omitempty"`
	CommitsBehind int32  `protobuf:"varint,2,opt,name=commits_behind,proto3" json:",omitempty"`
}

func (m *SrclibDataVersion) Reset()         { *m = SrclibDataVersion{} }
func (m *SrclibDataVersion) String() string { return proto.CompactTextString(m) }
func (*SrclibDataVersion) ProtoMessage()    {}

type RepoConfigureAppOp struct {
	// Repo is the repository whose applications are being configured.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// App is the app ID to enable or disable.
	App string `protobuf:"bytes,2,opt,name=app,proto3" json:",omitempty"`
	// Enable is true if the app should be enabled and false if it
	// should be disabled.
	Enable bool `protobuf:"varint,3,opt,name=enable,proto3" json:",omitempty"`
}

func (m *RepoConfigureAppOp) Reset()         { *m = RepoConfigureAppOp{} }
func (m *RepoConfigureAppOp) String() string { return proto.CompactTextString(m) }
func (*RepoConfigureAppOp) ProtoMessage()    {}

// StorageBucket represents the location where keys are stored.
//
// Understanding the name-spacing of storage objects is often helped by
// visualizing the filesystem-backed implementation, which looks like:
//
//  /repo/<Repo>/<AppName>/<Bucket>/<Key>
//  /global/<AppName>/<Bucket>/<Key>
//
type StorageBucket struct {
	// AppName is the name of the application whose data you are trying to
	// read/write, applications may read and write to each other's data assuming
	// the admin has not restricted such access.
	AppName string `protobuf:"bytes,1,opt,name=app_name,proto3" json:",omitempty"`
	// Repo is the repository URI. If specified storage is considered local to the
	// repository. Otherwise it is considered "global" (i.e. shared across all
	// repositories).
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty"`
	// Name is the bucket name. In filesystem terminology, a bucket is a 'folder'
	// and an object is a 'file'.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:",omitempty"`
}

func (m *StorageBucket) Reset()         { *m = StorageBucket{} }
func (m *StorageBucket) String() string { return proto.CompactTextString(m) }
func (*StorageBucket) ProtoMessage()    {}

// StorageKey is a storage object's key.
type StorageKey struct {
	// Bucket is the bucket name.
	Bucket *StorageBucket `protobuf:"bytes,3,opt,name=bucket" json:",omitempty"`
	// Key is the name of the storage object. In filesystem terminology, this is
	// the 'filename' and thus must be unique against all other key names in the
	// bucket.
	Key string `protobuf:"bytes,4,opt,name=key,proto3" json:",omitempty"`
}

func (m *StorageKey) Reset()         { *m = StorageKey{} }
func (m *StorageKey) String() string { return proto.CompactTextString(m) }
func (*StorageKey) ProtoMessage()    {}

// StorageValue is the value of a storage object.
type StorageValue struct {
	// Value is the value of the object.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:",omitempty"`
}

func (m *StorageValue) Reset()         { *m = StorageValue{} }
func (m *StorageValue) String() string { return proto.CompactTextString(m) }
func (*StorageValue) ProtoMessage()    {}

// StoragePutOp is the parameters for putting an object into storage.
type StoragePutOp struct {
	// Key is the key of the object to put into storage.
	Key StorageKey `protobuf:"bytes,1,opt,name=key" `
	// Value is the value of the object.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:",omitempty"`
}

func (m *StoragePutOp) Reset()         { *m = StoragePutOp{} }
func (m *StoragePutOp) String() string { return proto.CompactTextString(m) }
func (*StoragePutOp) ProtoMessage()    {}

// StorageExists is the result from checking if a storage object exists within
// a bucket.
type StorageExists struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,proto3" json:",omitempty"`
}

func (m *StorageExists) Reset()         { *m = StorageExists{} }
func (m *StorageExists) String() string { return proto.CompactTextString(m) }
func (*StorageExists) ProtoMessage()    {}

// StorageList is the result from listing all the keys in a storage bucket.
type StorageList struct {
	Keys []string `protobuf:"bytes,1,rep,name=keys" json:",omitempty"`
}

func (m *StorageList) Reset()         { *m = StorageList{} }
func (m *StorageList) String() string { return proto.CompactTextString(m) }
func (*StorageList) ProtoMessage()    {}

type ReposCreateOp struct {
	// URI is the desired URI of the new repository.
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:",omitempty"`
	// VCS is the desired VCS type of the new repository (only "git"
	// is currently supported).
	VCS string `protobuf:"bytes,2,opt,name=vcs,proto3" json:",omitempty"`
	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	CloneURL string `protobuf:"bytes,3,opt,name=clone_url,proto3" json:",omitempty"`
	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	Mirror bool `protobuf:"varint,4,opt,name=mirror,proto3" json:",omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,5,opt,name=private,proto3" json:",omitempty"`
	// Description is the description of the repository.
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:",omitempty"`
	// Language is the primary programming language of the repository.
	Language string `protobuf:"bytes,7,opt,name=language,proto3" json:",omitempty"`
}

func (m *ReposCreateOp) Reset()         { *m = ReposCreateOp{} }
func (m *ReposCreateOp) String() string { return proto.CompactTextString(m) }
func (*ReposCreateOp) ProtoMessage()    {}

// ReposUpdateOp is an operation to update a repository's metadata.
type ReposUpdateOp struct {
	// Repo is the repository to update.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// Description is the new description of the repository. If empty,
	// the description is not changed.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:",omitempty"`
	// Language is the new primary programming language of the
	// repository. If empty, the language is not changed.
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:",omitempty"`
}

func (m *ReposUpdateOp) Reset()         { *m = ReposUpdateOp{} }
func (m *ReposUpdateOp) String() string { return proto.CompactTextString(m) }
func (*ReposUpdateOp) ProtoMessage()    {}

type ReposListCommitsOp struct {
	Repo RepoSpec                `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListCommitsOp) Reset()         { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()    {}

type RepoListCommitsOptions struct {
	Head         string `protobuf:"bytes,1,opt,name=head,proto3" json:",omitempty" url:",omitempty"`
	Base         string `protobuf:"bytes,2,opt,name=base,proto3" json:",omitempty" url:",omitempty"`
	ListOptions  `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
	Path         string `protobuf:"bytes,4,opt,name=path,proto3" json:",omitempty" url:",omitempty"`
	RefreshCache bool   `protobuf:"varint,5,opt,name=refresh_cache,proto3" json:",omitempty" url:",omitempty"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}

type CommitList struct {
	Commits        []*vcs.Commit `protobuf:"bytes,1,rep,name=commits" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *CommitList) Reset()         { *m = CommitList{} }
func (m *CommitList) String() string { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()    {}

type ReposListBranchesOp struct {
	Repo RepoSpec                 `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListBranchesOp) Reset()         { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()    {}

type RepoListBranchesOptions struct {
	IncludeCommit     bool   `protobuf:"varint,4,opt,name=include_commit,proto3" json:",omitempty"`
	BehindAheadBranch string `protobuf:"bytes,5,opt,name=behind_ahead_branch,proto3" json:",omitempty"`
	ContainsCommit    string `protobuf:"bytes,6,opt,name=contains_commit,proto3" json:",omitempty"`
	ListOptions       `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}

type BranchList struct {
	Branches       []*vcs.Branch `protobuf:"bytes,1,rep,name=branches" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *BranchList) Reset()         { *m = BranchList{} }
func (m *BranchList) String() string { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()    {}

type ReposListTagsOp struct {
	Repo RepoSpec             `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListTagsOp) Reset()         { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()    {}

type ReposListCommittersOp struct {
	Repo RepoSpec                   `protobuf:"bytes,1,opt,name=repo" `
	Opt  *RepoListCommittersOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *ReposListCommittersOp) Reset()         { *m = ReposListCommittersOp{} }
func (m *ReposListCommittersOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommittersOp) ProtoMessage()    {}

type RepoListCommittersOptions struct {
	Rev         string `protobuf:"bytes,1,opt,name=rev,proto3" json:",omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListCommittersOptions) Reset()         { *m = RepoListCommittersOptions{} }
func (m *RepoListCommittersOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommittersOptions) ProtoMessage()    {}

type CommitterList struct {
	Committers     []*vcs.Committer `protobuf:"bytes,1,rep,name=committers" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *CommitterList) Reset()         { *m = CommitterList{} }
func (m *CommitterList) String() string { return proto.CompactTextString(m) }
func (*CommitterList) ProtoMessage()    {}

type ChangesetCreateOp struct {
	Repo      RepoSpec   `protobuf:"bytes,1,opt,name=repo" `
	Changeset *Changeset `protobuf:"bytes,2,opt,name=changeset" json:",omitempty"`
}

func (m *ChangesetCreateOp) Reset()         { *m = ChangesetCreateOp{} }
func (m *ChangesetCreateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateOp) ProtoMessage()    {}

type ChangesetCreateReviewOp struct {
	Repo        RepoSpec         `protobuf:"bytes,1,opt,name=repo" `
	ChangesetID int64            `protobuf:"varint,2,opt,name=changeset_id,proto3" json:",omitempty"`
	Review      *ChangesetReview `protobuf:"bytes,3,opt,name=review" json:",omitempty"`
}

func (m *ChangesetCreateReviewOp) Reset()         { *m = ChangesetCreateReviewOp{} }
func (m *ChangesetCreateReviewOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateReviewOp) ProtoMessage()    {}

type ChangesetListReviewsOp struct {
	Repo        RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	ChangesetID int64    `protobuf:"varint,2,opt,name=changeset_id,proto3" json:",omitempty"`
}

func (m *ChangesetListReviewsOp) Reset()         { *m = ChangesetListReviewsOp{} }
func (m *ChangesetListReviewsOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListReviewsOp) ProtoMessage()    {}

type ChangesetSpec struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	ID   int64    `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
}

func (m *ChangesetSpec) Reset()         { *m = ChangesetSpec{} }
func (m *ChangesetSpec) String() string { return proto.CompactTextString(m) }
func (*ChangesetSpec) ProtoMessage()    {}

type ChangesetUpdateOp struct {
	// Repo holds the RepoSpec where the Changeset to be updated is located.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// ID holds the ID of the changeset that is to be updated.
	ID int64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
	// Title, if non-empty, will be set as the new title of the changeset.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:",omitempty"`
	// Description, if specified, will become the new description of the changeset.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:",omitempty"`
	// Open, if true, will set the changeset's ClosedAt value to nil.
	Open bool `protobuf:"varint,5,opt,name=open,proto3" json:",omitempty"`
	// Close, if true, will set the ClosedAt date.
	Close bool `protobuf:"varint,6,opt,name=close,proto3" json:",omitempty"`
	// Merged, if true, will update the changeset to indicate that it was priorly
	// merged.
	Merged bool `protobuf:"varint,7,opt,name=merged,proto3" json:",omitempty"`
	// Author is the user that initiated this event.
	Author UserSpec `protobuf:"bytes,8,opt,name=Author" `
}

func (m *ChangesetUpdateOp) Reset()         { *m = ChangesetUpdateOp{} }
func (m *ChangesetUpdateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetUpdateOp) ProtoMessage()    {}

type ChangesetMergeOp struct {
	// Repo holds the RepoSpec where the Changeset to be merged is located.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// ID holds the ID of the changeset that is to be merged.
	ID int64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
	// Message is a text template used to generate a message for the commit of
	// the resulting merge operation. Any of the fields from the changeset are
	// available to use in the template.
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:",omitempty"`
	// Squash, if true, will squash the commits of the head branch into a
	// single commit prior to merging.
	Squash bool `protobuf:"varint,4,opt,name=squash,proto3" json:",omitempty"`
}

func (m *ChangesetMergeOp) Reset()         { *m = ChangesetMergeOp{} }
func (m *ChangesetMergeOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetMergeOp) ProtoMessage()    {}

type ChangesetUpdateAffectedOp struct {
	// Repo holds the RepoSpec which received a commit.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// Branch is the name of the branch which was pushed to.
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:",omitempty"`
	// Last is the SHA1 of the last commit on the branch.
	Last string `protobuf:"bytes,3,opt,name=last,proto3" json:",omitempty"`
	// Commit is the SHA1 of the tip of the newly pushed commits on the branch.
	Commit string `protobuf:"bytes,4,opt,name=commit,proto3" json:",omitempty"`
	// ForcePush is whether or not the branch was force pushed to.
	ForcePush bool `protobuf:"varint,5,opt,name=force_push,proto3" json:",omitempty"`
}

func (m *ChangesetUpdateAffectedOp) Reset()         { *m = ChangesetUpdateAffectedOp{} }
func (m *ChangesetUpdateAffectedOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetUpdateAffectedOp) ProtoMessage()    {}

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *RepoListTagsOptions) Reset()         { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()    {}

type TagList struct {
	Tags           []*vcs.Tag `protobuf:"bytes,1,rep,name=tags" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *TagList) Reset()         { *m = TagList{} }
func (m *TagList) String() string { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()    {}

type MirrorReposRefreshVCSOp struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
}

func (m *MirrorReposRefreshVCSOp) Reset()         { *m = MirrorReposRefreshVCSOp{} }
func (m *MirrorReposRefreshVCSOp) String() string { return proto.CompactTextString(m) }
func (*MirrorReposRefreshVCSOp) ProtoMessage()    {}

// VCSCredentials for authentication during communication with VCS remotes.
type VCSCredentials struct {
	// Pass is the password provided to the VCS.
	Pass string `protobuf:"bytes,1,opt,name=pass,proto3" json:",omitempty"`
}

func (m *VCSCredentials) Reset()         { *m = VCSCredentials{} }
func (m *VCSCredentials) String() string { return proto.CompactTextString(m) }
func (*VCSCredentials) ProtoMessage()    {}

type MirroredRepoSSHKeysCreateOp struct {
	Repo RepoSpec      `protobuf:"bytes,1,opt,name=repo" `
	Key  SSHPrivateKey `protobuf:"bytes,2,opt,name=key" `
}

func (m *MirroredRepoSSHKeysCreateOp) Reset()         { *m = MirroredRepoSSHKeysCreateOp{} }
func (m *MirroredRepoSSHKeysCreateOp) String() string { return proto.CompactTextString(m) }
func (*MirroredRepoSSHKeysCreateOp) ProtoMessage()    {}

// An SSHPrivateKey is an SSH key used to access a repository.
type SSHPrivateKey struct {
	// PEM is the encoded key.
	PEM []byte `protobuf:"bytes,2,opt,name=pem,proto3" json:",omitempty"`
}

func (m *SSHPrivateKey) Reset()         { *m = SSHPrivateKey{} }
func (m *SSHPrivateKey) String() string { return proto.CompactTextString(m) }
func (*SSHPrivateKey) ProtoMessage()    {}

// A Build represents a scheduled, completed, or failed repository analysis and
// import job.
//
// A build is composed of many tasks. The worker that is responsible for a build or
// task determines whether a task failure causes the whole build to fail. (Keep
// reading to see how we determine who is responsible for a build or task.) There
// is no single kind of worker; currently there are 2 things that could be
// considered workers because they build builds or perform tasks: the builders on
// Sourcegraph.com, and anyone who runs `src push` locally.
//
// Each task has logs associated with it, and each task can be associated with a
// single source unit (or not).
//
// Builds have a Queue bool field. If a process creates a build that
// has Queue=true, that means that it relinquishes responsibility for
// it; some other queue workers (on the server, for example) will
// dequeue and complete it. If Queue=false, then the process that
// created it is responsible for completing it. The only exception to
// this is that after a certain timeout (on the order of 45 minutes),
// started but unfinished builds are marked as failed.
//
// Builds and tasks are simple "build"ing blocks (no pun intended) with simple
// behavior. As we encounter new requirements for the build system, they may
// evolve.
type Build struct {
	// Repo is the URI of the repository this build is for.
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:",omitempty"`
	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos.
	ID uint64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
	// CommitID is the full resolved commit ID to build.
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:",omitempty"`
	// Branch, if set, is the name of the VCS branch on which this
	// commit was built. Commits may be configured to be built in
	// different ways depending on the branch the build was started on
	// (e.g., a release branch may trigger additional deployment
	// actions). A single commit can exist on any number of branches.
	//
	// A build is recommended to be associated with either a branch or
	// a tag because it is not generally possible to fetch a specific
	// commit from a Git repository; you can only fetch a refspec
	// (branch, tag, etc.). During CI we want to avoid needing to
	// clone *all* branches just to find the specific commit we
	// need. If the branch or tag is specified, we can do a fetch of a
	// specific refspec; otherwise we need to fetch all branches,
	// which makes CI much slower. And Git servers do not let you
	// request a single commit (although this is changing; see
	// http://stackoverflow.com/a/30701724, but it is still disabled
	// by default for apparently good reasons).
	Branch string `protobuf:"bytes,14,opt,name=branch,proto3" json:",omitempty"`
	// Tag, if set, is the name of the VCS tag associated with this
	// commit. See Branch for more information. A single commit can
	// have any number of tags.
	Tag         string             `protobuf:"bytes,15,opt,name=tag,proto3" json:",omitempty"`
	CreatedAt   pbtypes.Timestamp  `protobuf:"bytes,4,opt,name=created_at" `
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=started_at" json:",omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=ended_at" json:",omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=heartbeat_at" json:",omitempty"`
	Success     bool               `protobuf:"varint,8,opt,name=success,proto3" json:",omitempty"`
	Failure     bool               `protobuf:"varint,9,opt,name=failure,proto3" json:",omitempty"`
	// Killed is true if this build's worker didn't exit on its own accord. It is
	// generally set when no heartbeat has been received within a certain interval. If
	// Killed is true, then Failure must also always be set to true. Unqueued builds
	// are never killed for lack of a heartbeat.
	Killed bool `protobuf:"varint,10,opt,name=killed,proto3" json:",omitempty"`
	// Host is the hostname of the machine that is working on this build.
	Host        string `protobuf:"bytes,11,opt,name=host,proto3" json:",omitempty"`
	Purged      bool   `protobuf:"varint,12,opt,name=purged,proto3" json:",omitempty"`
	BuildConfig `protobuf:"bytes,13,opt,name=build_config,embedded=build_config" `
}

func (m *Build) Reset()         { *m = Build{} }
func (m *Build) String() string { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()    {}

// BuildConfig configures a repository build.
type BuildConfig struct {
	// Queue is whether this build should be enqueued. If enqueued, any worker may
	// begin running this build. If not enqueued, it is up to the client to run the
	// build and update it accordingly.
	Queue bool `protobuf:"varint,2,opt,name=queue,proto3" json:",omitempty"`
	// Priority of the build in the queue (higher numbers mean the build is dequeued
	// sooner).
	Priority int32 `protobuf:"varint,4,opt,name=priority,proto3" json:",omitempty"`
	// BuilderConfig is the actual .drone.yml config file that was
	// used to run this build in CI. It reflects all automatic
	// additions/changes made by the worker (i.e., it is not
	// necessarily the same .drone.yml config file as the one in the
	// repository).
	BuilderConfig string `protobuf:"bytes,16,opt,name=builder_config,proto3" json:",omitempty"`
}

func (m *BuildConfig) Reset()         { *m = BuildConfig{} }
func (m *BuildConfig) String() string { return proto.CompactTextString(m) }
func (*BuildConfig) ProtoMessage()    {}

// BuildGetLogOptions specifies options for build log API methods.
type BuildGetLogOptions struct {
	// MinID indicates that only log entries whose monotonically increasing ID is
	// greater than MinID should be returned.
	//
	// To "tail -f" or watch a log for updates, set each subsequent request's MinID to
	// the MaxID of the previous request.
	MinID string `protobuf:"bytes,1,opt,name=min_id,proto3" json:",omitempty"`
}

func (m *BuildGetLogOptions) Reset()         { *m = BuildGetLogOptions{} }
func (m *BuildGetLogOptions) String() string { return proto.CompactTextString(m) }
func (*BuildGetLogOptions) ProtoMessage()    {}

type BuildListOptions struct {
	Queued      bool   `protobuf:"varint,1,opt,name=queued,proto3" json:",omitempty" url:",omitempty"`
	Active      bool   `protobuf:"varint,2,opt,name=active,proto3" json:",omitempty" url:",omitempty"`
	Ended       bool   `protobuf:"varint,3,opt,name=ended,proto3" json:",omitempty" url:",omitempty"`
	Succeeded   bool   `protobuf:"varint,4,opt,name=succeeded,proto3" json:",omitempty" url:",omitempty"`
	Failed      bool   `protobuf:"varint,5,opt,name=failed,proto3" json:",omitempty" url:",omitempty"`
	Purged      bool   `protobuf:"varint,6,opt,name=purged,proto3" json:",omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,7,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	CommitID    string `protobuf:"bytes,8,opt,name=commit_id,proto3" json:",omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,9,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,10,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *BuildListOptions) Reset()         { *m = BuildListOptions{} }
func (m *BuildListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildListOptions) ProtoMessage()    {}

type ChangesetListOp struct {
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:",omitempty"`
	// Open, when true, will only return open changesets.
	Open bool `protobuf:"varint,2,opt,name=open,proto3" json:",omitempty"`
	// Closed, when true, will only return closed changeset.
	Closed bool `protobuf:"varint,3,opt,name=closed,proto3" json:",omitempty"`
	// Head, if set, will restrict the returned list to only changesets
	// that have this branch as head.
	Head string `protobuf:"bytes,4,opt,name=head,proto3" json:",omitempty"`
	// Base, when set, will restrict the list to changesets that have this
	// branch as a base.
	Base        string `protobuf:"bytes,5,opt,name=base,proto3" json:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" `
}

func (m *ChangesetListOp) Reset()         { *m = ChangesetListOp{} }
func (m *ChangesetListOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListOp) ProtoMessage()    {}

// A BuildSpec uniquely identifies a build.
type BuildSpec struct {
	// Repo is the repository associated with the build.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos' builds.
	ID uint64 `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
}

func (m *BuildSpec) Reset()         { *m = BuildSpec{} }
func (m *BuildSpec) String() string { return proto.CompactTextString(m) }
func (*BuildSpec) ProtoMessage()    {}

// A BuildTask represents an individual step of a build.
//
// See the documentation for Build for more information about how builds and tasks
// relate to each other.
type BuildTask struct {
	// ID is the numeric ID of the task. It is up to the
	// implementation to decide whether it is sequential within the
	// build or globally unique across all builds.
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:",omitempty"`
	// Build specifies the build associated with this task.
	Build BuildSpec `protobuf:"bytes,2,opt,name=build" `
	// ParentID, if non-zero, indicates that this task's parent is the
	// task (in the same build) with the given ID. A ParentID of zero
	// means that this is a top-level task.
	ParentID uint64 `protobuf:"varint,3,opt,name=parent_id,proto3" json:",omitempty"`
	// Label describes the task (e.g., Code Intelligence).
	Label string `protobuf:"bytes,4,opt,name=label,proto3" json:",omitempty"`
	// CreatedAt is when this task was initially created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,5,opt,name=created_at" `
	// StartedAt is when this task's execution began.
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=started_at" json:",omitempty"`
	// EndedAt is when this task's execution ended (whether because it succeeded or
	// failed).
	EndedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=ended_at" json:",omitempty"`
	// Success is whether this task's execution succeeded.
	Success bool `protobuf:"varint,8,opt,name=success,proto3" json:",omitempty"`
	// Failure is whether this task's execution failed.
	Failure bool `protobuf:"varint,9,opt,name=failure,proto3" json:",omitempty"`
	// Skipped is whether this task's execution was skipped.
	Skipped bool `protobuf:"varint,10,opt,name=skipped,proto3" json:",omitempty"`
	// Warnings is whether this task produced warnings. Tasks with
	// warnings are not displayed as "green". The warnings are
	// contained in the task logs.
	Warnings bool `protobuf:"varint,11,opt,name=warnings,proto3" json:",omitempty"`
}

func (m *BuildTask) Reset()         { *m = BuildTask{} }
func (m *BuildTask) String() string { return proto.CompactTextString(m) }
func (*BuildTask) ProtoMessage()    {}

type BuildTaskListOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *BuildTaskListOptions) Reset()         { *m = BuildTaskListOptions{} }
func (m *BuildTaskListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildTaskListOptions) ProtoMessage()    {}

// A BuildUpdate contains updated information to update on an existing build.
type BuildUpdate struct {
	StartedAt     *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:",omitempty"`
	EndedAt       *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:",omitempty"`
	HeartbeatAt   *pbtypes.Timestamp `protobuf:"bytes,3,opt,name=heartbeat_at" json:",omitempty"`
	Host          string             `protobuf:"bytes,4,opt,name=host,proto3" json:",omitempty"`
	Success       bool               `protobuf:"varint,5,opt,name=success,proto3" json:",omitempty"`
	Purged        bool               `protobuf:"varint,6,opt,name=purged,proto3" json:",omitempty"`
	Failure       bool               `protobuf:"varint,7,opt,name=failure,proto3" json:",omitempty"`
	Killed        bool               `protobuf:"varint,8,opt,name=killed,proto3" json:",omitempty"`
	Priority      int32              `protobuf:"varint,9,opt,name=priority,proto3" json:",omitempty"`
	BuilderConfig string             `protobuf:"bytes,10,opt,name=builder_config,proto3" json:",omitempty"`
}

func (m *BuildUpdate) Reset()         { *m = BuildUpdate{} }
func (m *BuildUpdate) String() string { return proto.CompactTextString(m) }
func (*BuildUpdate) ProtoMessage()    {}

type BuildList struct {
	Builds         []*Build `protobuf:"bytes,1,rep,name=builds" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *BuildList) Reset()         { *m = BuildList{} }
func (m *BuildList) String() string { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()    {}

type BuildsCreateOp struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" `
	// CommitID is the full commit ID of the commit to build. It is
	// required.
	CommitID string `protobuf:"bytes,2,opt,name=commit_id,proto3" json:",omitempty"`
	// Branch, if specified, indicates that this build's commit is on
	// the given branch. If Branch is set, Tag must be empty.
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:",omitempty"`
	// Tag, if specified, indicates that this build's commit has the
	// given tag. If Tag is set, Branch must be empty.
	Tag    string      `protobuf:"bytes,4,opt,name=tag,proto3" json:",omitempty"`
	Config BuildConfig `protobuf:"bytes,5,opt,name=config" `
}

func (m *BuildsCreateOp) Reset()         { *m = BuildsCreateOp{} }
func (m *BuildsCreateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateOp) ProtoMessage()    {}

type BuildsUpdateOp struct {
	Build BuildSpec   `protobuf:"bytes,1,opt,name=build" `
	Info  BuildUpdate `protobuf:"bytes,2,opt,name=info" `
}

func (m *BuildsUpdateOp) Reset()         { *m = BuildsUpdateOp{} }
func (m *BuildsUpdateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateOp) ProtoMessage()    {}

type BuildsListBuildTasksOp struct {
	Build BuildSpec             `protobuf:"bytes,1,opt,name=build" `
	Opt   *BuildTaskListOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsListBuildTasksOp) Reset()         { *m = BuildsListBuildTasksOp{} }
func (m *BuildsListBuildTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsListBuildTasksOp) ProtoMessage()    {}

type BuildTaskList struct {
	BuildTasks []*BuildTask `protobuf:"bytes,1,rep,name=build_tasks" json:",omitempty"`
}

func (m *BuildTaskList) Reset()         { *m = BuildTaskList{} }
func (m *BuildTaskList) String() string { return proto.CompactTextString(m) }
func (*BuildTaskList) ProtoMessage()    {}

type ChangesetReviewList struct {
	Reviews []*ChangesetReview `protobuf:"bytes,1,rep,name=reviews" json:",omitempty"`
}

func (m *ChangesetReviewList) Reset()         { *m = ChangesetReviewList{} }
func (m *ChangesetReviewList) String() string { return proto.CompactTextString(m) }
func (*ChangesetReviewList) ProtoMessage()    {}

type ChangesetList struct {
	Changesets []*Changeset `protobuf:"bytes,1,rep,name=changesets" json:",omitempty"`
}

func (m *ChangesetList) Reset()         { *m = ChangesetList{} }
func (m *ChangesetList) String() string { return proto.CompactTextString(m) }
func (*ChangesetList) ProtoMessage()    {}

type ChangesetEventList struct {
	Events []*ChangesetEvent `protobuf:"bytes,1,rep,name=events" json:",omitempty"`
}

func (m *ChangesetEventList) Reset()         { *m = ChangesetEventList{} }
func (m *ChangesetEventList) String() string { return proto.CompactTextString(m) }
func (*ChangesetEventList) ProtoMessage()    {}

type BuildsCreateTasksOp struct {
	Build BuildSpec    `protobuf:"bytes,1,opt,name=build" `
	Tasks []*BuildTask `protobuf:"bytes,2,rep,name=tasks" json:",omitempty"`
}

func (m *BuildsCreateTasksOp) Reset()         { *m = BuildsCreateTasksOp{} }
func (m *BuildsCreateTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateTasksOp) ProtoMessage()    {}

type BuildsUpdateTaskOp struct {
	Task TaskSpec   `protobuf:"bytes,1,opt,name=task" `
	Info TaskUpdate `protobuf:"bytes,2,opt,name=info" `
}

func (m *BuildsUpdateTaskOp) Reset()         { *m = BuildsUpdateTaskOp{} }
func (m *BuildsUpdateTaskOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateTaskOp) ProtoMessage()    {}

type BuildsGetTaskLogOp struct {
	Task TaskSpec            `protobuf:"bytes,1,opt,name=task" `
	Opt  *BuildGetLogOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *BuildsGetTaskLogOp) Reset()         { *m = BuildsGetTaskLogOp{} }
func (m *BuildsGetTaskLogOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetTaskLogOp) ProtoMessage()    {}

type BuildsDequeueNextOp struct {
}

func (m *BuildsDequeueNextOp) Reset()         { *m = BuildsDequeueNextOp{} }
func (m *BuildsDequeueNextOp) String() string { return proto.CompactTextString(m) }
func (*BuildsDequeueNextOp) ProtoMessage()    {}

// EmailAddr is an email address associated with a user.
type EmailAddr struct {
	// the email address (case-insensitively compared in the DB and API)
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// whether this email address has been verified
	Verified bool `protobuf:"varint,2,opt,name=verified,proto3" json:",omitempty"`
	// indicates this is the user's primary email (only 1 email can be primary per user)
	Primary bool `protobuf:"varint,3,opt,name=primary,proto3" json:",omitempty"`
	// whether Sourcegraph inferred via public data that this is an email for the user
	Guessed bool `protobuf:"varint,4,opt,name=guessed,proto3" json:",omitempty"`
	// indicates that this email should not be associated with the user (even if guessed in the future)
	Blacklisted bool `protobuf:"varint,5,opt,name=blacklisted,proto3" json:",omitempty"`
}

func (m *EmailAddr) Reset()         { *m = EmailAddr{} }
func (m *EmailAddr) String() string { return proto.CompactTextString(m) }
func (*EmailAddr) ProtoMessage()    {}

type LogEntries struct {
	MaxID   string   `protobuf:"bytes,1,opt,name=max_id,proto3" json:",omitempty"`
	Entries []string `protobuf:"bytes,2,rep,name=entries" json:",omitempty"`
}

func (m *LogEntries) Reset()         { *m = LogEntries{} }
func (m *LogEntries) String() string { return proto.CompactTextString(m) }
func (*LogEntries) ProtoMessage()    {}

type Org struct {
	User `protobuf:"bytes,1,opt,name=user,embedded=user" `
}

func (m *Org) Reset()         { *m = Org{} }
func (m *Org) String() string { return proto.CompactTextString(m) }
func (*Org) ProtoMessage()    {}

type OrgListMembersOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *OrgListMembersOptions) Reset()         { *m = OrgListMembersOptions{} }
func (m *OrgListMembersOptions) String() string { return proto.CompactTextString(m) }
func (*OrgListMembersOptions) ProtoMessage()    {}

// OrgSpec specifies an organization. At least one of Email, Login, and UID must be
// nonempty.
type OrgSpec struct {
	Org string `protobuf:"bytes,1,opt,name=org,proto3" json:",omitempty"`
	UID int32  `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
}

func (m *OrgSpec) Reset()         { *m = OrgSpec{} }
func (m *OrgSpec) String() string { return proto.CompactTextString(m) }
func (*OrgSpec) ProtoMessage()    {}

type OrgsListMembersOp struct {
	Org OrgSpec                `protobuf:"bytes,1,opt,name=org" `
	Opt *OrgListMembersOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *OrgsListMembersOp) Reset()         { *m = OrgsListMembersOp{} }
func (m *OrgsListMembersOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListMembersOp) ProtoMessage()    {}

type UserList struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:",omitempty"`
}

func (m *UserList) Reset()         { *m = UserList{} }
func (m *UserList) String() string { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()    {}

type UserCount struct {
	Count int32 `protobuf:"varint,1,opt,name=Count,proto3" json:",omitempty"`
}

func (m *UserCount) Reset()         { *m = UserCount{} }
func (m *UserCount) String() string { return proto.CompactTextString(m) }
func (*UserCount) ProtoMessage()    {}

// A Person represents either a registered user or a committer to a repository
// (typically when their commit email can't be resolved to a user).
type Person struct {
	// PersonSpec is an identifier for the person. If the person was resolved to a
	// user, then both Login and UID are set. Otherwise only Email is set, and it may
	// be obfuscated (to protect privacy).
	PersonSpec `protobuf:"bytes,1,opt,name=person_spec,embedded=person_spec" `
	// FullName is the (possibly empty) full name of the person.
	FullName string `protobuf:"bytes,2,opt,name=full_name,proto3" json:",omitempty"`
	// AvatarURL is the URL to the user's avatar image.
	AvatarURL string `protobuf:"bytes,3,opt,name=avatar_url,proto3" json:",omitempty"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}

// PersonSpec specifies a person. At least one of Email, Login, and UID must be
// nonempty.
type PersonSpec struct {
	// Email is a person's email address. It may be obfuscated (to protect privacy).
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// Login is a user's login.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:",omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,3,opt,name=uid,proto3" json:",omitempty"`
}

func (m *PersonSpec) Reset()         { *m = PersonSpec{} }
func (m *PersonSpec) String() string { return proto.CompactTextString(m) }
func (*PersonSpec) ProtoMessage()    {}

type TaskSpec struct {
	Build BuildSpec `protobuf:"bytes,1,opt,name=build" `
	ID    uint64    `protobuf:"varint,2,opt,name=id,proto3" json:",omitempty"`
}

func (m *TaskSpec) Reset()         { *m = TaskSpec{} }
func (m *TaskSpec) String() string { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()    {}

// A TaskUpdate contains updated information to update on an existing task.
type TaskUpdate struct {
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:",omitempty"`
	EndedAt   *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:",omitempty"`
	Success   bool               `protobuf:"varint,3,opt,name=success,proto3" json:",omitempty"`
	Failure   bool               `protobuf:"varint,4,opt,name=failure,proto3" json:",omitempty"`
	Skipped   bool               `protobuf:"varint,5,opt,name=skipped,proto3" json:",omitempty"`
	Warnings  bool               `protobuf:"varint,6,opt,name=warnings,proto3" json:",omitempty"`
}

func (m *TaskUpdate) Reset()         { *m = TaskUpdate{} }
func (m *TaskUpdate) String() string { return proto.CompactTextString(m) }
func (*TaskUpdate) ProtoMessage()    {}

// User represents a registered user.
type User struct {
	// UID is the numeric primary key for a user.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	// Login is the user's username.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:",omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
	// Name is the (possibly empty) full name of the user.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:",omitempty"`
	// IsOrganization is whether this user represents an organization.
	IsOrganization bool `protobuf:"varint,5,opt,name=is_organization,proto3" json:",omitempty"`
	// AvatarURL is the URL to an avatar image specified by the user.
	AvatarURL string `protobuf:"bytes,6,opt,name=avatar_url,proto3" json:",omitempty"`
	// Location is the user's physical location.
	Location string `protobuf:"bytes,7,opt,name=location,proto3" json:",omitempty"`
	// Company is the user's company.
	Company string `protobuf:"bytes,8,opt,name=company,proto3" json:",omitempty"`
	// HomepageURL is the user's homepage or blog URL.
	HomepageURL string `protobuf:"bytes,9,opt,name=homepage_url,proto3" json:",omitempty"`
	// Disabled is whether the user account is disabled.
	Disabled bool `protobuf:"varint,10,opt,name=disabled,proto3" json:",omitempty"`
	// Admin is whether the user is a site admin for the site named by
	// the Domain field.
	Admin bool `protobuf:"varint,12,opt,name=admin,proto3" json:",omitempty"`
	// Write is whether the user has write access for the site named by
	// the Domain field.
	Write bool `protobuf:"varint,13,opt,name=write,proto3" json:",omitempty"`
	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	RegisteredAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=registered_at" json:",omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
type UserSpec struct {
	// Login is a user's login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
}

func (m *UserSpec) Reset()         { *m = UserSpec{} }
func (m *UserSpec) String() string { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()    {}

// UsersListOptions specifies options for the UsersService.List method.
type UsersListOptions struct {
	// Query filters the results to only those whose logins match. The search algorithm
	// is an implementation detail (currently it is a prefix match).
	Query       string `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,2,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,3,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" `
}

func (m *UsersListOptions) Reset()         { *m = UsersListOptions{} }
func (m *UsersListOptions) String() string { return proto.CompactTextString(m) }
func (*UsersListOptions) ProtoMessage()    {}

type OrgsListOp struct {
	Member      UserSpec `protobuf:"bytes,1,opt,name=member" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *OrgsListOp) Reset()         { *m = OrgsListOp{} }
func (m *OrgsListOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListOp) ProtoMessage()    {}

type EmailAddrList struct {
	EmailAddrs []*EmailAddr `protobuf:"bytes,1,rep,name=email_addrs" json:",omitempty"`
}

func (m *EmailAddrList) Reset()         { *m = EmailAddrList{} }
func (m *EmailAddrList) String() string { return proto.CompactTextString(m) }
func (*EmailAddrList) ProtoMessage()    {}

type OrgList struct {
	Orgs []*Org `protobuf:"bytes,1,rep,name=orgs" json:",omitempty"`
}

func (m *OrgList) Reset()         { *m = OrgList{} }
func (m *OrgList) String() string { return proto.CompactTextString(m) }
func (*OrgList) ProtoMessage()    {}

type PasswordResetToken struct {
	// token is the hard to guess token that allows a user to set a new password.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:",omitempty"`
}

func (m *PasswordResetToken) Reset()         { *m = PasswordResetToken{} }
func (m *PasswordResetToken) String() string { return proto.CompactTextString(m) }
func (*PasswordResetToken) ProtoMessage()    {}

type PendingPasswordReset struct {
	// Link is the URL for resetting password using this token.
	// It is set in the response only if the request was made
	// by an admin user.
	Link string `protobuf:"bytes,1,opt,name=link,proto3" json:",omitempty"`
	// Token is the hard to guess token that allows a user to
	// set a new password.
	// It is set in the response only if the request was made
	// by an admin user.
	Token *PasswordResetToken `protobuf:"bytes,2,opt,name=token" json:",omitempty"`
	// EmailSent is set if the password reset link was emailed to
	// the user.
	EmailSent bool `protobuf:"varint,3,opt,name=email_sent,proto3" json:",omitempty"`
	// Login is the login name of user for whom this request is created.
	Login string `protobuf:"bytes,4,opt,name=login,proto3" json:",omitempty"`
}

func (m *PendingPasswordReset) Reset()         { *m = PendingPasswordReset{} }
func (m *PendingPasswordReset) String() string { return proto.CompactTextString(m) }
func (*PendingPasswordReset) ProtoMessage()    {}

type NewPassword struct {
	// password is the new password for the user who requested the password reset
	// token.
	Password string              `protobuf:"bytes,1,opt,name=password,proto3" json:",omitempty"`
	Token    *PasswordResetToken `protobuf:"bytes,2,opt,name=token" json:",omitempty"`
}

func (m *NewPassword) Reset()         { *m = NewPassword{} }
func (m *NewPassword) String() string { return proto.CompactTextString(m) }
func (*NewPassword) ProtoMessage()    {}

type NewAccount struct {
	// Login is the desired login for the new user account.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	// Password is the password for the new user account.
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:",omitempty"`
	// UID is the desired UID for the new user account.
	UID int32 `protobuf:"varint,4,opt,name=uid,proto3" json:",omitempty"`
}

func (m *NewAccount) Reset()         { *m = NewAccount{} }
func (m *NewAccount) String() string { return proto.CompactTextString(m) }
func (*NewAccount) ProtoMessage()    {}

type AccountInvite struct {
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
	// Write, if set, will grant write access to the user.
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:",omitempty"`
	// Admin, if set, will grant admin access to the user.
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:",omitempty"`
}

func (m *AccountInvite) Reset()         { *m = AccountInvite{} }
func (m *AccountInvite) String() string { return proto.CompactTextString(m) }
func (*AccountInvite) ProtoMessage()    {}

// An InviteSpec specifies an existing invite.
type InviteSpec struct {
	// Email is the email address for which the invite was generated.
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:",omitempty"`
}

func (m *InviteSpec) Reset()         { *m = InviteSpec{} }
func (m *InviteSpec) String() string { return proto.CompactTextString(m) }
func (*InviteSpec) ProtoMessage()    {}

type PendingInvite struct {
	// Link is the URL for signing up using this invite.
	Link string `protobuf:"bytes,1,opt,name=link,proto3" json:",omitempty"`
	// Token identifies the pending invite.
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:",omitempty"`
	// EmailSent is set if the invite link was emailed to the user.
	EmailSent bool `protobuf:"varint,3,opt,name=email_sent,proto3" json:",omitempty"`
}

func (m *PendingInvite) Reset()         { *m = PendingInvite{} }
func (m *PendingInvite) String() string { return proto.CompactTextString(m) }
func (*PendingInvite) ProtoMessage()    {}

type AccountInviteList struct {
	Invites []*AccountInvite `protobuf:"bytes,1,rep,name=invites" json:",omitempty"`
}

func (m *AccountInviteList) Reset()         { *m = AccountInviteList{} }
func (m *AccountInviteList) String() string { return proto.CompactTextString(m) }
func (*AccountInviteList) ProtoMessage()    {}

type AcceptedInvite struct {
	// Account holds the desired account details.
	Account *NewAccount `protobuf:"bytes,1,opt,name=account" json:",omitempty"`
	// Token identifies the pending invite.
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:",omitempty"`
}

func (m *AcceptedInvite) Reset()         { *m = AcceptedInvite{} }
func (m *AcceptedInvite) String() string { return proto.CompactTextString(m) }
func (*AcceptedInvite) ProtoMessage()    {}

type SSHKeyList struct {
	SSHKeys []SSHPublicKey `protobuf:"bytes,1,rep,name=ssh_keys" `
}

func (m *SSHKeyList) Reset()         { *m = SSHKeyList{} }
func (m *SSHKeyList) String() string { return proto.CompactTextString(m) }
func (*SSHKeyList) ProtoMessage()    {}

// SSHPublicKey that users to authenticate with for SSH git access.
type SSHPublicKey struct {
	// Key is the serialized key data in SSH wire format, with the name prefix.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:",omitempty"`
	// Name is the name of the SSH key.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:",omitempty"`
	// ID is the ID of the SSH key.
	ID uint64 `protobuf:"varint,3,opt,name=id,proto3" json:",omitempty"`
}

func (m *SSHPublicKey) Reset()         { *m = SSHPublicKey{} }
func (m *SSHPublicKey) String() string { return proto.CompactTextString(m) }
func (*SSHPublicKey) ProtoMessage()    {}

// AuthorizationCodeRequest: see
// https://tools.ietf.org/html/rfc6749#section-4.1.1.
type AuthorizationCodeRequest struct {
	ResponseType string   `protobuf:"bytes,1,opt,name=response_type,proto3" json:",omitempty"`
	ClientID     string   `protobuf:"bytes,2,opt,name=client_id,proto3" json:",omitempty"`
	RedirectURI  string   `protobuf:"bytes,3,opt,name=redirect_uri,proto3" json:",omitempty"`
	Scope        []string `protobuf:"bytes,4,rep,name=scope" json:",omitempty"`
	// UID is the UID of the user who will be presented with the code.
	UID int32 `protobuf:"varint,5,opt,name=uid,proto3" json:",omitempty"`
}

func (m *AuthorizationCodeRequest) Reset()         { *m = AuthorizationCodeRequest{} }
func (m *AuthorizationCodeRequest) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCodeRequest) ProtoMessage()    {}

// AuthorizationCode represents an access token request using the
// authorization_code OAuth2 grant type. See
// http://tools.ietf.org/html/rfc6749#section-4.1.3 for more
// information.
//
// The client_id field is not set in this message; it is taken from
// the authenticated client for the request (which must exist).
type AuthorizationCode struct {
	Code        string `protobuf:"bytes,1,opt,name=code,proto3" json:",omitempty"`
	RedirectURI string `protobuf:"bytes,2,opt,name=redirect_uri,proto3" json:",omitempty"`
}

func (m *AuthorizationCode) Reset()         { *m = AuthorizationCode{} }
func (m *AuthorizationCode) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCode) ProtoMessage()    {}

// LoginCredentials is the information a user submits to log in.
type LoginCredentials struct {
	// Login is the user's claimed login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:",omitempty"`
	// Password is the password (possibly) corresponding to the login.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:",omitempty"`
}

func (m *LoginCredentials) Reset()         { *m = LoginCredentials{} }
func (m *LoginCredentials) String() string { return proto.CompactTextString(m) }
func (*LoginCredentials) ProtoMessage()    {}

// BearerJWT is a Bearer JSON Web Token, which is used for client
// authentication during an authentication grant. See
// https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12#section-2.1
// for more information.
type BearerJWT struct {
	// Assertion is a JWT.
	Assertion string `protobuf:"bytes,1,opt,name=assertion,proto3" json:",omitempty"`
}

func (m *BearerJWT) Reset()         { *m = BearerJWT{} }
func (m *BearerJWT) String() string { return proto.CompactTextString(m) }
func (*BearerJWT) ProtoMessage()    {}

// AccessTokenRequest contains the information necessary to
// request an OAuth2 access token. It supports a subset of
// authorization grant types specified in
// http://tools.ietf.org/html/rfc6749#section-4.
type AccessTokenRequest struct {
	// See http://tools.ietf.org/html/rfc6749#section-1.3 for more
	// information on OAuth2 authorization grant types.
	//
	// Types that are valid to be assigned to AuthorizationGrant:
	//	*AccessTokenRequest_AuthorizationCode
	//	*AccessTokenRequest_ResourceOwnerPassword
	//	*AccessTokenRequest_BearerJWT
	AuthorizationGrant isAccessTokenRequest_AuthorizationGrant `protobuf_oneof:"authorization_grant"`
	// TokenURL is the token endpoint URL on the OAuth2 authorization
	// server that the client is requesting an access token from.
	TokenURL string   `protobuf:"bytes,9,opt,name=token_url,proto3" json:",omitempty"`
	Scope    []string `protobuf:"bytes,17,rep,name=scope" json:",omitempty"`
}

func (m *AccessTokenRequest) Reset()         { *m = AccessTokenRequest{} }
func (m *AccessTokenRequest) String() string { return proto.CompactTextString(m) }
func (*AccessTokenRequest) ProtoMessage()    {}

type isAccessTokenRequest_AuthorizationGrant interface {
	isAccessTokenRequest_AuthorizationGrant()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AccessTokenRequest_AuthorizationCode struct {
	AuthorizationCode *AuthorizationCode `protobuf:"bytes,1,opt,name=authorization_code,oneof"`
}
type AccessTokenRequest_ResourceOwnerPassword struct {
	ResourceOwnerPassword *LoginCredentials `protobuf:"bytes,2,opt,name=resource_owner_password,oneof"`
}
type AccessTokenRequest_BearerJWT struct {
	BearerJWT *BearerJWT `protobuf:"bytes,3,opt,name=bearer_jwt,oneof"`
}

func (*AccessTokenRequest_AuthorizationCode) isAccessTokenRequest_AuthorizationGrant()     {}
func (*AccessTokenRequest_ResourceOwnerPassword) isAccessTokenRequest_AuthorizationGrant() {}
func (*AccessTokenRequest_BearerJWT) isAccessTokenRequest_AuthorizationGrant()             {}

func (m *AccessTokenRequest) GetAuthorizationGrant() isAccessTokenRequest_AuthorizationGrant {
	if m != nil {
		return m.AuthorizationGrant
	}
	return nil
}

func (m *AccessTokenRequest) GetAuthorizationCode() *AuthorizationCode {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_AuthorizationCode); ok {
		return x.AuthorizationCode
	}
	return nil
}

func (m *AccessTokenRequest) GetResourceOwnerPassword() *LoginCredentials {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_ResourceOwnerPassword); ok {
		return x.ResourceOwnerPassword
	}
	return nil
}

func (m *AccessTokenRequest) GetBearerJWT() *BearerJWT {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_BearerJWT); ok {
		return x.BearerJWT
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessTokenRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _AccessTokenRequest_OneofMarshaler, _AccessTokenRequest_OneofUnmarshaler, []interface{}{
		(*AccessTokenRequest_AuthorizationCode)(nil),
		(*AccessTokenRequest_ResourceOwnerPassword)(nil),
		(*AccessTokenRequest_BearerJWT)(nil),
	}
}

func _AccessTokenRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessTokenRequest)
	// authorization_grant
	switch x := m.AuthorizationGrant.(type) {
	case *AccessTokenRequest_AuthorizationCode:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AuthorizationCode); err != nil {
			return err
		}
	case *AccessTokenRequest_ResourceOwnerPassword:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResourceOwnerPassword); err != nil {
			return err
		}
	case *AccessTokenRequest_BearerJWT:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BearerJWT); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessTokenRequest.AuthorizationGrant has unexpected type %T", x)
	}
	return nil
}

func _AccessTokenRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessTokenRequest)
	switch tag {
	case 1: // authorization_grant.authorization_code
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AuthorizationCode)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_AuthorizationCode{msg}
		return true, err
	case 2: // authorization_grant.resource_owner_password
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoginCredentials)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_ResourceOwnerPassword{msg}
		return true, err
	case 3: // authorization_grant.bearer_jwt
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BearerJWT)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_BearerJWT{msg}
		return true, err
	default:
		return false, nil
	}
}

// AccessTokenResponse is a successful access token response. See
// http://tools.ietf.org/html/rfc6749#section-5.1 for more
// information.
type AccessTokenResponse struct {
	AccessToken  string   `protobuf:"bytes,1,opt,name=access_token,proto3" json:",omitempty"`
	TokenType    string   `protobuf:"bytes,2,opt,name=token_type,proto3" json:",omitempty"`
	ExpiresInSec int32    `protobuf:"varint,3,opt,name=expires_in_sec,proto3" json:",omitempty"`
	RefreshToken string   `protobuf:"bytes,4,opt,name=refresh_token,proto3" json:",omitempty"`
	Scope        []string `protobuf:"bytes,5,rep,name=scope" json:",omitempty"`
}

func (m *AccessTokenResponse) Reset()         { *m = AccessTokenResponse{} }
func (m *AccessTokenResponse) String() string { return proto.CompactTextString(m) }
func (*AccessTokenResponse) ProtoMessage()    {}

// AuthInfo describes the currently authenticated client and/or user
// (if any).
type AuthInfo struct {
	// ClientID is the client ID of the currently authenticated
	// client. If a user is authenticated using an access token,
	// ClientID is the client ID of the registered client that the
	// access token was granted to.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,proto3" json:",omitempty"`
	// UID is the UID of the currently authenticated user (if any).
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	// Domain is the domain of the currently authenticated user (if
	// any), or blank if the user account was registered on the
	// current server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:",omitempty"`
	// Login is the login of the currently authenticated user (if any).
	Login string `protobuf:"bytes,4,opt,name=login,proto3" json:",omitempty"`
	// Write is set if the user (if any) has write access on this server.
	Write bool `protobuf:"varint,5,opt,name=write,proto3" json:",omitempty"`
	// Admin is set if the user (if any) has admin access on this server.
	Admin bool `protobuf:"varint,6,opt,name=admin,proto3" json:",omitempty"`
	// Scopes represent the permissions granted to the authenticated
	// user (if any).
	Scopes []string `protobuf:"bytes,7,rep,name=scopes" json:",omitempty"`
}

func (m *AuthInfo) Reset()         { *m = AuthInfo{} }
func (m *AuthInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()    {}

type AuthorshipInfo struct {
	AuthorEmail    string            `protobuf:"bytes,1,opt,name=author_email,proto3" json:",omitempty"`
	LastCommitDate pbtypes.Timestamp `protobuf:"bytes,2,opt,name=last_commit_date" `
	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	LastCommitID string `protobuf:"bytes,3,opt,name=last_commit_id,proto3" json:",omitempty"`
}

func (m *AuthorshipInfo) Reset()         { *m = AuthorshipInfo{} }
func (m *AuthorshipInfo) String() string { return proto.CompactTextString(m) }
func (*AuthorshipInfo) ProtoMessage()    {}

// Def is a code def returned by the Sourcegraph API.
type Def struct {
	graph.Def  `protobuf:"bytes,1,opt,name=def,embedded=def" json:""`
	DocHTML    *pbtypes2.HTML          `protobuf:"bytes,2,opt,name=doc_html" json:",omitempty"`
	FmtStrings *graph.DefFormatStrings `protobuf:"bytes,3,opt,name=fmt_strings" json:",omitempty"`
}

func (m *Def) Reset()         { *m = Def{} }
func (m *Def) String() string { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()    {}

type DefAuthor struct {
	UID           int32  `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	Email         string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	DefAuthorship `protobuf:"bytes,3,opt,name=def_authorship,embedded=def_authorship" `
}

func (m *DefAuthor) Reset()         { *m = DefAuthor{} }
func (m *DefAuthor) String() string { return proto.CompactTextString(m) }
func (*DefAuthor) ProtoMessage()    {}

type DefAuthorship struct {
	AuthorshipInfo `protobuf:"bytes,1,opt,name=authorship_info,embedded=authorship_info" `
	// Exported is whether the def is exported.
	Exported        bool    `protobuf:"varint,2,opt,name=exported,proto3" json:",omitempty"`
	Bytes           int32   `protobuf:"varint,3,opt,name=bytes,proto3" json:",omitempty"`
	BytesProportion float64 `protobuf:"fixed64,4,opt,name=bytes_proportion,proto3" json:",omitempty"`
}

func (m *DefAuthorship) Reset()         { *m = DefAuthorship{} }
func (m *DefAuthorship) String() string { return proto.CompactTextString(m) }
func (*DefAuthorship) ProtoMessage()    {}

type DefClient struct {
	UID            int32  `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	Email          string `protobuf:"bytes,2,opt,name=email,proto3" json:",omitempty"`
	AuthorshipInfo `protobuf:"bytes,3,opt,name=authorship_info,embedded=authorship_info" `
	// UseCount is the number of times this person referred to the def.
	UseCount int32 `protobuf:"varint,4,opt,name=use_count,proto3" json:",omitempty"`
}

func (m *DefClient) Reset()         { *m = DefClient{} }
func (m *DefClient) String() string { return proto.CompactTextString(m) }
func (*DefClient) ProtoMessage()    {}

// A DefDelta represents a single definition that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the def was changed from base to head. Otherwise, one of the fields being
// nil means that the def did not exist in that revision (e.g., it was added or
// deleted from base to head).
type DefDelta struct {
	// the def in the base commit (if nil, this def was added in the head)
	Base *Def `protobuf:"bytes,1,opt,name=base" json:",omitempty"`
	// the def in the head commit (if nil, this def was deleted in the head)
	Head *Def `protobuf:"bytes,2,opt,name=head" json:",omitempty"`
}

func (m *DefDelta) Reset()         { *m = DefDelta{} }
func (m *DefDelta) String() string { return proto.CompactTextString(m) }
func (*DefDelta) ProtoMessage()    {}

// DefGetOptions specifies options for DefsService.Get.
type DefGetOptions struct {
	Doc bool `protobuf:"varint,1,opt,name=doc,proto3" json:",omitempty" url:",omitempty"`
}

func (m *DefGetOptions) Reset()         { *m = DefGetOptions{} }
func (m *DefGetOptions) String() string { return proto.CompactTextString(m) }
func (*DefGetOptions) ProtoMessage()    {}

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
type DefListAuthorsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *DefListAuthorsOptions) Reset()         { *m = DefListAuthorsOptions{} }
func (m *DefListAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListAuthorsOptions) ProtoMessage()    {}

// DefListClientsOptions specifies options for DefsService.ListClients.
type DefListClientsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" `
}

func (m *DefListClientsOptions) Reset()         { *m = DefListClientsOptions{} }
func (m *DefListClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListClientsOptions) ProtoMessage()    {}

// DefListExamplesOptions specifies options for DefsService.ListExamples.
type DefListExamplesOptions struct {
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty" url:",omitempty"`
	// Filter by a specific Repo URI
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:",omitempty" url:",omitempty"`
	ListOptions     `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" `
}

func (m *DefListExamplesOptions) Reset()         { *m = DefListExamplesOptions{} }
func (m *DefListExamplesOptions) String() string { return proto.CompactTextString(m) }
func (*DefListExamplesOptions) ProtoMessage()    {}

// DefListOptions specifies options for DefsService.List.
type DefListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:",omitempty" url:",omitempty"`
	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteStart uint32 `protobuf:"varint,3,opt,name=byte_start,proto3" json:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteEnd uint32 `protobuf:"varint,4,opt,name=byte_end,proto3" json:",omitempty"`
	// DefKeys, if set, will return the definitions that match the given DefKey
	DefKeys []*graph.DefKey `protobuf:"bytes,5,rep,name=def_keys" json:",omitempty"`
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,6,rep,name=repo_revs" json:",omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,7,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,8,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	Path     string   `protobuf:"bytes,9,opt,name=path,proto3" json:",omitempty" url:",omitempty"`
	// Files, if specified, will restrict the results to only defs defined in the
	// specified file.
	Files []string `protobuf:"bytes,10,rep,name=files" json:",omitempty" url:",omitempty"`
	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	FilePathPrefix string   `protobuf:"bytes,11,opt,name=file_path_prefix,proto3" json:",omitempty" url:",omitempty"`
	Kinds          []string `protobuf:"bytes,12,rep,name=kinds" json:",omitempty" url:",omitempty,comma"`
	Exported       bool     `protobuf:"varint,13,opt,name=exported,proto3" json:",omitempty" url:",omitempty"`
	Nonlocal       bool     `protobuf:"varint,14,opt,name=nonlocal,proto3" json:",omitempty" url:",omitempty"`
	// IncludeTest is whether the results should include definitions in test files.
	IncludeTest bool `protobuf:"varint,15,opt,name=include_test,proto3" json:",omitempty" url:",omitempty"`
	// Enhancements
	Doc   bool `protobuf:"varint,16,opt,name=doc,proto3" json:",omitempty" url:",omitempty"`
	Fuzzy bool `protobuf:"varint,17,opt,name=fuzzy,proto3" json:",omitempty" url:",omitempty"`
	// Sorting
	Sort      string `protobuf:"bytes,18,opt,name=sort,proto3" json:",omitempty" url:",omitempty"`
	Direction string `protobuf:"bytes,19,opt,name=direction,proto3" json:",omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,20,opt,name=list_options,embedded=list_options" `
}

func (m *DefListOptions) Reset()         { *m = DefListOptions{} }
func (m *DefListOptions) String() string { return proto.CompactTextString(m) }
func (*DefListOptions) ProtoMessage()    {}

type DefListRefsOptions struct {
	Authorship  bool   `protobuf:"varint,1,opt,name=authorship,proto3" json:",omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,2,opt,name=repo,proto3" json:",omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *DefListRefsOptions) Reset()         { *m = DefListRefsOptions{} }
func (m *DefListRefsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListRefsOptions) ProtoMessage()    {}

// DefSpec specifies a def.
type DefSpec struct {
	Repo     string `protobuf:"bytes,1,opt,name=repo,proto3" json:",omitempty"`
	CommitID string `protobuf:"bytes,2,opt,name=commit_id,proto3" json:",omitempty"`
	UnitType string `protobuf:"bytes,3,opt,name=unit_type,proto3" json:",omitempty"`
	Unit     string `protobuf:"bytes,4,opt,name=unit,proto3" json:",omitempty"`
	Path     string `protobuf:"bytes,5,opt,name=path,proto3" json:",omitempty"`
}

func (m *DefSpec) Reset()         { *m = DefSpec{} }
func (m *DefSpec) String() string { return proto.CompactTextString(m) }
func (*DefSpec) ProtoMessage()    {}

type DefsGetOp struct {
	Def DefSpec        `protobuf:"bytes,1,opt,name=def" `
	Opt *DefGetOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsGetOp) Reset()         { *m = DefsGetOp{} }
func (m *DefsGetOp) String() string { return proto.CompactTextString(m) }
func (*DefsGetOp) ProtoMessage()    {}

type DefList struct {
	Defs         []*Def `protobuf:"bytes,1,rep,name=defs" json:",omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" `
}

func (m *DefList) Reset()         { *m = DefList{} }
func (m *DefList) String() string { return proto.CompactTextString(m) }
func (*DefList) ProtoMessage()    {}

type DefsListRefsOp struct {
	Def DefSpec             `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListRefsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListRefsOp) Reset()         { *m = DefsListRefsOp{} }
func (m *DefsListRefsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListRefsOp) ProtoMessage()    {}

type RefList struct {
	Refs           []*Ref `protobuf:"bytes,1,rep,name=refs" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *RefList) Reset()         { *m = RefList{} }
func (m *RefList) String() string { return proto.CompactTextString(m) }
func (*RefList) ProtoMessage()    {}

type DefsListExamplesOp struct {
	Def DefSpec `protobuf:"bytes,1,opt,name=def" `
	// If set, source code in the examples will be linked to this branch, rather
	// than to the commit ID.
	Rev string                  `protobuf:"bytes,2,opt,name=rev,proto3" json:",omitempty"`
	Opt *DefListExamplesOptions `protobuf:"bytes,3,opt,name=opt" json:",omitempty"`
}

func (m *DefsListExamplesOp) Reset()         { *m = DefsListExamplesOp{} }
func (m *DefsListExamplesOp) String() string { return proto.CompactTextString(m) }
func (*DefsListExamplesOp) ProtoMessage()    {}

type ExampleList struct {
	Examples       []*Example `protobuf:"bytes,1,rep,name=examples" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *ExampleList) Reset()         { *m = ExampleList{} }
func (m *ExampleList) String() string { return proto.CompactTextString(m) }
func (*ExampleList) ProtoMessage()    {}

type DefsListAuthorsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListAuthorsOp) Reset()         { *m = DefsListAuthorsOp{} }
func (m *DefsListAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListAuthorsOp) ProtoMessage()    {}

type DefsListClientsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" `
	Opt *DefListClientsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DefsListClientsOp) Reset()         { *m = DefsListClientsOp{} }
func (m *DefsListClientsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListClientsOp) ProtoMessage()    {}

// Delta represents the difference between two commits (possibly in 2 separate
// repositories).
type Delta struct {
	Base       RepoRevSpec `protobuf:"bytes,1,opt,name=base" `
	Head       RepoRevSpec `protobuf:"bytes,2,opt,name=head" `
	BaseCommit *vcs.Commit `protobuf:"bytes,3,opt,name=base_commit" json:",omitempty"`
	HeadCommit *vcs.Commit `protobuf:"bytes,4,opt,name=head_commit" json:",omitempty"`
	BaseRepo   *Repo       `protobuf:"bytes,5,opt,name=base_repo" json:",omitempty"`
	HeadRepo   *Repo       `protobuf:"bytes,6,opt,name=head_repo" json:",omitempty"`
}

func (m *Delta) Reset()         { *m = Delta{} }
func (m *Delta) String() string { return proto.CompactTextString(m) }
func (*Delta) ProtoMessage()    {}

// DeltaAffectedPerson describes a person (registered user or committer email
// address) that is affected by a delta. It includes fields for the person affected
// as well as the defs that are the reason why we consider them to be affected.
//
// The person's relationship to the Defs depends on what method returned this
// DeltaAffectedPerson. If it was returned by a method that lists authors, then the
// Defs are definitions that the Person committed. If it was returned by a method
// that lists clients (a.k.a users), then the Defs are definitions that the Person
// uses.
type DeltaAffectedPerson struct {
	// the affected person
	Person `protobuf:"bytes,1,opt,name=person,embedded=person" `
	// the defs they authored or use (the reason why they're affected)
	Defs []*Def `protobuf:"bytes,2,rep,name=defs" json:",omitempty"`
}

func (m *DeltaAffectedPerson) Reset()         { *m = DeltaAffectedPerson{} }
func (m *DeltaAffectedPerson) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPerson) ProtoMessage()    {}

// DeltaDefs describes definitions added/changed/deleted in a delta.
type DeltaDefs struct {
	// added/changed/deleted defs
	Defs []*DefDelta `protobuf:"bytes,1,rep,name=defs" json:",omitempty"`
	// overall diffstat (not subject to pagination)
	DiffStat diff.Stat `protobuf:"bytes,2,opt,name=diff_stat" `
}

func (m *DeltaDefs) Reset()         { *m = DeltaDefs{} }
func (m *DeltaDefs) String() string { return proto.CompactTextString(m) }
func (*DeltaDefs) ProtoMessage()    {}

// FileDiff holds data about a diff, and additionally stores extended
// information about its hunks.
type FileDiff struct {
	diff.FileDiff `protobuf:"bytes,1,opt,name=file_diff,embedded=file_diff" `
	FileDiffHunks []*Hunk `protobuf:"bytes,2,rep,name=file_diff_hunks" json:",omitempty"`
	// PreImage is the CommitID at which this file was before the change occurred.
	PreImage string `protobuf:"bytes,3,opt,name=pre_image,proto3" json:",omitempty"`
	// PostImage is the CommitID at which this file was after the change occurred.
	PostImage string `protobuf:"bytes,4,opt,name=post_image,proto3" json:",omitempty"`
	// Stat contains statistics about additions and deletions to this diff.
	Stats diff.Stat `protobuf:"bytes,5,opt,name=stats" `
}

func (m *FileDiff) Reset()         { *m = FileDiff{} }
func (m *FileDiff) String() string { return proto.CompactTextString(m) }
func (*FileDiff) ProtoMessage()    {}

// Hunk holds data about a hunk in a diff.
type Hunk struct {
	diff.Hunk `protobuf:"bytes,1,opt,name=hunk,embedded=hunk" `
	// LinePrefixes holds a string where each character's index corresponds
	// to a line in the BodySource, and its value reflects whether the line
	// is an addition, deletion, or change ('+', '-', ' ').
	LinePrefixes string `protobuf:"bytes,2,opt,name=line_prefixes,proto3" json:",omitempty"`
	// BaseSource holds the source code for the original hunk, having all
	// lines starting from the original line down to the end of the hunk.
	BaseSource *SourceCode `protobuf:"bytes,3,opt,name=base_source" json:",omitempty"`
	// HeadSource contains the source code for the new hunk, holding
	// all consecutive lines from the start to the end.
	HeadSource *SourceCode `protobuf:"bytes,4,opt,name=head_source" json:",omitempty"`
	// BodySource contains the source code for the Hunk body and is a mix
	// of both additions and deletions.
	BodySource *SourceCode `protobuf:"bytes,5,opt,name=body_source" json:",omitempty"`
}

func (m *Hunk) Reset()         { *m = Hunk{} }
func (m *Hunk) String() string { return proto.CompactTextString(m) }
func (*Hunk) ProtoMessage()    {}

// DeltaFiles describes files added/changed/deleted in a delta.
type DeltaFiles struct {
	FileDiffs []*FileDiff `protobuf:"bytes,1,rep,name=file_diffs" json:",omitempty"`
	Delta     *Delta      `protobuf:"bytes,2,opt,name=delta" json:",omitempty"`
	Stats     diff.Stat   `protobuf:"bytes,3,opt,name=stats" `
	// OverThreshold will be true when the source code contents of the diff
	// have not been tokenized and linked. This occurs when the 'MaxSize'
	// limit in DeltaListFilesOptions has been met.
	OverThreshold bool `protobuf:"varint,4,opt,name=over_threshold,proto3" json:",omitempty"`
}

func (m *DeltaFiles) Reset()         { *m = DeltaFiles{} }
func (m *DeltaFiles) String() string { return proto.CompactTextString(m) }
func (*DeltaFiles) ProtoMessage()    {}

// DeltaFilter specifies criteria by which to filter results from DeltaListXxx
// methods.
type DeltaFilter struct {
	Unit     string `protobuf:"bytes,1,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	UnitType string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
}

func (m *DeltaFilter) Reset()         { *m = DeltaFilter{} }
func (m *DeltaFilter) String() string { return proto.CompactTextString(m) }
func (*DeltaFilter) ProtoMessage()    {}

// DeltaListAffectedAuthorsOptions specifies options for ListAffectedAuthors.
type DeltaListAffectedAuthorsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListAffectedAuthorsOptions) Reset()         { *m = DeltaListAffectedAuthorsOptions{} }
func (m *DeltaListAffectedAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedAuthorsOptions) ProtoMessage()    {}

// DeltaListAffectedClientsOptions specifies options for ListAffectedClients.
type DeltaListAffectedClientsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListAffectedClientsOptions) Reset()         { *m = DeltaListAffectedClientsOptions{} }
func (m *DeltaListAffectedClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedClientsOptions) ProtoMessage()    {}

// DeltaListDefsOptions specifies options for ListDefs.
type DeltaListDefsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" `
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *DeltaListDefsOptions) Reset()         { *m = DeltaListDefsOptions{} }
func (m *DeltaListDefsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListDefsOptions) ProtoMessage()    {}

// DeltaListFilesOptions specifies options for ListFiles.
type DeltaListFilesOptions struct {
	// Formatted is whether the files should have their contents code-formatted
	// (syntax-highlighted and reference-linked) if they contain code.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty" url:",omitempty"`
	// Filter filters the list of returned files to those whose name matches Filter.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:",omitempty" url:",omitempty"`
	// Tokenized, when set, will tokenize the whole source code
	// contained in the diff, returning 3 versions for each hunk: Head
	// revision, Base revision and Hunk body. For more information,
	// see sourcegraph.Hunk.
	Tokenized bool `protobuf:"varint,3,opt,name=tokenized,proto3" json:",omitempty" url:",omitempty"`
	// MaxSize stores the maximum number of bytes that will be accepted for tokenizing
	// the diff. If the size of the diff exceeds this value, the returned structure
	// will not contain the linked and tokenized source code.
	// This option is useful when one wishes to present the data in a browser and it
	// may be too large for that. DeltaFiles structure size can be up to 4 times the
	// size of the raw diff when tokenized and linked.
	MaxSize     int32 `protobuf:"varint,4,opt,name=max_size,proto3" json:",omitempty" url:",omitempty"`
	DeltaFilter `protobuf:"bytes,5,opt,name=delta_filter,embedded=delta_filter" `
}

func (m *DeltaListFilesOptions) Reset()         { *m = DeltaListFilesOptions{} }
func (m *DeltaListFilesOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListFilesOptions) ProtoMessage()    {}

// DeltaListUnitsOptions specifies options for ListUnits.
type DeltaListUnitsOptions struct {
}

func (m *DeltaListUnitsOptions) Reset()         { *m = DeltaListUnitsOptions{} }
func (m *DeltaListUnitsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListUnitsOptions) ProtoMessage()    {}

// A DeltaSpec specifies a delta.
type DeltaSpec struct {
	Base RepoRevSpec `protobuf:"bytes,1,opt,name=base" `
	Head RepoRevSpec `protobuf:"bytes,2,opt,name=head" `
}

func (m *DeltaSpec) Reset()         { *m = DeltaSpec{} }
func (m *DeltaSpec) String() string { return proto.CompactTextString(m) }
func (*DeltaSpec) ProtoMessage()    {}

type DeltasListUnitsOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListUnitsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListUnitsOp) Reset()         { *m = DeltasListUnitsOp{} }
func (m *DeltasListUnitsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListUnitsOp) ProtoMessage()    {}

type UnitDeltaList struct {
	UnitDeltas []*UnitDelta `protobuf:"bytes,1,rep,name=unit_deltas" json:",omitempty"`
}

func (m *UnitDeltaList) Reset()         { *m = UnitDeltaList{} }
func (m *UnitDeltaList) String() string { return proto.CompactTextString(m) }
func (*UnitDeltaList) ProtoMessage()    {}

type DeltasListDefsOp struct {
	Ds  DeltaSpec             `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListDefsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListDefsOp) Reset()         { *m = DeltasListDefsOp{} }
func (m *DeltasListDefsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListDefsOp) ProtoMessage()    {}

type DeltasListFilesOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListFilesOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListFilesOp) Reset()         { *m = DeltasListFilesOp{} }
func (m *DeltasListFilesOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListFilesOp) ProtoMessage()    {}

type DeltasListAffectedAuthorsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListAffectedAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListAffectedAuthorsOp) Reset()         { *m = DeltasListAffectedAuthorsOp{} }
func (m *DeltasListAffectedAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedAuthorsOp) ProtoMessage()    {}

type DeltaAffectedPersonList struct {
	DeltaAffectedPersons []*DeltaAffectedPerson `protobuf:"bytes,1,rep,name=delta_affected_persons" json:",omitempty"`
}

func (m *DeltaAffectedPersonList) Reset()         { *m = DeltaAffectedPersonList{} }
func (m *DeltaAffectedPersonList) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPersonList) ProtoMessage()    {}

type DeltasListAffectedClientsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" `
	Opt *DeltaListAffectedClientsOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *DeltasListAffectedClientsOp) Reset()         { *m = DeltasListAffectedClientsOp{} }
func (m *DeltasListAffectedClientsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedClientsOp) ProtoMessage()    {}

// Example is a usage example of a def.
type Example struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	// SrcHTML is the formatted HTML source code of the example, with links to
	// definitions.
	SrcHTML string `protobuf:"bytes,2,opt,name=src_html,proto3" json:",omitempty"`
	// SourceCode contains the parsed source for this example, if requested via
	// DefListExamplesOptions.
	SourceCode *SourceCode `protobuf:"bytes,3,opt,name=source_code" json:",omitempty"`
	// The line that the given example starts on
	StartLine int32 `protobuf:"varint,4,opt,name=start_line,proto3" json:",omitempty"`
	// The line that the given example ends on
	EndLine int32 `protobuf:"varint,5,opt,name=end_line,proto3" json:",omitempty"`
	// Error is whether an error occurred while fetching this example.
	Error bool `protobuf:"varint,6,opt,name=error,proto3" json:",omitempty"`
	// If the example has been requested by revision name (ie. branch, tag), this
	// value will be set.
	Rev string `protobuf:"bytes,7,opt,name=rev,proto3" json:",omitempty"`
}

func (m *Example) Reset()         { *m = Example{} }
func (m *Example) String() string { return proto.CompactTextString(m) }
func (*Example) ProtoMessage()    {}

// FormatResult contains information about and warnings from the formatting
// operation (if Formatted is true in the options).
type FormatResult struct {
	// TooManyRefs indicates that the file being formatted exceeded the maximum number
	// of refs that are linked. Only the first NumRefs refs are linked.
	TooManyRefs bool `protobuf:"varint,1,opt,name=too_many_refs,proto3" json:",omitempty"`
	// NumRefs is the number of refs that were linked in this file. If the total number
	// of refs in the file exceeds the (server-defined) limit, NumRefs is capped at the
	// limit.
	NumRefs int32 `protobuf:"varint,2,opt,name=num_refs,proto3" json:",omitempty"`
	// LineStartByteOffsets is the byte offset of each line's first byte.
	LineStartByteOffsets []int32 `protobuf:"varint,3,rep,name=line_start_byte_offsets" json:",omitempty"`
}

func (m *FormatResult) Reset()         { *m = FormatResult{} }
func (m *FormatResult) String() string { return proto.CompactTextString(m) }
func (*FormatResult) ProtoMessage()    {}

type MarkdownData struct {
	Rendered  []byte     `protobuf:"bytes,1,opt,name=rendered,proto3" json:",omitempty"`
	Checklist *Checklist `protobuf:"bytes,2,opt,name=checklist" json:",omitempty"`
}

func (m *MarkdownData) Reset()         { *m = MarkdownData{} }
func (m *MarkdownData) String() string { return proto.CompactTextString(m) }
func (*MarkdownData) ProtoMessage()    {}

type MarkdownOpt struct {
	EnableCheckboxes bool `protobuf:"varint,1,opt,name=enable_checkboxes,proto3" json:",omitempty"`
}

func (m *MarkdownOpt) Reset()         { *m = MarkdownOpt{} }
func (m *MarkdownOpt) String() string { return proto.CompactTextString(m) }
func (*MarkdownOpt) ProtoMessage()    {}

type MarkdownRequestBody struct {
	Markdown    []byte `protobuf:"bytes,1,opt,name=markdown,proto3" json:",omitempty"`
	MarkdownOpt `protobuf:"bytes,2,opt,name=markdown_opt,embedded=markdown_opt" `
}

func (m *MarkdownRequestBody) Reset()         { *m = MarkdownRequestBody{} }
func (m *MarkdownRequestBody) String() string { return proto.CompactTextString(m) }
func (*MarkdownRequestBody) ProtoMessage()    {}

type MarkdownRenderOp struct {
	Markdown []byte      `protobuf:"bytes,1,opt,name=markdown,proto3" json:",omitempty"`
	Opt      MarkdownOpt `protobuf:"bytes,2,opt,name=opt" `
}

func (m *MarkdownRenderOp) Reset()         { *m = MarkdownRenderOp{} }
func (m *MarkdownRenderOp) String() string { return proto.CompactTextString(m) }
func (*MarkdownRenderOp) ProtoMessage()    {}

type Ref struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	Authorship *AuthorshipInfo `protobuf:"bytes,2,opt,name=authorship" json:",omitempty"`
}

func (m *Ref) Reset()         { *m = Ref{} }
func (m *Ref) String() string { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()    {}

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
type RepoTreeGetOptions struct {
	// Formatted is whether the specified entry, if it's a file, should have its
	// Contents code-formatted using HTML.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:",omitempty"`
	// HighlightStrings is a list of fixed strings that should be wrapped in a <span
	// class="highlight"> in the returned HTML. It only takes effect if Formatted is
	// true.
	HighlightStrings []string `protobuf:"bytes,2,rep,name=highlight_strings" json:",omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource          bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:",omitempty" url:",omitempty"`
	ContentsAsString         bool `protobuf:"varint,4,opt,name=contents_as_string,proto3" json:",omitempty" url:",omitempty"`
	vcsclient.GetFileOptions `protobuf:"bytes,5,opt,name=get_file_options,embedded=get_file_options" `
}

func (m *RepoTreeGetOptions) Reset()         { *m = RepoTreeGetOptions{} }
func (m *RepoTreeGetOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOptions) ProtoMessage()    {}

type RepoTreeSearchOptions struct {
	vcs.SearchOptions `protobuf:"bytes,1,opt,name=search_options,embedded=search_options" `
	Formatted         bool `protobuf:"varint,2,opt,name=formatted,proto3" json:",omitempty"`
}

func (m *RepoTreeSearchOptions) Reset()         { *m = RepoTreeSearchOptions{} }
func (m *RepoTreeSearchOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOptions) ProtoMessage()    {}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
type RepoTreeSearchResult struct {
	vcs.SearchResult `protobuf:"bytes,1,opt,name=search_result,embedded=search_result" `
	RepoRev          RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
}

func (m *RepoTreeSearchResult) Reset()         { *m = RepoTreeSearchResult{} }
func (m *RepoTreeSearchResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchResult) ProtoMessage()    {}

type RepoTreeGetOp struct {
	Entry TreeEntrySpec       `protobuf:"bytes,1,opt,name=entry" `
	Opt   *RepoTreeGetOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *RepoTreeGetOp) Reset()         { *m = RepoTreeGetOp{} }
func (m *RepoTreeGetOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOp) ProtoMessage()    {}

type RepoTreeSearchOp struct {
	Rev RepoRevSpec            `protobuf:"bytes,1,opt,name=rev" `
	Opt *RepoTreeSearchOptions `protobuf:"bytes,2,opt,name=opt" json:",omitempty"`
}

func (m *RepoTreeSearchOp) Reset()         { *m = RepoTreeSearchOp{} }
func (m *RepoTreeSearchOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOp) ProtoMessage()    {}

type RepoTreeListOp struct {
	Rev RepoRevSpec `protobuf:"bytes,1,opt,name=rev" `
}

func (m *RepoTreeListOp) Reset()         { *m = RepoTreeListOp{} }
func (m *RepoTreeListOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeListOp) ProtoMessage()    {}

type RepoTreeListResult struct {
	Files []string `protobuf:"bytes,1,rep,name=files" json:",omitempty"`
}

func (m *RepoTreeListResult) Reset()         { *m = RepoTreeListResult{} }
func (m *RepoTreeListResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeListResult) ProtoMessage()    {}

type VCSSearchResultList struct {
	SearchResults []*vcs.SearchResult `protobuf:"bytes,1,rep,name=search_results" json:",omitempty"`
	ListResponse  `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" `
}

func (m *VCSSearchResultList) Reset()         { *m = VCSSearchResultList{} }
func (m *VCSSearchResultList) String() string { return proto.CompactTextString(m) }
func (*VCSSearchResultList) ProtoMessage()    {}

type TokenSearchOptions struct {
	Query       string      `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:"q" schema:"q"`
	RepoRev     RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *TokenSearchOptions) Reset()         { *m = TokenSearchOptions{} }
func (m *TokenSearchOptions) String() string { return proto.CompactTextString(m) }
func (*TokenSearchOptions) ProtoMessage()    {}

type TextSearchOptions struct {
	Query       string      `protobuf:"bytes,1,opt,name=query,proto3" json:",omitempty" url:"q" schema:"q"`
	RepoRev     RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" `
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" `
}

func (m *TextSearchOptions) Reset()         { *m = TextSearchOptions{} }
func (m *TextSearchOptions) String() string { return proto.CompactTextString(m) }
func (*TextSearchOptions) ProtoMessage()    {}

// SourceCode contains a snippet of code with linked and classed tokens, along with
// other information about the contents.
//
// This data structure is useful when one desires to take full control of rendering
// and manipulating the contents of the requested TreeEntry or snippet, rather than
// dealing with an (annotated) string or parsing text. To obtain this structure in
// the TreeEntry, TokenizedSource must be set to "true" in the RepoTreeGetOptions.
type SourceCode struct {
	// Lines contains all the lines of the contained code snippet.
	Lines       []*SourceCodeLine `protobuf:"bytes,1,rep,name=lines" json:",omitempty"`
	NumRefs     int32             `protobuf:"varint,2,opt,name=num_refs,proto3" json:",omitempty"`
	TooManyRefs bool              `protobuf:"varint,3,opt,name=too_many_refs,proto3" json:",omitempty"`
}

func (m *SourceCode) Reset()         { *m = SourceCode{} }
func (m *SourceCode) String() string { return proto.CompactTextString(m) }
func (*SourceCode) ProtoMessage()    {}

// SourceCodeLine contains all tokens on this line along with other information
// such as byte offsets in original source.
type SourceCodeLine struct {
	// StartByte and EndByte are the start and end offsets in bytes, in the original
	// file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:",omitempty"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:",omitempty"`
	// Tokens contains any tokens that may be on this line, including whitespace. New
	// lines ('\n') are not present.
	Tokens []*SourceCodeToken `protobuf:"bytes,3,rep,name=tokens" json:",omitempty"`
}

func (m *SourceCodeLine) Reset()         { *m = SourceCodeLine{} }
func (m *SourceCodeLine) String() string { return proto.CompactTextString(m) }
func (*SourceCodeLine) ProtoMessage()    {}

// SourceCodeToken contains information about a code token.
type SourceCodeToken struct {
	// Start and end byte offsets in original file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"-"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:"-"`
	// If the token is a reference URL contains the DefKey-based URLs for all the
	// definitions at this position.
	URL []string `protobuf:"bytes,3,rep,name=url" json:",omitempty"`
	// IsDef specifies whether the token is a definition.
	IsDef bool `protobuf:"varint,4,opt,name=is_def,proto3" json:",omitempty"`
	// Class specifies the token type as per
	// [google-code-prettify](https://code.google.com/p/google-code-prettify/).
	// All tokens except Whitespace will have this field.
	Class string `protobuf:"bytes,5,opt,name=class,proto3" json:",omitempty"`
	// ExtraClasses may additionally contain other classes for this token, such as
	// for example highlighting in a diff.
	ExtraClasses string `protobuf:"bytes,6,opt,name=extraClasses,proto3" json:",omitempty"`
	// Label is non-whitespace HTML encoded source code.
	Label string `protobuf:"bytes,7,opt,name=label,proto3" json:",omitempty"`
}

func (m *SourceCodeToken) Reset()         { *m = SourceCodeToken{} }
func (m *SourceCodeToken) String() string { return proto.CompactTextString(m) }
func (*SourceCodeToken) ProtoMessage()    {}

// TreeEntry is a file or directory in a repository, with additional feedback from
// the formatting operation (if Formatted is true in the options).
type TreeEntry struct {
	*vcsclient.TreeEntry `protobuf:"bytes,1,opt,name=tree_entry,embedded=tree_entry" json:""`
	*vcsclient.FileRange `protobuf:"bytes,2,opt,name=file_range,embedded=file_range" json:",omitempty"`
	ContentsString       string `protobuf:"bytes,3,opt,name=contents_string,proto3" json:",omitempty"`
	// SourceCode is set when TokenizedSource is enabled in RepoTreeGetOptions.
	SourceCode *SourceCode `protobuf:"bytes,4,opt,name=source_code" json:",omitempty"`
	// FormatResult is only set if this TreeEntry is a file.
	FormatResult *FormatResult `protobuf:"bytes,5,opt,name=format_result" json:",omitempty"`
}

func (m *TreeEntry) Reset()         { *m = TreeEntry{} }
func (m *TreeEntry) String() string { return proto.CompactTextString(m) }
func (*TreeEntry) ProtoMessage()    {}

type TreeEntrySpec struct {
	RepoRev RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev" `
	Path    string      `protobuf:"bytes,2,opt,name=path,proto3" json:",omitempty"`
}

func (m *TreeEntrySpec) Reset()         { *m = TreeEntrySpec{} }
func (m *TreeEntrySpec) String() string { return proto.CompactTextString(m) }
func (*TreeEntrySpec) ProtoMessage()    {}

// A UnitDelta represents a single source unit that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the unit was changed from base to head. Otherwise, one of the fields being
// nil means that the unit did not exist in that revision (e.g., it was added or
// deleted from base to head).
type UnitDelta struct {
	Base *unit.RepoSourceUnit `protobuf:"bytes,1,opt,name=base" json:",omitempty"`
	Head *unit.RepoSourceUnit `protobuf:"bytes,2,opt,name=head" json:",omitempty"`
}

func (m *UnitDelta) Reset()         { *m = UnitDelta{} }
func (m *UnitDelta) String() string { return proto.CompactTextString(m) }
func (*UnitDelta) ProtoMessage()    {}

// UnitListOptions specifies options for UnitsService.List.
type UnitListOptions struct {
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,1,rep,name=repo_revs" json:",omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,3,opt,name=unit,proto3" json:",omitempty" url:",omitempty"`
	// NameQuery specifies a full-text search query over the unit name.
	NameQuery string `protobuf:"bytes,4,opt,name=name_query,proto3" json:",omitempty" url:",omitempty"`
	// Query specifies a full-text search query over the repo URI, unit name, and unit
	// data.
	Query string `protobuf:"bytes,5,opt,name=query,proto3" json:",omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,6,opt,name=list_options,embedded=list_options" `
}

func (m *UnitListOptions) Reset()         { *m = UnitListOptions{} }
func (m *UnitListOptions) String() string { return proto.CompactTextString(m) }
func (*UnitListOptions) ProtoMessage()    {}

// UnitSpec specifies a source unit.
type UnitSpec struct {
	RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev_spec,embedded=repo_rev_spec" `
	UnitType    string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:",omitempty"`
	Unit        string `protobuf:"bytes,3,opt,name=unit,proto3" json:",omitempty"`
}

func (m *UnitSpec) Reset()         { *m = UnitSpec{} }
func (m *UnitSpec) String() string { return proto.CompactTextString(m) }
func (*UnitSpec) ProtoMessage()    {}

type RepoSourceUnitList struct {
	Units []*unit.RepoSourceUnit `protobuf:"bytes,1,rep,name=units" json:",omitempty"`
}

func (m *RepoSourceUnitList) Reset()         { *m = RepoSourceUnitList{} }
func (m *RepoSourceUnitList) String() string { return proto.CompactTextString(m) }
func (*RepoSourceUnitList) ProtoMessage()    {}

type DefAuthorList struct {
	DefAuthors []*DefAuthor `protobuf:"bytes,1,rep,name=def_authors" json:",omitempty"`
}

func (m *DefAuthorList) Reset()         { *m = DefAuthorList{} }
func (m *DefAuthorList) String() string { return proto.CompactTextString(m) }
func (*DefAuthorList) ProtoMessage()    {}

type DefClientList struct {
	DefClients []*DefClient `protobuf:"bytes,1,rep,name=def_clients" json:",omitempty"`
}

func (m *DefClientList) Reset()         { *m = DefClientList{} }
func (m *DefClientList) String() string { return proto.CompactTextString(m) }
func (*DefClientList) ProtoMessage()    {}

type Checklist struct {
	// number of tasks to be done (unchecked)
	Todo int32 `protobuf:"varint,1,opt,name=todo,proto3" json:",omitempty"`
	// number of tasks that are done (checked)
	Done int32 `protobuf:"varint,2,opt,name=done,proto3" json:",omitempty"`
}

func (m *Checklist) Reset()         { *m = Checklist{} }
func (m *Checklist) String() string { return proto.CompactTextString(m) }
func (*Checklist) ProtoMessage()    {}

type FileToken struct {
	Path  string               `protobuf:"bytes,1,opt,name=path,proto3" json:",omitempty"`
	Entry *vcsclient.TreeEntry `protobuf:"bytes,2,opt,name=entry" json:",omitempty"`
}

func (m *FileToken) Reset()         { *m = FileToken{} }
func (m *FileToken) String() string { return proto.CompactTextString(m) }
func (*FileToken) ProtoMessage()    {}

// ServerStatus describes the server's status.
type ServerStatus struct {
	// Info contains arbitrary human-readable status information about
	// the server.
	Info string `protobuf:"bytes,1,opt,name=info,proto3" json:",omitempty"`
}

func (m *ServerStatus) Reset()         { *m = ServerStatus{} }
func (m *ServerStatus) String() string { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()    {}

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
type ServerConfig struct {
	// Version is the version of Sourcegraph that this server is
	// running.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:",omitempty"`
	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	AppURL string `protobuf:"bytes,2,opt,name=app_url,proto3" json:",omitempty"`
	// FederationRootURL is the --fed.root-url CLI flag's value. It is
	// the URL of the federation root server, or blank if this server
	// is itself a federation root (in which case IsFederationRoot is
	// true).
	FederationRootURL string `protobuf:"bytes,5,opt,name=federation_root_url,proto3" json:",omitempty"`
	// IsFederationRoot is whether this server is itself a federation
	// root. If true, then FederationRootURL is empty.
	IsFederationRoot bool `protobuf:"varint,6,opt,name=is_federation_root,proto3" json:",omitempty"`
	// IDKey is the server's identity key (ID key).
	IDKey string `protobuf:"bytes,7,opt,name=id_key,proto3" json:",omitempty"`
	// AllowAnonymousReaders is whether anonymous (unauthenticated)
	// users may perform "read" operations, such as viewing
	// repositories.
	AllowAnonymousReaders bool `protobuf:"varint,9,opt,name=allow_anonymous_readers,proto3" json:",omitempty"`
	// AuthSource is which mode of authentication is set up on the
	// server (local|oauth|ldap).
	AuthSource string `protobuf:"bytes,10,opt,name=auth_source,proto3" json:",omitempty"`
}

func (m *ServerConfig) Reset()         { *m = ServerConfig{} }
func (m *ServerConfig) String() string { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()    {}

// A RegisteredClient is a registered API client.
//
// Many fields correspond to those listed at
// http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata.
//
// It's called RegisteredClient instead of Client to avoid a name
// conflict with the existing Client (Go) type.
type RegisteredClient struct {
	// ID is a unique identifier for this client.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
	// RedirectURIs is a list of allowed redirect URIs.
	RedirectURIs []string `protobuf:"bytes,2,rep,name=redirect_uris" json:",omitempty"`
	// ClientName is the name of the client to be presented to the
	// end-user.
	ClientName string `protobuf:"bytes,3,opt,name=client_name,proto3" json:",omitempty"`
	// LogoURI is a URL to this client's logo.
	LogoURI string `protobuf:"bytes,4,opt,name=logo_uri,proto3" json:",omitempty"`
	// ClientURI is a URL to this client's homepage.
	ClientURI string `protobuf:"bytes,5,opt,name=client_uri,proto3" json:",omitempty"`
	// JWKS is the client's JSON Web Key Set. It contains the client's
	// public keys, if any.
	JWKS string `protobuf:"bytes,6,opt,name=jwks,proto3" json:",omitempty"`
	// ClientSecret is the secret value that authenticates the
	// client. It may be empty (e.g., if JWKS keys are used for
	// authentication instead).
	ClientSecret string `protobuf:"bytes,7,opt,name=client_secret,proto3" json:",omitempty"`
	// Description is a human-readable description of this API client
	// that's shown to the user during, e.g., OAuth2 authentication.
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:",omitempty"`
	// Meta holds arbitrary metadata about this API client. The
	// structure is defined by the API client and is opaque to the
	// server.
	Meta map[string]string `protobuf:"bytes,9,rep,name=meta" json:",omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// RegisteredClientType describes this client's type.
	Type RegisteredClientType `protobuf:"varint,10,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:",omitempty"`
	// CreatedAt is when this API client's record was created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,11,opt,name=created_at" `
	// UpdatedAt is when this API client's record was last updated.
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,12,opt,name=updated_at" `
}

func (m *RegisteredClient) Reset()         { *m = RegisteredClient{} }
func (m *RegisteredClient) String() string { return proto.CompactTextString(m) }
func (*RegisteredClient) ProtoMessage()    {}

// A RegisteredClientSpec uniquely identifies a RegisteredClient.
type RegisteredClientSpec struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
}

func (m *RegisteredClientSpec) Reset()         { *m = RegisteredClientSpec{} }
func (m *RegisteredClientSpec) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientSpec) ProtoMessage()    {}

// A RegisteredClientCredentials authenticates a RegisteredClient.
type RegisteredClientCredentials struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:",omitempty"`
	// Secret is the client's secret.
	Secret string `protobuf:"bytes,2,opt,name=secret,proto3" json:",omitempty"`
}

func (m *RegisteredClientCredentials) Reset()         { *m = RegisteredClientCredentials{} }
func (m *RegisteredClientCredentials) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientCredentials) ProtoMessage()    {}

// RegisteredClientListOptions configures a call to
// RegisteredClients.List.
type RegisteredClientListOptions struct {
	Type        RegisteredClientType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:",omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" `
}

func (m *RegisteredClientListOptions) Reset()         { *m = RegisteredClientListOptions{} }
func (m *RegisteredClientListOptions) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientListOptions) ProtoMessage()    {}

// RegisteredClientList holds a list of clients.
type RegisteredClientList struct {
	Clients        []*RegisteredClient `protobuf:"bytes,1,rep,name=clients" json:",omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=stream_response,embedded=stream_response" `
}

func (m *RegisteredClientList) Reset()         { *m = RegisteredClientList{} }
func (m *RegisteredClientList) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientList) ProtoMessage()    {}

type UserPermissions struct {
	// UID is a user's UID.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:",omitempty"`
	// ClientID is the ID of the client whose whitelist is to
	// be fetched and/or modified.
	ClientID string `protobuf:"bytes,2,opt,name=client_id,proto3" json:",omitempty"`
	// Read is true if the user has read permissions on the client.
	Read bool `protobuf:"varint,3,opt,name=read,proto3" json:",omitempty"`
	// Write is true if the user has write permissions on the client.
	Write bool `protobuf:"varint,4,opt,name=write,proto3" json:",omitempty"`
	// Admin is true if the user should be considered an admin on
	// the client.
	Admin bool `protobuf:"varint,5,opt,name=admin,proto3" json:",omitempty"`
}

func (m *UserPermissions) Reset()         { *m = UserPermissions{} }
func (m *UserPermissions) String() string { return proto.CompactTextString(m) }
func (*UserPermissions) ProtoMessage()    {}

type UserPermissionsList struct {
	UserPermissions []*UserPermissions `protobuf:"bytes,1,rep,name=user_permissions" json:",omitempty"`
}

func (m *UserPermissionsList) Reset()         { *m = UserPermissionsList{} }
func (m *UserPermissionsList) String() string { return proto.CompactTextString(m) }
func (*UserPermissionsList) ProtoMessage()    {}

type UserPermissionsOptions struct {
	ClientSpec *RegisteredClientSpec `protobuf:"bytes,1,opt,name=client_spec" json:",omitempty"`
	UID        int32                 `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
}

func (m *UserPermissionsOptions) Reset()         { *m = UserPermissionsOptions{} }
func (m *UserPermissionsOptions) String() string { return proto.CompactTextString(m) }
func (*UserPermissionsOptions) ProtoMessage()    {}

// MetricsSnapshots encodes
type MetricsSnapshot struct {
	// Type is the encoding of TelemetryData
	Type TelemetryType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.TelemetryType" json:",omitempty"`
	// TelemetryData is the encoded metrics
	TelemetryData []byte `protobuf:"bytes,2,opt,name=telemetry_data,proto3" json:",omitempty"`
}

func (m *MetricsSnapshot) Reset()         { *m = MetricsSnapshot{} }
func (m *MetricsSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetricsSnapshot) ProtoMessage()    {}

// UserEvent encodes any user initiated event on the local instance.
type UserEvent struct {
	Type     string `protobuf:"bytes,1,opt,name=type,proto3" json:",omitempty"`
	UID      int32  `protobuf:"varint,2,opt,name=uid,proto3" json:",omitempty"`
	ClientID string `protobuf:"bytes,3,opt,name=client_id,proto3" json:",omitempty"`
	Service  string `protobuf:"bytes,4,opt,name=service,proto3" json:",omitempty"`
	Method   string `protobuf:"bytes,5,opt,name=method,proto3" json:",omitempty"`
	Result   string `protobuf:"bytes,6,opt,name=result,proto3" json:",omitempty"`
	// CreatedAt holds the time when this event was logged.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=created_at" json:",omitempty"`
	Message   string             `protobuf:"bytes,8,opt,name=message,proto3" json:",omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,9,opt,name=version,proto3" json:",omitempty"`
	// URL holds the http request url.
	URL string `protobuf:"bytes,10,opt,name=url,proto3" json:",omitempty"`
}

func (m *UserEvent) Reset()         { *m = UserEvent{} }
func (m *UserEvent) String() string { return proto.CompactTextString(m) }
func (*UserEvent) ProtoMessage()    {}

type UserEventList struct {
	Events []*UserEvent `protobuf:"bytes,1,rep,name=events" json:",omitempty"`
}

func (m *UserEventList) Reset()         { *m = UserEventList{} }
func (m *UserEventList) String() string { return proto.CompactTextString(m) }
func (*UserEventList) ProtoMessage()    {}

// Event is any event logged on a Sourcegraph instance.
type Event struct {
	Type            string             `protobuf:"bytes,1,opt,name=type,proto3" json:",omitempty"`
	UserID          string             `protobuf:"bytes,2,opt,name=user_id,proto3" json:",omitempty"`
	DeviceID        string             `protobuf:"bytes,3,opt,name=device_id,proto3" json:",omitempty"`
	ClientID        string             `protobuf:"bytes,4,opt,name=client_id,proto3" json:",omitempty"`
	Timestamp       *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=timestamp" json:",omitempty"`
	UserProperties  map[string]string  `protobuf:"bytes,6,rep,name=user_properties" json:",omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	EventProperties map[string]string  `protobuf:"bytes,7,rep,name=event_properties" json:",omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}

type EventList struct {
	Events []*Event `protobuf:"bytes,1,rep,name=events" json:",omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:",omitempty"`
	// AppURL holds the base URL of the Sourcegraph app.
	AppURL string `protobuf:"bytes,3,opt,name=app_url,proto3" json:",omitempty"`
}

func (m *EventList) Reset()         { *m = EventList{} }
func (m *EventList) String() string { return proto.CompactTextString(m) }
func (*EventList) ProtoMessage()    {}

// NotifyGenericEvent describes an action being done against an object. For
// example reviewing a changeset.
type NotifyGenericEvent struct {
	// Actor is the User who did the action
	Actor *UserSpec `protobuf:"bytes,1,opt,name=actor" json:",omitempty"`
	// Recipients is who should be notified of the action
	Recipients []*UserSpec `protobuf:"bytes,2,rep,name=recipients" json:",omitempty"`
	// ActionType example: "reviewed"
	ActionType string `protobuf:"bytes,3,opt,name=action_type,proto3" json:",omitempty"`
	// ActionContent example: "Please add tests for the new functionality"
	ActionContent string `protobuf:"bytes,4,opt,name=action_content,proto3" json:",omitempty"`
	// ObjectID example: 71
	ObjectID int64 `protobuf:"varint,5,opt,name=object_id,proto3" json:",omitempty"`
	// ObjectRepo example: "gorilla/mux"
	ObjectRepo string `protobuf:"bytes,6,opt,name=object_repo,proto3" json:",omitempty"`
	// ObjectType example: "changeset"
	ObjectType string `protobuf:"bytes,7,opt,name=object_type,proto3" json:",omitempty"`
	// ObjectTitle example: "search: Simplify tokenizer"
	ObjectTitle string `protobuf:"bytes,8,opt,name=object_title,proto3" json:",omitempty"`
	// ObjectURL example: "https://src.sourcegraph.com/sourcegraph/.changesets/71"
	ObjectURL string `protobuf:"bytes,9,opt,name=object_url,proto3" json:",omitempty"`
	// SlackMsg, if present, will override the Slack message for this event.
	SlackMsg string `protobuf:"bytes,10,opt,name=slack_msg,proto3" json:",omitempty"`
	// EmailHTML, if present, will override the notification email body for this event.
	EmailHTML string `protobuf:"bytes,11,opt,name=email_html,proto3" json:",omitempty"`
	// NoEmail turns off the email notification for this event.
	NoEmail bool `protobuf:"varint,13,opt,name=no_email,proto3" json:",omitempty"`
}

func (m *NotifyGenericEvent) Reset()         { *m = NotifyGenericEvent{} }
func (m *NotifyGenericEvent) String() string { return proto.CompactTextString(m) }
func (*NotifyGenericEvent) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("sourcegraph.RegisteredClientType", RegisteredClientType_name, RegisteredClientType_value)
	proto.RegisterEnum("sourcegraph.TelemetryType", TelemetryType_name, TelemetryType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for RepoBadges service

type RepoBadgesClient interface {
	// ListBadges lists the available badges for repo.
	ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error)
}

type repoBadgesClient struct {
	cc *grpc.ClientConn
}

func NewRepoBadgesClient(cc *grpc.ClientConn) RepoBadgesClient {
	return &repoBadgesClient{cc}
}

func (c *repoBadgesClient) ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error) {
	out := new(BadgeList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListBadges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error) {
	out := new(CounterList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListCounters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/RecordHit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error) {
	out := new(RepoBadgesCountHitsResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/CountHits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoBadges service

type RepoBadgesServer interface {
	// ListBadges lists the available badges for repo.
	ListBadges(context.Context, *RepoSpec) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(context.Context, *RepoSpec) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(context.Context, *RepoBadgesCountHitsOp) (*RepoBadgesCountHitsResult, error)
}

func RegisterRepoBadgesServer(s *grpc.Server, srv RepoBadgesServer) {
	s.RegisterService(&_RepoBadges_serviceDesc, srv)
}

func _RepoBadges_ListBadges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListBadges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_ListCounters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListCounters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_RecordHit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).RecordHit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_CountHits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoBadgesCountHitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).CountHits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoBadges_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoBadges",
	HandlerType: (*RepoBadgesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBadges",
			Handler:    _RepoBadges_ListBadges_Handler,
		},
		{
			MethodName: "ListCounters",
			Handler:    _RepoBadges_ListCounters_Handler,
		},
		{
			MethodName: "RecordHit",
			Handler:    _RepoBadges_RecordHit_Handler,
		},
		{
			MethodName: "CountHits",
			Handler:    _RepoBadges_CountHits_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// Create creates a new repository.
	Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error)
	// Update updates a repository.
	Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error)
	// Delete removes a repository.
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error) {
	out := new(Readme)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetReadme", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error) {
	out := new(RepoConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error) {
	out := new(CommitterList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommitters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error) {
	out := new(SrclibDataVersion)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetSrclibDataVersionForPath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ConfigureApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error) {
	out := new(inventory.Inventory)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetInventory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// Create creates a new repository.
	Create(context.Context, *ReposCreateOp) (*Repo, error)
	// Update updates a repository.
	Update(context.Context, *ReposUpdateOp) (*Repo, error)
	// Delete removes a repository.
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(context.Context, *RepoRevSpec) (*Readme, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(context.Context, *RepoSpec) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(context.Context, *ReposListCommittersOp) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(context.Context, *TreeEntrySpec) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(context.Context, *RepoConfigureAppOp) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(context.Context, *RepoRevSpec) (*inventory.Inventory, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetReadme_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetReadme(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetConfig(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommitters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommittersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommitters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetSrclibDataVersionForPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TreeEntrySpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetSrclibDataVersionForPath(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ConfigureApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoConfigureAppOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ConfigureApp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetInventory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Repos_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "GetReadme",
			Handler:    _Repos_GetReadme_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Repos_GetConfig_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
		{
			MethodName: "ListCommitters",
			Handler:    _Repos_ListCommitters_Handler,
		},
		{
			MethodName: "GetSrclibDataVersionForPath",
			Handler:    _Repos_GetSrclibDataVersionForPath_Handler,
		},
		{
			MethodName: "ConfigureApp",
			Handler:    _Repos_ConfigureApp_Handler,
		},
		{
			MethodName: "GetInventory",
			Handler:    _Repos_GetInventory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Storage service

type StorageClient interface {
	// Get gets the value of a storage object.
	//
	// If the specified object does not exist, a NotFound error is returned.
	Get(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageValue, error)
	// Put puts an object into storage overwriting the old object (if any).
	Put(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// PutNoOverwrite puts an object into storage, returning a AlreadyExists error
	// if the object already exists.
	PutNoOverwrite(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete deletes the specific storage object or, if no key is specified, all
	// objects in the bucket.
	//
	// If the given key or bucket does not exist, this function is no-op.
	Delete(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Exists tells if the given key exists in the bucket or not.
	//
	// If the object does not exist, no error is returned, only exists=false is
	// returned.
	Exists(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageExists, error)
	// List lists all objects in the bucket. It ignores the 'key' field of the
	// storage name parameter.
	//
	// If the bucket does not exist, no error is returned, only an empty list is
	// returned.
	List(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageList, error)
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) Get(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageValue, error) {
	out := new(StorageValue)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Put(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) PutNoOverwrite(ctx context.Context, in *StoragePutOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/PutNoOverwrite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Delete(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) Exists(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageExists, error) {
	out := new(StorageExists)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/Exists", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) List(ctx context.Context, in *StorageKey, opts ...grpc.CallOption) (*StorageList, error) {
	out := new(StorageList)
	err := grpc.Invoke(ctx, "/sourcegraph.Storage/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Storage service

type StorageServer interface {
	// Get gets the value of a storage object.
	//
	// If the specified object does not exist, a NotFound error is returned.
	Get(context.Context, *StorageKey) (*StorageValue, error)
	// Put puts an object into storage overwriting the old object (if any).
	Put(context.Context, *StoragePutOp) (*pbtypes1.Void, error)
	// PutNoOverwrite puts an object into storage, returning a AlreadyExists error
	// if the object already exists.
	PutNoOverwrite(context.Context, *StoragePutOp) (*pbtypes1.Void, error)
	// Delete deletes the specific storage object or, if no key is specified, all
	// objects in the bucket.
	//
	// If the given key or bucket does not exist, this function is no-op.
	Delete(context.Context, *StorageKey) (*pbtypes1.Void, error)
	// Exists tells if the given key exists in the bucket or not.
	//
	// If the object does not exist, no error is returned, only exists=false is
	// returned.
	Exists(context.Context, *StorageKey) (*StorageExists, error)
	// List lists all objects in the bucket. It ignores the 'key' field of the
	// storage name parameter.
	//
	// If the bucket does not exist, no error is returned, only an empty list is
	// returned.
	List(context.Context, *StorageKey) (*StorageList, error)
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StoragePutOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Put(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_PutNoOverwrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StoragePutOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).PutNoOverwrite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).Exists(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Storage_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(StorageKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(StorageServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Storage_Get_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _Storage_Put_Handler,
		},
		{
			MethodName: "PutNoOverwrite",
			Handler:    _Storage_PutNoOverwrite_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Storage_Delete_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _Storage_Exists_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Storage_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Changesets service

type ChangesetsClient interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error)
	// List lists changesets for a repository.
	List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error)
	// Update updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error)
	// Merge merges the head branch of a changeset into its base branch and
	// pushes the resulting merged base. It returns the resulting update event.
	// If no merge occurred, it returns nil.
	Merge(ctx context.Context, in *ChangesetMergeOp, opts ...grpc.CallOption) (*ChangesetEvent, error)
	// UpdateAffected updates all changesets which may be affected
	// by new commits to a branch and returns the list of update
	// events for all affected changesets.
	UpdateAffected(ctx context.Context, in *ChangesetUpdateAffectedOp, opts ...grpc.CallOption) (*ChangesetEventList, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error)
}

type changesetsClient struct {
	cc *grpc.ClientConn
}

func NewChangesetsClient(cc *grpc.ClientConn) ChangesetsClient {
	return &changesetsClient{cc}
}

func (c *changesetsClient) Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error) {
	out := new(ChangesetList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error) {
	out := new(ChangesetEvent)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Merge(ctx context.Context, in *ChangesetMergeOp, opts ...grpc.CallOption) (*ChangesetEvent, error) {
	out := new(ChangesetEvent)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Merge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) UpdateAffected(ctx context.Context, in *ChangesetUpdateAffectedOp, opts ...grpc.CallOption) (*ChangesetEventList, error) {
	out := new(ChangesetEventList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/UpdateAffected", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error) {
	out := new(ChangesetReview)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/CreateReview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error) {
	out := new(ChangesetReviewList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListReviews", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error) {
	out := new(ChangesetEventList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Changesets service

type ChangesetsServer interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(context.Context, *ChangesetCreateOp) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(context.Context, *ChangesetSpec) (*Changeset, error)
	// List lists changesets for a repository.
	List(context.Context, *ChangesetListOp) (*ChangesetList, error)
	// Update updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(context.Context, *ChangesetUpdateOp) (*ChangesetEvent, error)
	// Merge merges the head branch of a changeset into its base branch and
	// pushes the resulting merged base. It returns the resulting update event.
	// If no merge occurred, it returns nil.
	Merge(context.Context, *ChangesetMergeOp) (*ChangesetEvent, error)
	// UpdateAffected updates all changesets which may be affected
	// by new commits to a branch and returns the list of update
	// events for all affected changesets.
	UpdateAffected(context.Context, *ChangesetUpdateAffectedOp) (*ChangesetEventList, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(context.Context, *ChangesetCreateReviewOp) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(context.Context, *ChangesetListReviewsOp) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(context.Context, *ChangesetSpec) (*ChangesetEventList, error)
}

func RegisterChangesetsServer(s *grpc.Server, srv ChangesetsServer) {
	s.RegisterService(&_Changesets_serviceDesc, srv)
}

func _Changesets_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Merge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetMergeOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Merge(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_UpdateAffected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetUpdateAffectedOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).UpdateAffected(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_CreateReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetCreateReviewOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).CreateReview(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListReviews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetListReviewsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListReviews(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListEvents(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Changesets_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Changesets",
	HandlerType: (*ChangesetsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Changesets_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Changesets_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Changesets_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Changesets_Update_Handler,
		},
		{
			MethodName: "Merge",
			Handler:    _Changesets_Merge_Handler,
		},
		{
			MethodName: "UpdateAffected",
			Handler:    _Changesets_UpdateAffected_Handler,
		},
		{
			MethodName: "CreateReview",
			Handler:    _Changesets_CreateReview_Handler,
		},
		{
			MethodName: "ListReviews",
			Handler:    _Changesets_ListReviews_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _Changesets_ListEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *MirrorReposRefreshVCSOp) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirrorReposRefreshVCSOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysClient interface {
	Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error)
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirroredRepoSSHKeysClient struct {
	cc *grpc.ClientConn
}

func NewMirroredRepoSSHKeysClient(cc *grpc.ClientConn) MirroredRepoSSHKeysClient {
	return &mirroredRepoSSHKeysClient{cc}
}

func (c *mirroredRepoSSHKeysClient) Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error) {
	out := new(SSHPrivateKey)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysServer interface {
	Create(context.Context, *MirroredRepoSSHKeysCreateOp) (*pbtypes1.Void, error)
	Get(context.Context, *RepoSpec) (*SSHPrivateKey, error)
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
}

func RegisterMirroredRepoSSHKeysServer(s *grpc.Server, srv MirroredRepoSSHKeysServer) {
	s.RegisterService(&_MirroredRepoSSHKeys_serviceDesc, srv)
}

func _MirroredRepoSSHKeys_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirroredRepoSSHKeysCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirroredRepoSSHKeys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirroredRepoSSHKeys",
	HandlerType: (*MirroredRepoSSHKeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MirroredRepoSSHKeys_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MirroredRepoSSHKeys_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MirroredRepoSSHKeys_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Builds service

type BuildsClient interface {
	// Get fetches a build.
	Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error)
	// GetRepoBuild returns the build for the repo at the given exact
	// commit or branch head commit.
	//
	// NOTE: Previously, this method looked at the build and commit
	// history to find the "best recent build." This method no longer
	// implements that functionality. Refer to
	// Repos.GetSrclibDataVersionForPath.
	GetRepoBuild(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Build, error)
	// List builds.
	List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error)
}

type buildsClient struct {
	cc *grpc.ClientConn
}

func NewBuildsClient(cc *grpc.ClientConn) BuildsClient {
	return &buildsClient{cc}
}

func (c *buildsClient) Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetRepoBuild(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetRepoBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/ListBuildTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/CreateTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error) {
	out := new(BuildTask)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/UpdateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetTaskLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/DequeueNext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Builds service

type BuildsServer interface {
	// Get fetches a build.
	Get(context.Context, *BuildSpec) (*Build, error)
	// GetRepoBuild returns the build for the repo at the given exact
	// commit or branch head commit.
	//
	// NOTE: Previously, this method looked at the build and commit
	// history to find the "best recent build." This method no longer
	// implements that functionality. Refer to
	// Repos.GetSrclibDataVersionForPath.
	GetRepoBuild(context.Context, *RepoRevSpec) (*Build, error)
	// List builds.
	List(context.Context, *BuildListOptions) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(context.Context, *BuildsCreateOp) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(context.Context, *BuildsUpdateOp) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(context.Context, *BuildsListBuildTasksOp) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(context.Context, *BuildsCreateTasksOp) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(context.Context, *BuildsUpdateTaskOp) (*BuildTask, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(context.Context, *BuildsGetTaskLogOp) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(context.Context, *BuildsDequeueNextOp) (*Build, error)
}

func RegisterBuildsServer(s *grpc.Server, srv BuildsServer) {
	s.RegisterService(&_Builds_serviceDesc, srv)
}

func _Builds_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetRepoBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetRepoBuild(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_ListBuildTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsListBuildTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).ListBuildTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_CreateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).CreateTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateTaskOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).UpdateTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetTaskLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsGetTaskLogOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetTaskLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_DequeueNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsDequeueNextOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).DequeueNext(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Builds_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Builds",
	HandlerType: (*BuildsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Builds_Get_Handler,
		},
		{
			MethodName: "GetRepoBuild",
			Handler:    _Builds_GetRepoBuild_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Builds_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Builds_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Builds_Update_Handler,
		},
		{
			MethodName: "ListBuildTasks",
			Handler:    _Builds_ListBuildTasks_Handler,
		},
		{
			MethodName: "CreateTasks",
			Handler:    _Builds_CreateTasks_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Builds_UpdateTask_Handler,
		},
		{
			MethodName: "GetTaskLog",
			Handler:    _Builds_GetTaskLog_Handler,
		},
		{
			MethodName: "DequeueNext",
			Handler:    _Builds_DequeueNext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Orgs service

type OrgsClient interface {
	// Get fetches an organization.
	Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error)
	// List lists organizations that a user is a member of.
	List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error)
}

type orgsClient struct {
	cc *grpc.ClientConn
}

func NewOrgsClient(cc *grpc.ClientConn) OrgsClient {
	return &orgsClient{cc}
}

func (c *orgsClient) Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error) {
	out := new(Org)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error) {
	out := new(OrgList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/ListMembers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Orgs service

type OrgsServer interface {
	// Get fetches an organization.
	Get(context.Context, *OrgSpec) (*Org, error)
	// List lists organizations that a user is a member of.
	List(context.Context, *OrgsListOp) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(context.Context, *OrgsListMembersOp) (*UserList, error)
}

func RegisterOrgsServer(s *grpc.Server, srv OrgsServer) {
	s.RegisterService(&_Orgs_serviceDesc, srv)
}

func _Orgs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_ListMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListMembersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).ListMembers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Orgs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Orgs",
	HandlerType: (*OrgsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Orgs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Orgs_List_Handler,
		},
		{
			MethodName: "ListMembers",
			Handler:    _Orgs_ListMembers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for People service

type PeopleClient interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error)
}

type peopleClient struct {
	cc *grpc.ClientConn
}

func NewPeopleClient(cc *grpc.ClientConn) PeopleClient {
	return &peopleClient{cc}
}

func (c *peopleClient) Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error) {
	out := new(Person)
	err := grpc.Invoke(ctx, "/sourcegraph.People/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for People service

type PeopleServer interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(context.Context, *PersonSpec) (*Person, error)
}

func RegisterPeopleServer(s *grpc.Server, srv PeopleServer) {
	s.RegisterService(&_People_serviceDesc, srv)
}

func _People_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PeopleServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _People_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.People",
	HandlerType: (*PeopleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _People_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Accounts service

type AccountsClient interface {
	// Create creates a new user account.
	Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Invite creates a pending invite and notifies the recipient via email.
	Invite(ctx context.Context, in *AccountInvite, opts ...grpc.CallOption) (*PendingInvite, error)
	// AcceptInvite uses a pending invite to create a new user account.
	AcceptInvite(ctx context.Context, in *AcceptedInvite, opts ...grpc.CallOption) (*UserSpec, error)
	// ListInvites lists the pending invites on this server.
	ListInvites(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AccountInviteList, error)
	// DeleteInvite deletes an existing invite.
	DeleteInvite(ctx context.Context, in *InviteSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type accountsClient struct {
	cc *grpc.ClientConn
}

func NewAccountsClient(cc *grpc.ClientConn) AccountsClient {
	return &accountsClient{cc}
}

func (c *accountsClient) Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error) {
	out := new(PendingPasswordReset)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/RequestPasswordReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ResetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Invite(ctx context.Context, in *AccountInvite, opts ...grpc.CallOption) (*PendingInvite, error) {
	out := new(PendingInvite)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Invite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) AcceptInvite(ctx context.Context, in *AcceptedInvite, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/AcceptInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ListInvites(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AccountInviteList, error) {
	out := new(AccountInviteList)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ListInvites", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) DeleteInvite(ctx context.Context, in *InviteSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/DeleteInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Accounts service

type AccountsServer interface {
	// Create creates a new user account.
	Create(context.Context, *NewAccount) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(context.Context, *PersonSpec) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(context.Context, *NewPassword) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(context.Context, *User) (*pbtypes1.Void, error)
	// Invite creates a pending invite and notifies the recipient via email.
	Invite(context.Context, *AccountInvite) (*PendingInvite, error)
	// AcceptInvite uses a pending invite to create a new user account.
	AcceptInvite(context.Context, *AcceptedInvite) (*UserSpec, error)
	// ListInvites lists the pending invites on this server.
	ListInvites(context.Context, *pbtypes1.Void) (*AccountInviteList, error)
	// DeleteInvite deletes an existing invite.
	DeleteInvite(context.Context, *InviteSpec) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(context.Context, *PersonSpec) (*pbtypes1.Void, error)
}

func RegisterAccountsServer(s *grpc.Server, srv AccountsServer) {
	s.RegisterService(&_Accounts_serviceDesc, srv)
}

func _Accounts_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).RequestPasswordReset(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ResetPassword(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Invite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AccountInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Invite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_AcceptInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AcceptedInvite)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).AcceptInvite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ListInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ListInvites(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_DeleteInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InviteSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).DeleteInvite(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Accounts_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Accounts",
	HandlerType: (*AccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Accounts_Create_Handler,
		},
		{
			MethodName: "RequestPasswordReset",
			Handler:    _Accounts_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _Accounts_ResetPassword_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Accounts_Update_Handler,
		},
		{
			MethodName: "Invite",
			Handler:    _Accounts_Invite_Handler,
		},
		{
			MethodName: "AcceptInvite",
			Handler:    _Accounts_AcceptInvite_Handler,
		},
		{
			MethodName: "ListInvites",
			Handler:    _Accounts_ListInvites_Handler,
		},
		{
			MethodName: "DeleteInvite",
			Handler:    _Accounts_DeleteInvite_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Accounts_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Users service

type UsersClient interface {
	// Get fetches a user.
	Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error)
	// List users.
	List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/GetWithEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error) {
	out := new(EmailAddrList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/ListEmails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error) {
	out := new(UserCount)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Count", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Users service

type UsersServer interface {
	// Get fetches a user.
	Get(context.Context, *UserSpec) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(context.Context, *EmailAddr) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(context.Context, *UserSpec) (*EmailAddrList, error)
	// List users.
	List(context.Context, *UsersListOptions) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(context.Context, *pbtypes1.Void) (*UserCount, error)
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_GetWithEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EmailAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).GetWithEmail(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_ListEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).ListEmails(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UsersListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Count(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Users_Get_Handler,
		},
		{
			MethodName: "GetWithEmail",
			Handler:    _Users_GetWithEmail_Handler,
		},
		{
			MethodName: "ListEmails",
			Handler:    _Users_ListEmails_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Users_List_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Users_Count_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for UserKeys service

type UserKeysClient interface {
	// AddKey adds an SSH public key for the user, enabling them to use git over SSH.
	//
	// The ID field of SSHPublicKey will be ignored by this method.
	AddKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// LookupUser looks up a user based on the given public key.
	//
	// The ID and Name fields of SSHPublicKey will be ignored by this method.
	LookupUser(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*UserSpec, error)
	// DeleteKey deletes the user's SSH public key given an ID or name.
	DeleteKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// ListKeys lists the user's SSH public keys
	ListKeys(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*SSHKeyList, error)
	// DeleteAllKeys delets all of the user's SSH public keys
	DeleteAllKeys(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type userKeysClient struct {
	cc *grpc.ClientConn
}

func NewUserKeysClient(cc *grpc.ClientConn) UserKeysClient {
	return &userKeysClient{cc}
}

func (c *userKeysClient) AddKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/AddKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) LookupUser(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/LookupUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) DeleteKey(ctx context.Context, in *SSHPublicKey, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/DeleteKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) ListKeys(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*SSHKeyList, error) {
	out := new(SSHKeyList)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/ListKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeysClient) DeleteAllKeys(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.UserKeys/DeleteAllKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserKeys service

type UserKeysServer interface {
	// AddKey adds an SSH public key for the user, enabling them to use git over SSH.
	//
	// The ID field of SSHPublicKey will be ignored by this method.
	AddKey(context.Context, *SSHPublicKey) (*pbtypes1.Void, error)
	// LookupUser looks up a user based on the given public key.
	//
	// The ID and Name fields of SSHPublicKey will be ignored by this method.
	LookupUser(context.Context, *SSHPublicKey) (*UserSpec, error)
	// DeleteKey deletes the user's SSH public key given an ID or name.
	DeleteKey(context.Context, *SSHPublicKey) (*pbtypes1.Void, error)
	// ListKeys lists the user's SSH public keys
	ListKeys(context.Context, *pbtypes1.Void) (*SSHKeyList, error)
	// DeleteAllKeys delets all of the user's SSH public keys
	DeleteAllKeys(context.Context, *pbtypes1.Void) (*pbtypes1.Void, error)
}

func RegisterUserKeysServer(s *grpc.Server, srv UserKeysServer) {
	s.RegisterService(&_UserKeys_serviceDesc, srv)
}

func _UserKeys_AddKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SSHPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).AddKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_LookupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SSHPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).LookupUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SSHPublicKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).DeleteKey(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).ListKeys(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UserKeys_DeleteAllKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UserKeysServer).DeleteAllKeys(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UserKeys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.UserKeys",
	HandlerType: (*UserKeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddKey",
			Handler:    _UserKeys_AddKey_Handler,
		},
		{
			MethodName: "LookupUser",
			Handler:    _UserKeys_LookupUser_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _UserKeys_DeleteKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _UserKeys_ListKeys_Handler,
		},
		{
			MethodName: "DeleteAllKeys",
			Handler:    _UserKeys_DeleteAllKeys_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Auth service

type AuthClient interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error) {
	out := new(AuthorizationCode)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAuthorizationCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error) {
	out := new(AccessTokenResponse)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error) {
	out := new(AuthInfo)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/Identify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(context.Context, *AuthorizationCodeRequest) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(context.Context, *AccessTokenRequest) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(context.Context, *pbtypes1.Void) (*AuthInfo, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_GetAuthorizationCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AuthorizationCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAuthorizationCode(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAccessToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_Identify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).Identify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthorizationCode",
			Handler:    _Auth_GetAuthorizationCode_Handler,
		},
		{
			MethodName: "GetAccessToken",
			Handler:    _Auth_GetAccessToken_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Auth_Identify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Defs service

type DefsClient interface {
	// Get fetches a def.
	Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error)
	// List defs.
	List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error)
}

type defsClient struct {
	cc *grpc.ClientConn
}

func NewDefsClient(cc *grpc.ClientConn) DefsClient {
	return &defsClient{cc}
}

func (c *defsClient) Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error) {
	out := new(Def)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error) {
	out := new(RefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error) {
	out := new(ExampleList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListExamples", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error) {
	out := new(DefAuthorList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error) {
	out := new(DefClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Defs service

type DefsServer interface {
	// Get fetches a def.
	Get(context.Context, *DefsGetOp) (*Def, error)
	// List defs.
	List(context.Context, *DefListOptions) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(context.Context, *DefsListRefsOp) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(context.Context, *DefsListExamplesOp) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(context.Context, *DefsListAuthorsOp) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(context.Context, *DefsListClientsOp) (*DefClientList, error)
}

func RegisterDefsServer(s *grpc.Server, srv DefsServer) {
	s.RegisterService(&_Defs_serviceDesc, srv)
}

func _Defs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListExamplesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListExamples(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListClientsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Defs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Defs",
	HandlerType: (*DefsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Defs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Defs_List_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Defs_ListRefs_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Defs_ListExamples_Handler,
		},
		{
			MethodName: "ListAuthors",
			Handler:    _Defs_ListAuthors_Handler,
		},
		{
			MethodName: "ListClients",
			Handler:    _Defs_ListClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Deltas service

type DeltasClient interface {
	// Get fetches a summary of a delta.
	Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
}

type deltasClient struct {
	cc *grpc.ClientConn
}

func NewDeltasClient(cc *grpc.ClientConn) DeltasClient {
	return &deltasClient{cc}
}

func (c *deltasClient) Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error) {
	out := new(Delta)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error) {
	out := new(UnitDeltaList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListUnits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error) {
	out := new(DeltaDefs)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListDefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error) {
	out := new(DeltaFiles)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Deltas service

type DeltasServer interface {
	// Get fetches a summary of a delta.
	Get(context.Context, *DeltaSpec) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(context.Context, *DeltasListUnitsOp) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(context.Context, *DeltasListDefsOp) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(context.Context, *DeltasListFilesOp) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(context.Context, *DeltasListAffectedAuthorsOp) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(context.Context, *DeltasListAffectedClientsOp) (*DeltaAffectedPersonList, error)
}

func RegisterDeltasServer(s *grpc.Server, srv DeltasServer) {
	s.RegisterService(&_Deltas_serviceDesc, srv)
}

func _Deltas_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltaSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListUnitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListUnits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListDefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListDefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListDefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListFilesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListFiles(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListAffectedAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListAffectedClientsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Deltas_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Deltas",
	HandlerType: (*DeltasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Deltas_Get_Handler,
		},
		{
			MethodName: "ListUnits",
			Handler:    _Deltas_ListUnits_Handler,
		},
		{
			MethodName: "ListDefs",
			Handler:    _Deltas_ListDefs_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _Deltas_ListFiles_Handler,
		},
		{
			MethodName: "ListAffectedAuthors",
			Handler:    _Deltas_ListAffectedAuthors_Handler,
		},
		{
			MethodName: "ListAffectedClients",
			Handler:    _Deltas_ListAffectedClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Markdown service

type MarkdownClient interface {
	Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error)
}

type markdownClient struct {
	cc *grpc.ClientConn
}

func NewMarkdownClient(cc *grpc.ClientConn) MarkdownClient {
	return &markdownClient{cc}
}

func (c *markdownClient) Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error) {
	out := new(MarkdownData)
	err := grpc.Invoke(ctx, "/sourcegraph.Markdown/Render", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Markdown service

type MarkdownServer interface {
	Render(context.Context, *MarkdownRenderOp) (*MarkdownData, error)
}

func RegisterMarkdownServer(s *grpc.Server, srv MarkdownServer) {
	s.RegisterService(&_Markdown_serviceDesc, srv)
}

func _Markdown_Render_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MarkdownRenderOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MarkdownServer).Render(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Markdown_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Markdown",
	HandlerType: (*MarkdownServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Render",
			Handler:    _Markdown_Render_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoTree service

type RepoTreeClient interface {
	Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error)
	Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error)
}

type repoTreeClient struct {
	cc *grpc.ClientConn
}

func NewRepoTreeClient(cc *grpc.ClientConn) RepoTreeClient {
	return &repoTreeClient{cc}
}

func (c *repoTreeClient) Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error) {
	out := new(TreeEntry)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error) {
	out := new(RepoTreeListResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoTree service

type RepoTreeServer interface {
	Get(context.Context, *RepoTreeGetOp) (*TreeEntry, error)
	Search(context.Context, *RepoTreeSearchOp) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(context.Context, *RepoTreeListOp) (*RepoTreeListResult, error)
}

func RegisterRepoTreeServer(s *grpc.Server, srv RepoTreeServer) {
	s.RegisterService(&_RepoTree_serviceDesc, srv)
}

func _RepoTree_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeSearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoTree_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoTree",
	HandlerType: (*RepoTreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RepoTree_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _RepoTree_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RepoTree_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Search service

type SearchClient interface {
	// SearchTokens searches the index of tokens.
	SearchTokens(ctx context.Context, in *TokenSearchOptions, opts ...grpc.CallOption) (*DefList, error)
	// SearchText searches the content of files in the repo tree.
	SearchText(ctx context.Context, in *TextSearchOptions, opts ...grpc.CallOption) (*VCSSearchResultList, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) SearchTokens(ctx context.Context, in *TokenSearchOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/SearchTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) SearchText(ctx context.Context, in *TextSearchOptions, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/SearchText", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	// SearchTokens searches the index of tokens.
	SearchTokens(context.Context, *TokenSearchOptions) (*DefList, error)
	// SearchText searches the content of files in the repo tree.
	SearchText(context.Context, *TextSearchOptions) (*VCSSearchResultList, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_SearchTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TokenSearchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).SearchTokens(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_SearchText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TextSearchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).SearchText(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchTokens",
			Handler:    _Search_SearchTokens_Handler,
		},
		{
			MethodName: "SearchText",
			Handler:    _Search_SearchText_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Units service

type UnitsClient interface {
	// Get fetches a unit.
	Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error)
	// List units.
	List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error)
}

type unitsClient struct {
	cc *grpc.ClientConn
}

func NewUnitsClient(cc *grpc.ClientConn) UnitsClient {
	return &unitsClient{cc}
}

func (c *unitsClient) Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error) {
	out := new(unit.RepoSourceUnit)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitsClient) List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error) {
	out := new(RepoSourceUnitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Units service

type UnitsServer interface {
	// Get fetches a unit.
	Get(context.Context, *UnitSpec) (*unit.RepoSourceUnit, error)
	// List units.
	List(context.Context, *UnitListOptions) (*RepoSourceUnitList, error)
}

func RegisterUnitsServer(s *grpc.Server, srv UnitsServer) {
	s.RegisterService(&_Units_serviceDesc, srv)
}

func _Units_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Units_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Units_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Units",
	HandlerType: (*UnitsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Units_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Units_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Meta service

type MetaClient interface {
	// Status returns status information from the server's point of
	// view.
	Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error) {
	out := new(ServerStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error) {
	out := new(ServerConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Config", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	// Status returns status information from the server's point of
	// view.
	Status(context.Context, *pbtypes1.Void) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(context.Context, *pbtypes1.Void) (*ServerConfig, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Status(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Config(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Meta_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _Meta_Config_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RegisteredClients service

type RegisteredClientsClient interface {
	// Get retrieves an API client's record given its client ID.
	Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Create registers an API client.
	Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error)
	// Get the permissions of the user on the specified client.
	GetUserPermissions(ctx context.Context, in *UserPermissionsOptions, opts ...grpc.CallOption) (*UserPermissions, error)
	// Set the permissions of the user on the specified client.
	SetUserPermissions(ctx context.Context, in *UserPermissions, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// List the permissions of all users that are registered on this client.
	ListUserPermissions(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*UserPermissionsList, error)
}

type registeredClientsClient struct {
	cc *grpc.ClientConn
}

func NewRegisteredClientsClient(cc *grpc.ClientConn) RegisteredClientsClient {
	return &registeredClientsClient{cc}
}

func (c *registeredClientsClient) Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/GetCurrent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error) {
	out := new(RegisteredClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) GetUserPermissions(ctx context.Context, in *UserPermissionsOptions, opts ...grpc.CallOption) (*UserPermissions, error) {
	out := new(UserPermissions)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/GetUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) SetUserPermissions(ctx context.Context, in *UserPermissions, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/SetUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) ListUserPermissions(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*UserPermissionsList, error) {
	out := new(UserPermissionsList)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/ListUserPermissions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RegisteredClients service

type RegisteredClientsServer interface {
	// Get retrieves an API client's record given its client ID.
	Get(context.Context, *RegisteredClientSpec) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(context.Context, *pbtypes1.Void) (*RegisteredClient, error)
	// Create registers an API client.
	Create(context.Context, *RegisteredClient) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(context.Context, *RegisteredClient) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(context.Context, *RegisteredClientSpec) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(context.Context, *RegisteredClientListOptions) (*RegisteredClientList, error)
	// Get the permissions of the user on the specified client.
	GetUserPermissions(context.Context, *UserPermissionsOptions) (*UserPermissions, error)
	// Set the permissions of the user on the specified client.
	SetUserPermissions(context.Context, *UserPermissions) (*pbtypes1.Void, error)
	// List the permissions of all users that are registered on this client.
	ListUserPermissions(context.Context, *RegisteredClientSpec) (*UserPermissionsList, error)
}

func RegisterRegisteredClientsServer(s *grpc.Server, srv RegisteredClientsServer) {
	s.RegisterService(&_RegisteredClients_serviceDesc, srv)
}

func _RegisteredClients_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_GetCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).GetCurrent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_GetUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserPermissionsOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).GetUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_SetUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).SetUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_ListUserPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).ListUserPermissions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RegisteredClients_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RegisteredClients",
	HandlerType: (*RegisteredClientsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RegisteredClients_Get_Handler,
		},
		{
			MethodName: "GetCurrent",
			Handler:    _RegisteredClients_GetCurrent_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RegisteredClients_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegisteredClients_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegisteredClients_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegisteredClients_List_Handler,
		},
		{
			MethodName: "GetUserPermissions",
			Handler:    _RegisteredClients_GetUserPermissions_Handler,
		},
		{
			MethodName: "SetUserPermissions",
			Handler:    _RegisteredClients_SetUserPermissions_Handler,
		},
		{
			MethodName: "ListUserPermissions",
			Handler:    _RegisteredClients_ListUserPermissions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for GraphUplink service

type GraphUplinkClient interface {
	// Push sends the latest metrics to the upstream instance
	Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// PushEvents flushes the local event logs to the upstream
	// instance
	PushEvents(ctx context.Context, in *UserEventList, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type graphUplinkClient struct {
	cc *grpc.ClientConn
}

func NewGraphUplinkClient(cc *grpc.ClientConn) GraphUplinkClient {
	return &graphUplinkClient{cc}
}

func (c *graphUplinkClient) Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.GraphUplink/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *graphUplinkClient) PushEvents(ctx context.Context, in *UserEventList, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.GraphUplink/PushEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GraphUplink service

type GraphUplinkServer interface {
	// Push sends the latest metrics to the upstream instance
	Push(context.Context, *MetricsSnapshot) (*pbtypes1.Void, error)
	// PushEvents flushes the local event logs to the upstream
	// instance
	PushEvents(context.Context, *UserEventList) (*pbtypes1.Void, error)
}

func RegisterGraphUplinkServer(s *grpc.Server, srv GraphUplinkServer) {
	s.RegisterService(&_GraphUplink_serviceDesc, srv)
}

func _GraphUplink_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MetricsSnapshot)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GraphUplinkServer).Push(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _GraphUplink_PushEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserEventList)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GraphUplinkServer).PushEvents(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _GraphUplink_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.GraphUplink",
	HandlerType: (*GraphUplinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _GraphUplink_Push_Handler,
		},
		{
			MethodName: "PushEvents",
			Handler:    _GraphUplink_PushEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Notify service

type NotifyClient interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type notifyClient struct {
	cc *grpc.ClientConn
}

func NewNotifyClient(cc *grpc.ClientConn) NotifyClient {
	return &notifyClient{cc}
}

func (c *notifyClient) GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Notify/GenericEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Notify service

type NotifyServer interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(context.Context, *NotifyGenericEvent) (*pbtypes1.Void, error)
}

func RegisterNotifyServer(s *grpc.Server, srv NotifyServer) {
	s.RegisterService(&_Notify_serviceDesc, srv)
}

func _Notify_GenericEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NotifyGenericEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotifyServer).GenericEvent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Notify_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Notify",
	HandlerType: (*NotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenericEvent",
			Handler:    _Notify_GenericEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *Badge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Badge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.ImageURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ImageURL)))
		i += copy(data[i:], m.ImageURL)
	}
	if len(m.UncountedImageURL) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UncountedImageURL)))
		i += copy(data[i:], m.UncountedImageURL)
	}
	if len(m.Markdown) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Markdown)))
		i += copy(data[i:], m.Markdown)
	}
	return i, nil
}

func (m *CombinedStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CombinedStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.Statuses) > 0 {
		for _, msg := range m.Statuses {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rev) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *Counter) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Counter) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.ImageURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ImageURL)))
		i += copy(data[i:], m.ImageURL)
	}
	if len(m.UncountedImageURL) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UncountedImageURL)))
		i += copy(data[i:], m.UncountedImageURL)
	}
	if len(m.Markdown) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Markdown)))
		i += copy(data[i:], m.Markdown)
	}
	return i, nil
}

func (m *ListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerPage != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PerPage))
	}
	if m.Page != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Total))
	}
	return i, nil
}

func (m *StreamResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		data[i] = 0x8
		i++
		if m.HasMore {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Changeset) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Changeset) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.Title) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Title)))
		i += copy(data[i:], m.Title)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Author.Size()))
	n1, err := m.Author.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.DeltaSpec != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.DeltaSpec.Size()))
		n2, err := m.DeltaSpec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Merged {
		data[i] = 0x30
		i++
		if m.Merged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n3, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ClosedAt != nil {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ClosedAt.Size()))
		n4, err := m.ClosedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ChangesetReview) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetReview) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.Body) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Author.Size()))
	n5, err := m.Author.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.CreatedAt != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n6, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.EditedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EditedAt.Size()))
		n7, err := m.EditedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Comments) > 0 {
		for _, msg := range m.Comments {
			data[i] = 0x32
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Deleted {
		data[i] = 0x38
		i++
		if m.Deleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChangesetEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Before.Size()))
		n8, err := m.Before.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.After != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.After.Size()))
		n9, err := m.After.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Op != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Op.Size()))
		n10, err := m.Op.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.CreatedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n11, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *InlineComment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InlineComment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filename) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Filename)))
		i += copy(data[i:], m.Filename)
	}
	if m.LineNumber != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.LineNumber))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Author.Size()))
	n12, err := m.Author.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Body) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Body)))
		i += copy(data[i:], m.Body)
	}
	if m.CreatedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n13, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.EditedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EditedAt.Size()))
		n14, err := m.EditedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Deleted {
		data[i] = 0x40
		i++
		if m.Deleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Readme) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Readme) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.HTML) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTML)))
		i += copy(data[i:], m.HTML)
	}
	return i, nil
}

func (m *GitHubRepo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitHubRepo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stars != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Stars))
	}
	return i, nil
}

func (m *RepoConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Repo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Repo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.VCS) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.VCS)))
		i += copy(data[i:], m.VCS)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.SSHCloneURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SSHCloneURL)))
		i += copy(data[i:], m.SSHCloneURL)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Language) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.Blocked {
		data[i] = 0x50
		i++
		if m.Blocked {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Deprecated {
		data[i] = 0x58
		i++
		if m.Deprecated {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fork {
		data[i] = 0x60
		i++
		if m.Fork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Mirror {
		data[i] = 0x68
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Private {
		data[i] = 0x70
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n15, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UpdatedAt != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
		n16, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.PushedAt != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PushedAt.Size()))
		n17, err := m.PushedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Permissions != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Permissions.Size()))
		n18, err := m.Permissions.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.GitHub != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.GitHub.Size()))
		n19, err := m.GitHub.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Origin) > 0 {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Origin)))
		i += copy(data[i:], m.Origin)
	}
	if len(m.HTMLURL) > 0 {
		data[i] = 0xb2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTMLURL)))
		i += copy(data[i:], m.HTMLURL)
	}
	return i, nil
}

func (m *BadgeList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BadgeList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Badges) > 0 {
		for _, msg := range m.Badges {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CounterList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CounterList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Counters) > 0 {
		for _, msg := range m.Counters {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RepoBadgesCountHitsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoBadgesCountHitsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n20, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.Since != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Since.Size()))
		n21, err := m.Since.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *RepoBadgesCountHitsResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoBadgesCountHitsResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hits != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Hits))
	}
	return i, nil
}

func (m *RepoListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Sort) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	if m.NoFork {
		data[i] = 0x38
		i++
		if m.NoFork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n22, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	return i, nil
}

func (m *RepoPermissions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoPermissions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Read {
		data[i] = 0x8
		i++
		if m.Read {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Write {
		data[i] = 0x10
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x18
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoRevSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoRevSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoSpec.Size()))
	n23, err := m.RepoSpec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if len(m.Rev) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *RepoSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	return i, nil
}

func (m *RepoStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.TargetURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TargetURL)))
		i += copy(data[i:], m.TargetURL)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Context) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	data[i] = 0x32
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n24, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	data[i] = 0x3a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
	n25, err := m.UpdatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	return i, nil
}

func (m *RepoStatusesCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatusesCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n26, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Status.Size()))
	n27, err := m.Status.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	return i, nil
}

func (m *RepoList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, msg := range m.Repos {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SrclibDataVersion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SrclibDataVersion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if m.CommitsBehind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CommitsBehind))
	}
	return i, nil
}

func (m *RepoConfigureAppOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoConfigureAppOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n28, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	if len(m.App) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.App)))
		i += copy(data[i:], m.App)
	}
	if m.Enable {
		data[i] = 0x18
		i++
		if m.Enable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StorageBucket) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StorageBucket) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppName)))
		i += copy(data[i:], m.AppName)
	}
	if len(m.Repo) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *StorageKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StorageKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Bucket.Size()))
		n29, err := m.Bucket.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.Key) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	return i, nil
}

func (m *StorageValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StorageValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	return i, nil
}

func (m *StoragePutOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoragePutOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Key.Size()))
	n30, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	if m.Value != nil {
		if len(m.Value) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Value)))
			i += copy(data[i:], m.Value)
		}
	}
	return i, nil
}

func (m *StorageExists) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StorageExists) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exists {
		data[i] = 0x8
		i++
		if m.Exists {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StorageList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StorageList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *ReposCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.VCS) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.VCS)))
		i += copy(data[i:], m.VCS)
	}
	if len(m.CloneURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CloneURL)))
		i += copy(data[i:], m.CloneURL)
	}
	if m.Mirror {
		data[i] = 0x20
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Private {
		data[i] = 0x28
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Description) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	return i, nil
}

func (m *ReposUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n31, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	return i, nil
}

func (m *ReposListCommitsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommitsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n32, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n33, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *RepoListCommitsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommitsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Head)))
		i += copy(data[i:], m.Head)
	}
	if len(m.Base) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Base)))
		i += copy(data[i:], m.Base)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n34, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	if len(m.Path) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.RefreshCache {
		data[i] = 0x28
		i++
		if m.RefreshCache {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommitList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n35, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	return i, nil
}

func (m *ReposListBranchesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListBranchesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n36, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n37, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *RepoListBranchesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListBranchesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n38, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n38
	if m.IncludeCommit {
		data[i] = 0x20
		i++
		if m.IncludeCommit {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.BehindAheadBranch) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BehindAheadBranch)))
		i += copy(data[i:], m.BehindAheadBranch)
	}
	if len(m.ContainsCommit) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContainsCommit)))
		i += copy(data[i:], m.ContainsCommit)
	}
	return i, nil
}

func (m *BranchList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BranchList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, msg := range m.Branches {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n39, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n39
	return i, nil
}

func (m *ReposListTagsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListTagsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n40, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n41, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *ReposListCommittersOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommittersOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n42, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n42
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n43, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *RepoListCommittersOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommittersOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rev) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n44, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n44
	return i, nil
}

func (m *CommitterList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitterList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, msg := range m.Committers {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n45, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n45
	return i, nil
}

func (m *ChangesetCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n46, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n46
	if m.Changeset != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Changeset.Size()))
		n47, err := m.Changeset.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *ChangesetCreateReviewOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetCreateReviewOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n48, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n48
	if m.ChangesetID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ChangesetID))
	}
	if m.Review != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Review.Size()))
		n49, err := m.Review.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}

func (m *ChangesetListReviewsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetListReviewsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n50, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n50
	if m.ChangesetID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ChangesetID))
	}
	return i, nil
}

func (m *ChangesetSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n51, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n51
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *ChangesetUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n52, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n52
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.Title) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Title)))
		i += copy(data[i:], m.Title)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.Open {
		data[i] = 0x28
		i++
		if m.Open {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Close {
		data[i] = 0x30
		i++
		if m.Close {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Merged {
		data[i] = 0x38
		i++
		if m.Merged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x42
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Author.Size()))
	n53, err := m.Author.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n53
	return i, nil
}

func (m *ChangesetMergeOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetMergeOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n54, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n54
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.Message) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.Squash {
		data[i] = 0x20
		i++
		if m.Squash {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChangesetUpdateAffectedOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetUpdateAffectedOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n55, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n55
	if len(m.Branch) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Last) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Last)))
		i += copy(data[i:], m.Last)
	}
	if len(m.Commit) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Commit)))
		i += copy(data[i:], m.Commit)
	}
	if m.ForcePush {
		data[i] = 0x28
		i++
		if m.ForcePush {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoListTagsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListTagsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n56, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n56
	return i, nil
}

func (m *TagList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TagList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n57, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n57
	return i, nil
}

func (m *MirrorReposRefreshVCSOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MirrorReposRefreshVCSOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n58, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n58
	return i, nil
}

func (m *VCSCredentials) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VCSCredentials) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pass) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Pass)))
		i += copy(data[i:], m.Pass)
	}
	return i, nil
}

func (m *MirroredRepoSSHKeysCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MirroredRepoSSHKeysCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n59, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n59
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Key.Size()))
	n60, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n60
	return i, nil
}

func (m *SSHPrivateKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SSHPrivateKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PEM != nil {
		if len(m.PEM) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.PEM)))
			i += copy(data[i:], m.PEM)
		}
	}
	return i, nil
}

func (m *Build) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Build) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n61, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n61
	if m.StartedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n62, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.EndedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n63, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.HeartbeatAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeartbeatAt.Size()))
		n64, err := m.HeartbeatAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Success {
		data[i] = 0x40
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x48
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Killed {
		data[i] = 0x50
		i++
		if m.Killed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Host) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if m.Purged {
		data[i] = 0x60
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x6a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.BuildConfig.Size()))
	n65, err := m.BuildConfig.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n65
	if len(m.Branch) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Tag) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	return i, nil
}

func (m *BuildConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Queue {
		data[i] = 0x10
		i++
		if m.Queue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Priority))
	}
	if len(m.BuilderConfig) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BuilderConfig)))
		i += copy(data[i:], m.BuilderConfig)
	}
	return i, nil
}

func (m *BuildGetLogOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildGetLogOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MinID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.MinID)))
		i += copy(data[i:], m.MinID)
	}
	return i, nil
}

func (m *BuildListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Queued {
		data[i] = 0x8
		i++
		if m.Queued {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Active {
		data[i] = 0x10
		i++
		if m.Active {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ended {
		data[i] = 0x18
		i++
		if m.Ended {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Succeeded {
		data[i] = 0x20
		i++
		if m.Succeeded {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failed {
		data[i] = 0x28
		i++
		if m.Failed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Purged {
		data[i] = 0x30
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Repo) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Sort) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n66, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n66
	return i, nil
}

func (m *ChangesetListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if m.Open {
		data[i] = 0x10
		i++
		if m.Open {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Closed {
		data[i] = 0x18
		i++
		if m.Closed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Head) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Head)))
		i += copy(data[i:], m.Head)
	}
	if len(m.Base) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Base)))
		i += copy(data[i:], m.Base)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n67, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n67
	return i, nil
}

func (m *BuildSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n68, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n68
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *BuildTask) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTask) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n69, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n69
	if m.ParentID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ParentID))
	}
	if len(m.Label) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n70, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n70
	if m.StartedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n71, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.EndedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n72, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Success {
		data[i] = 0x40
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x48
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Skipped {
		data[i] = 0x50
		i++
		if m.Skipped {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Warnings {
		data[i] = 0x58
		i++
		if m.Warnings {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BuildTaskListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTaskListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n73, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n73
	return i, nil
}

func (m *BuildUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartedAt != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n74, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.EndedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n75, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.HeartbeatAt != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeartbeatAt.Size()))
		n76, err := m.HeartbeatAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.Host) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if m.Success {
		data[i] = 0x28
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Purged {
		data[i] = 0x30
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x38
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Killed {
		data[i] = 0x40
		i++
		if m.Killed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Priority))
	}
	if len(m.BuilderConfig) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BuilderConfig)))
		i += copy(data[i:], m.BuilderConfig)
	}
	return i, nil
}

func (m *BuildList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Builds) > 0 {
		for _, msg := range m.Builds {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n77, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n77
	return i, nil
}

func (m *BuildsCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n78, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n78
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Branch) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Tag) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Config.Size()))
	n79, err := m.Config.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n79
	return i, nil
}

func (m *BuildsUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n80, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n80
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Info.Size()))
	n81, err := m.Info.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n81
	return i, nil
}

func (m *BuildsListBuildTasksOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsListBuildTasksOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n82, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n82
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n83, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *BuildTaskList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTaskList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildTasks) > 0 {
		for _, msg := range m.BuildTasks {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChangesetReviewList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetReviewList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reviews) > 0 {
		for _, msg := range m.Reviews {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChangesetList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changesets) > 0 {
		for _, msg := range m.Changesets {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ChangesetEventList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangesetEventList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildsCreateTasksOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsCreateTasksOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n84, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n84
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildsUpdateTaskOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsUpdateTaskOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Task.Size()))
	n85, err := m.Task.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n85
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Info.Size()))
	n86, err := m.Info.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n86
	return i, nil
}

func (m *BuildsGetTaskLogOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsGetTaskLogOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Task.Size()))
	n87, err := m.Task.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n87
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n88, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}

func (m *BuildsDequeueNextOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsDequeueNextOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EmailAddr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Verified {
		data[i] = 0x10
		i++
		if m.Verified {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Primary {
		data[i] = 0x18
		i++
		if m.Primary {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Guessed {
		data[i] = 0x20
		i++
		if m.Guessed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Blacklisted {
		data[i] = 0x28
		i++
		if m.Blacklisted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogEntries) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LogEntries) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MaxID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.MaxID)))
		i += copy(data[i:], m.MaxID)
	}
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Org) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Org) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.User.Size()))
	n89, err := m.User.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n89
	return i, nil
}

func (m *OrgListMembersOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgListMembersOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n90, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n90
	return i, nil
}

func (m *OrgSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Org) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Org)))
		i += copy(data[i:], m.Org)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *OrgsListMembersOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgsListMembersOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Org.Size()))
	n91, err := m.Org.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n91
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n92, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	return i, nil
}

func (m *UserList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserCount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserCount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *Person) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Person) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.PersonSpec.Size()))
	n93, err := m.PersonSpec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n93
	if len(m.FullName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FullName)))
		i += copy(data[i:], m.FullName)
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	return i, nil
}

func (m *PersonSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersonSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.UID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *TaskSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n94, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n94
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *TaskUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartedAt != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n95, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if m.EndedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n96, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.Success {
		data[i] = 0x18
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x20
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Skipped {
		data[i] = 0x28
		i++
		if m.Skipped {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Warnings {
		data[i] = 0x30
		i++
		if m.Warnings {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Domain) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Domain)))
		i += copy(data[i:], m.Domain)
	}
	if len(m.Name) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.IsOrganization {
		data[i] = 0x28
		i++
		if m.IsOrganization {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	if len(m.Location) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Location)))
		i += copy(data[i:], m.Location)
	}
	if len(m.Company) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Company)))
		i += copy(data[i:], m.Company)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if m.Disabled {
		data[i] = 0x50
		i++
		if m.Disabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RegisteredAt != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RegisteredAt.Size()))
		n97, err := m.RegisteredAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if m.Admin {
		data[i] = 0x60
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Write {
		data[i] = 0x68
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Domain) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Domain)))
		i += copy(data[i:], m.Domain)
	}
	return i, nil
}

func (m *UsersListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UsersListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.Sort) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n98, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n98
	return i, nil
}

func (m *OrgsListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgsListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Member.Size()))
	n99, err := m.Member.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n99
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n100, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n100
	return i, nil
}

func (m *EmailAddrList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddrList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, msg := range m.EmailAddrs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OrgList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Orgs) > 0 {
		for _, msg := range m.Orgs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PasswordResetToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PasswordResetToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	return i, nil
}

func (m *PendingPasswordReset) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PendingPasswordReset) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Link)))
		i += copy(data[i:], m.Link)
	}
	if m.Token != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Token.Size()))
		n101, err := m.Token.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if m.EmailSent {
		data[i] = 0x18
		i++
		if m.EmailSent {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Login) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	return i, nil
}

func (m *NewPassword) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewPassword) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if m.Token != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Token.Size()))
		n102, err := m.Token.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n102
	}
	return i, nil
}

func (m *NewAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.Password) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if m.UID != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *AccountInvite) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccountInvite) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Write {
		data[i] = 0x10
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x18
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InviteSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InviteSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	return i, nil
}

func (m *PendingInvite) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PendingInvite) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Link)))
		i += copy(data[i:], m.Link)
	}
	if len(m.Token) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	if m.EmailSent {
		data[i] = 0x18
		i++
		if m.EmailSent {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AccountInviteList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccountInviteList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Invites) > 0 {
		for _, msg := range m.Invites {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AcceptedInvite) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptedInvite) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Account.Size()))
		n103, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if len(m.Token) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	return i, nil
}

func (m *SSHKeyList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SSHKeyList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SSHKeys) > 0 {
		for _, msg := range m.SSHKeys {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SSHPublicKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SSHPublicKey) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		if len(m.Key) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Key)))
			i += copy(data[i:], m.Key)
		}
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.ID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *AuthorizationCodeRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorizationCodeRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResponseType) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ResponseType)))
		i += copy(data[i:], m.ResponseType)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if len(m.RedirectURI) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.RedirectURI)))
		i += copy(data[i:], m.RedirectURI)
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.UID != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *AuthorizationCode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorizationCode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Code)))
		i += copy(data[i:], m.Code)
	}
	if len(m.RedirectURI) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.RedirectURI)))
		i += copy(data[i:], m.RedirectURI)
	}
	return i, nil
}

func (m *LoginCredentials) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LoginCredentials) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Password) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	return i, nil
}

func (m *BearerJWT) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BearerJWT) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Assertion) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Assertion)))
		i += copy(data[i:], m.Assertion)
	}
	return i, nil
}

func (m *AccessTokenRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccessTokenRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthorizationGrant != nil {
		nn104, err := m.AuthorizationGrant.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn104
	}
	if len(m.TokenURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TokenURL)))
		i += copy(data[i:], m.TokenURL)
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			data[i] = 0x8a
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *AccessTokenRequest_AuthorizationCode) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.AuthorizationCode != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.AuthorizationCode.Size()))
		n105, err := m.AuthorizationCode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	return i, nil
}
func (m *AccessTokenRequest_ResourceOwnerPassword) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ResourceOwnerPassword != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ResourceOwnerPassword.Size()))
		n106, err := m.ResourceOwnerPassword.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	return i, nil
}
func (m *AccessTokenRequest_BearerJWT) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.BearerJWT != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BearerJWT.Size()))
		n107, err := m.BearerJWT.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	return i, nil
}
func (m *AccessTokenResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccessTokenResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AccessToken)))
		i += copy(data[i:], m.AccessToken)
	}
	if len(m.TokenType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TokenType)))
		i += copy(data[i:], m.TokenType)
	}
	if m.ExpiresInSec != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ExpiresInSec))
	}
	if len(m.RefreshToken) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.RefreshToken)))
		i += copy(data[i:], m.RefreshToken)
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *AuthInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Domain) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Domain)))
		i += copy(data[i:], m.Domain)
	}
	if len(m.Login) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.Write {
		data[i] = 0x28
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x30
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *AuthorshipInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorshipInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AuthorEmail) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AuthorEmail)))
		i += copy(data[i:], m.AuthorEmail)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.LastCommitDate.Size()))
	n108, err := m.LastCommitDate.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n108
	if len(m.LastCommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LastCommitID)))
		i += copy(data[i:], m.LastCommitID)
	}
	return i, nil
}

func (m *Def) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Def) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n109, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n109
	if m.DocHTML != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.DocHTML.Size()))
		n110, err := m.DocHTML.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.FmtStrings != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FmtStrings.Size()))
		n111, err := m.FmtStrings.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	return i, nil
}

func (m *DefAuthor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DefAuthorship.Size()))
	n112, err := m.DefAuthorship.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n112
	return i, nil
}

func (m *DefAuthorship) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorship) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.AuthorshipInfo.Size()))
	n113, err := m.AuthorshipInfo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n113
	if m.Exported {
		data[i] = 0x10
		i++
		if m.Exported {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Bytes != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Sourcegraph(data, i, uint64(math.Float64bits(m.BytesProportion)))
	}
	return i, nil
}

func (m *DefClient) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefClient) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.AuthorshipInfo.Size()))
	n114, err := m.AuthorshipInfo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n114
	if m.UseCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UseCount))
	}
	return i, nil
}

func (m *DefDelta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefDelta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
		n115, err := m.Base.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.Head != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
		n116, err := m.Head.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	return i, nil
}

func (m *DefGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Doc {
		data[i] = 0x8
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DefListAuthorsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListAuthorsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n117, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n117
	return i, nil
}

func (m *DefListClientsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListClientsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n118, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n118
	return i, nil
}

func (m *DefListExamplesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListExamplesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Formatted {
		data[i] = 0x8
		i++
		if m.Formatted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Repo) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if m.TokenizedSource {
		data[i] = 0x18
		i++
		if m.TokenizedSource {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n119, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n119
	return i, nil
}

func (m *DefListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.ByteStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, msg := range m.DefKeys {
			data[i] = 0x2a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.FilePathPrefix) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FilePathPrefix)))
		i += copy(data[i:], m.FilePathPrefix)
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Exported {
		data[i] = 0x68
		i++
		if m.Exported {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Nonlocal {
		data[i] = 0x70
		i++
		if m.Nonlocal {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IncludeTest {
		data[i] = 0x78
		i++
		if m.IncludeTest {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Doc {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fuzzy {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		if m.Fuzzy {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Sort) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0xa2
	i++
	data[i] = 0x1
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n120, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n120
	return i, nil
}

func (m *DefListRefsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListRefsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Authorship {
		data[i] = 0x8
		i++
		if m.Authorship {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Repo) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n121, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n121
	return i, nil
}

func (m *DefSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *DefsGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n122, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n122
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n123, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	return i, nil
}

func (m *DefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n124, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n124
	return i, nil
}

func (m *DefsListRefsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListRefsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n125, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n125
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n126, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	return i, nil
}

func (m *RefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, msg := range m.Refs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n127, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n127
	return i, nil
}

func (m *DefsListExamplesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListExamplesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n128, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n128
	if len(m.Rev) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	if m.Opt != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n129, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	return i, nil
}

func (m *ExampleList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExampleList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, msg := range m.Examples {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n130, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n130
	return i, nil
}

func (m *DefsListAuthorsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListAuthorsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n131, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n131
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n132, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	return i, nil
}

func (m *DefsListClientsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListClientsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n133, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n133
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n134, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	return i, nil
}

func (m *Delta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Delta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
	n135, err := m.Base.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n135
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
	n136, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n136
	if m.BaseCommit != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BaseCommit.Size()))
		n137, err := m.BaseCommit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	if m.HeadCommit != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeadCommit.Size()))
		n138, err := m.HeadCommit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	if m.BaseRepo != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BaseRepo.Size()))
		n139, err := m.BaseRepo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	if m.HeadRepo != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeadRepo.Size()))
		n140, err := m.HeadRepo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	return i, nil
}

func (m *DeltaAffectedPerson) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaAffectedPerson) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Person.Size()))
	n141, err := m.Person.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n141
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeltaDefs) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaDefs) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DiffStat.Size()))
	n142, err := m.DiffStat.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n142
	return i, nil
}

func (m *FileDiff) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileDiff) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FileDiff.Size()))
	n143, err := m.FileDiff.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n143
	if len(m.FileDiffHunks) > 0 {
		for _, msg := range m.FileDiffHunks {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreImage) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.PreImage)))
		i += copy(data[i:], m.PreImage)
	}
	if len(m.PostImage) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.PostImage)))
		i += copy(data[i:], m.PostImage)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Stats.Size()))
	n144, err := m.Stats.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n144
	return i, nil
}

func (m *Hunk) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Hunk) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Hunk.Size()))
	n145, err := m.Hunk.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n145
	if len(m.LinePrefixes) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LinePrefixes)))
		i += copy(data[i:], m.LinePrefixes)
	}
	if m.BaseSource != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BaseSource.Size()))
		n146, err := m.BaseSource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n146
	}
	if m.HeadSource != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeadSource.Size()))
		n147, err := m.HeadSource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n147
	}
	if m.BodySource != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BodySource.Size()))
		n148, err := m.BodySource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n148
	}
	return i, nil
}

func (m *DeltaFiles) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaFiles) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileDiffs) > 0 {
		for _, msg := range m.FileDiffs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Delta != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Delta.Size()))
		n149, err := m.Delta.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n149
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Stats.Size()))
	n150, err := m.Stats.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n150
	if m.OverThreshold {
		data[i] = 0x20
		i++
		if m.OverThreshold {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeltaFilter) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaFilter) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Unit) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	return i, nil
}

func (m *DeltaListAffectedAuthorsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListAffectedAuthorsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DeltaFilter.Size()))
	n151, err := m.DeltaFilter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n151
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n152, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n152
	return i, nil
}

func (m *DeltaListAffectedClientsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListAffectedClientsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DeltaFilter.Size()))
	n153, err := m.DeltaFilter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n153
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n154, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n154
	return i, nil
}

func (m *DeltaListDefsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListDefsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DeltaFilter.Size()))
	n155, err := m.DeltaFilter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n155
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n156, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n156
	return i, nil
}

func (m *DeltaListFilesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListFilesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Formatted {
		data[i] = 0x8
		i++
		if m.Formatted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Filter) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Filter)))
		i += copy(data[i:], m.Filter)
	}
	if m.Tokenized {
		data[i] = 0x18
		i++
		if m.Tokenized {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.MaxSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.MaxSize))
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DeltaFilter.Size()))
	n157, err := m.DeltaFilter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n157
	return i, nil
}

func (m *DeltaListUnitsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListUnitsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeltaSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
	n158, err := m.Base.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n158
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
	n159, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n159
	return i, nil
}

func (m *DeltasListUnitsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListUnitsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n160, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n160
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n161, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n161
	}
	return i, nil
}

func (m *UnitDeltaList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnitDeltaList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UnitDeltas) > 0 {
		for _, msg := range m.UnitDeltas {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeltasListDefsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListDefsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n162, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n162
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n163, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n163
	}
	return i, nil
}

func (m *DeltasListFilesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListFilesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n164, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n164
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n165, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n165
	}
	return i, nil
}

func (m *DeltasListAffectedAuthorsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListAffectedAuthorsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n166, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n166
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n167, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n167
	}
	return i, nil
}

func (m *DeltaAffectedPersonList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaAffectedPersonList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeltaAffectedPersons) > 0 {
		for _, msg := range m.DeltaAffectedPersons {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeltasListAffectedClientsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListAffectedClientsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n168, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n168
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n169, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n169
	}
	return i, nil
}

func (m *Example) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Example) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ref.Size()))
	n170, err := m.Ref.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n170
	if len(m.SrcHTML) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SrcHTML)))
		i += copy(data[i:], m.SrcHTML)
	}
	if m.SourceCode != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.SourceCode.Size()))
		n171, err := m.SourceCode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n171
	}
	if m.StartLine != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndLine))
	}
	if m.Error {
		data[i] = 0x30
		i++
		if m.Error {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Rev) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *FormatResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FormatResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TooManyRefs {
		data[i] = 0x8
		i++
		if m.TooManyRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NumRefs != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.NumRefs))
	}
	if len(m.LineStartByteOffsets) > 0 {
		for _, num := range m.LineStartByteOffsets {
			data[i] = 0x18
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *MarkdownData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MarkdownData) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rendered != nil {
		if len(m.Rendered) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Rendered)))
			i += copy(data[i:], m.Rendered)
		}
	}
	if m.Checklist != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Checklist.Size()))
		n172, err := m.Checklist.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n172
	}
	return i, nil
}

func (m *MarkdownOpt) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MarkdownOpt) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnableCheckboxes {
		data[i] = 0x8
		i++
		if m.EnableCheckboxes {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MarkdownRequestBody) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MarkdownRequestBody) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Markdown != nil {
		if len(m.Markdown) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Markdown)))
			i += copy(data[i:], m.Markdown)
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.MarkdownOpt.Size()))
	n173, err := m.MarkdownOpt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n173
	return i, nil
}

func (m *MarkdownRenderOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MarkdownRenderOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Markdown != nil {
		if len(m.Markdown) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.Markdown)))
			i += copy(data[i:], m.Markdown)
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
	n174, err := m.Opt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n174
	return i, nil
}

func (m *Ref) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ref) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ref.Size()))
	n175, err := m.Ref.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n175
	if m.Authorship != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Authorship.Size()))
		n176, err := m.Authorship.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n176
	}
	return i, nil
}

func (m *RepoTreeGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Formatted {
		data[i] = 0x8
		i++
		if m.Formatted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.HighlightStrings) > 0 {
		for _, s := range m.HighlightStrings {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.TokenizedSource {
		data[i] = 0x18
		i++
		if m.TokenizedSource {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ContentsAsString {
		data[i] = 0x20
		i++
		if m.ContentsAsString {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.GetFileOptions.Size()))
	n177, err := m.GetFileOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n177
	return i, nil
}

func (m *RepoTreeSearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchOptions.Size()))
	n178, err := m.SearchOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n178
	if m.Formatted {
		data[i] = 0x10
		i++
		if m.Formatted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoTreeSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchResult.Size()))
	n179, err := m.SearchResult.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n179
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n180, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n180
	return i, nil
}

func (m *RepoTreeGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n181, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n181
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n182, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n182
	}
	return i, nil
}

func (m *RepoTreeSearchOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n183, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n183
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n184, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n184
	}
	return i, nil
}

func (m *RepoTreeListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n185, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n185
	return i, nil
}

func (m *RepoTreeListResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VCSSearchResultList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VCSSearchResultList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, msg := range m.SearchResults {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n186, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n186
	return i, nil
}

func (m *TokenSearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TokenSearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n187, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n187
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n188, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n188
	return i, nil
}

func (m *TextSearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TextSearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n189, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n189
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n190, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n190
	return i, nil
}

func (m *SourceCode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceCode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Lines) > 0 {
		for _, msg := range m.Lines {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumRefs != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.NumRefs))
	}
	if m.TooManyRefs {
		data[i] = 0x18
		i++
		if m.TooManyRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SourceCodeLine) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceCodeLine) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartByte != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	if len(m.Tokens) > 0 {
		for _, msg := range m.Tokens {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SourceCodeToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceCodeToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartByte != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	if len(m.URL) > 0 {
		for _, s := range m.URL {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.IsDef {
		data[i] = 0x20
		i++
		if m.IsDef {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Class) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Class)))
		i += copy(data[i:], m.Class)
	}
	if len(m.ExtraClasses) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ExtraClasses)))
		i += copy(data[i:], m.ExtraClasses)
	}
	if len(m.Label) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *TreeEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreeEntry != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.TreeEntry.Size()))
		n191, err := m.TreeEntry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n191
	}
	if m.FileRange != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FileRange.Size()))
		n192, err := m.FileRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n192
	}
	if len(m.ContentsString) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContentsString)))
		i += copy(data[i:], m.ContentsString)
	}
	if m.SourceCode != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.SourceCode.Size()))
		n193, err := m.SourceCode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n193
	}
	if m.FormatResult != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FormatResult.Size()))
		n194, err := m.FormatResult.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n194
	}
	return i, nil
}

func (m *TreeEntrySpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntrySpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n195, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n195
	if len(m.Path) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *UnitDelta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnitDelta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
		n196, err := m.Base.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n196
	}
	if m.Head != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
		n197, err := m.Head.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n197
	}
	return i, nil
}

func (m *UnitListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnitListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.NameQuery) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.NameQuery)))
		i += copy(data[i:], m.NameQuery)
	}
	if len(m.Query) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	data[i] = 0x32
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n198, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n198
	return i, nil
}

func (m *UnitSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnitSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRevSpec.Size()))
	n199, err := m.RepoRevSpec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n199
	if len(m.UnitType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	return i, nil
}

func (m *RepoSourceUnitList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSourceUnitList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Units) > 0 {
		for _, msg := range m.Units {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefAuthorList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, msg := range m.DefAuthors {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefClientList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefClientList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefClients) > 0 {
		for _, msg := range m.DefClients {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Checklist) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Checklist) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Todo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Todo))
	}
	if m.Done != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Done))
	}
	return i, nil
}

func (m *FileToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Entry != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
		n200, err := m.Entry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n200
	}
	return i, nil
}

func (m *ServerStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServerStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Info)))
		i += copy(data[i:], m.Info)
	}
	return i, nil
}

func (m *ServerConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServerConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	if len(m.FederationRootURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FederationRootURL)))
		i += copy(data[i:], m.FederationRootURL)
	}
	if m.IsFederationRoot {
		data[i] = 0x30
		i++
		if m.IsFederationRoot {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.IDKey) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.IDKey)))
		i += copy(data[i:], m.IDKey)
	}
	if m.AllowAnonymousReaders {
		data[i] = 0x48
		i++
		if m.AllowAnonymousReaders {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.AuthSource) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AuthSource)))
		i += copy(data[i:], m.AuthSource)
	}
	return i, nil
}

func (m *RegisteredClient) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisteredClient) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.RedirectURIs) > 0 {
		for _, s := range m.RedirectURIs {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ClientName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientName)))
		i += copy(data[i:], m.ClientName)
	}
	if len(m.LogoURI) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LogoURI)))
		i += copy(data[i:], m.LogoURI)
	}
	if len(m.ClientURI) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientURI)))
		i += copy(data[i:], m.ClientURI)
	}
	if len(m.JWKS) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.JWKS)))
		i += copy(data[i:], m.JWKS)
	}
	if len(m.ClientSecret) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientSecret)))
		i += copy(data[i:], m.ClientSecret)
	}
	if len(m.Description) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Meta) > 0 {
		keysForMeta := make([]string, 0, len(m.Meta))
		for k, _ := range m.Meta {
			keysForMeta = append(keysForMeta, k)
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMeta)
		for _, k := range keysForMeta {
			data[i] = 0x4a
			i++
			v := m.Meta[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if m.Type != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Type))
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n201, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n201
	data[i] = 0x62
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
	n202, err := m.UpdatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n202
	return i, nil
}

func (m *RegisteredClientSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisteredClientSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *RegisteredClientCredentials) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisteredClientCredentials) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Secret) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Secret)))
		i += copy(data[i:], m.Secret)
	}
	return i, nil
}

func (m *RegisteredClientListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisteredClientListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Type))
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n203, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n203
	return i, nil
}

func (m *RegisteredClientList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RegisteredClientList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for _, msg := range m.Clients {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n204, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n204
	return i, nil
}

func (m *UserPermissions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserPermissions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.Read {
		data[i] = 0x18
		i++
		if m.Read {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Write {
		data[i] = 0x20
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x28
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserPermissionsList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserPermissionsList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserPermissions) > 0 {
		for _, msg := range m.UserPermissions {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserPermissionsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserPermissionsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientSpec != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ClientSpec.Size()))
		n205, err := m.ClientSpec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n205
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *MetricsSnapshot) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricsSnapshot) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Type))
	}
	if m.TelemetryData != nil {
		if len(m.TelemetryData) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(m.TelemetryData)))
			i += copy(data[i:], m.TelemetryData)
		}
	}
	return i, nil
}

func (m *UserEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if len(m.Service) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Service)))
		i += copy(data[i:], m.Service)
	}
	if len(m.Method) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Method)))
		i += copy(data[i:], m.Method)
	}
	if len(m.Result) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Result)))
		i += copy(data[i:], m.Result)
	}
	if m.CreatedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n206, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n206
	}
	if len(m.Message) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if len(m.Version) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.URL) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	return i, nil
}

func (m *UserEventList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserEventList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Event) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Event) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.UserID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UserID)))
		i += copy(data[i:], m.UserID)
	}
	if len(m.DeviceID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DeviceID)))
		i += copy(data[i:], m.DeviceID)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.Timestamp != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Timestamp.Size()))
		n207, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n207
	}
	if len(m.UserProperties) > 0 {
		keysForUserProperties := make([]string, 0, len(m.UserProperties))
		for k, _ := range m.UserProperties {
			keysForUserProperties = append(keysForUserProperties, k)
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForUserProperties)
		for _, k := range keysForUserProperties {
			data[i] = 0x32
			i++
			v := m.UserProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.EventProperties) > 0 {
		keysForEventProperties := make([]string, 0, len(m.EventProperties))
		for k, _ := range m.EventProperties {
			keysForEventProperties = append(keysForEventProperties, k)
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEventProperties)
		for _, k := range keysForEventProperties {
			data[i] = 0x3a
			i++
			v := m.EventProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *EventList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	return i, nil
}

func (m *NotifyGenericEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NotifyGenericEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Actor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Actor.Size()))
		n208, err := m.Actor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n208
	}
	if len(m.Recipients) > 0 {
		for _, msg := range m.Recipients {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ActionType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ActionType)))
		i += copy(data[i:], m.ActionType)
	}
	if len(m.ActionContent) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ActionContent)))
		i += copy(data[i:], m.ActionContent)
	}
	if m.ObjectID != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ObjectID))
	}
	if len(m.ObjectRepo) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectRepo)))
		i += copy(data[i:], m.ObjectRepo)
	}
	if len(m.ObjectType) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectType)))
		i += copy(data[i:], m.ObjectType)
	}
	if len(m.ObjectTitle) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectTitle)))
		i += copy(data[i:], m.ObjectTitle)
	}
	if len(m.ObjectURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectURL)))
		i += copy(data[i:], m.ObjectURL)
	}
	if len(m.SlackMsg) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SlackMsg)))
		i += copy(data[i:], m.SlackMsg)
	}
	if len(m.EmailHTML) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.EmailHTML)))
		i += copy(data[i:], m.EmailHTML)
	}
	if m.NoEmail {
		data[i] = 0x68
		i++
		if m.NoEmail {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Sourcegraph(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sourcegraph(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSourcegraph(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Badge) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ImageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UncountedImageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Markdown)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *CombinedStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Counter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ImageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UncountedImageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Markdown)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	var l int
	_ = l
	if m.PerPage != 0 {
		n += 1 + sovSourcegraph(uint64(m.PerPage))
	}
	if m.Page != 0 {
		n += 1 + sovSourcegraph(uint64(m.Page))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovSourcegraph(uint64(m.Total))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *Changeset) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Author.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.DeltaSpec != nil {
		l = m.DeltaSpec.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Merged {
		n += 2
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ClosedAt != nil {
		l = m.ClosedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ChangesetReview) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Author.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EditedAt != nil {
		l = m.EditedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Deleted {
		n += 2
	}
	return n
}

func (m *ChangesetEvent) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Op != nil {
		l = m.Op.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *InlineComment) Size() (n int) {
	var l int
	_ = l
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.LineNumber != 0 {
		n += 1 + sovSourcegraph(uint64(m.LineNumber))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Author.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EditedAt != nil {
		l = m.EditedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Deleted {
		n += 2
	}
	return n
}

func (m *Readme) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTML)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *GitHubRepo) Size() (n int) {
	var l int
	_ = l
	if m.Stars != 0 {
		n += 1 + sovSourcegraph(uint64(m.Stars))
	}
	return n
}

func (m *RepoConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Repo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.VCS)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SSHCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Blocked {
		n += 2
	}
	if m.Deprecated {
		n += 2
	}
	if m.Fork {
		n += 2
	}
	if m.Mirror {
		n += 2
	}
	if m.Private {
		n += 2
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.PushedAt != nil {
		l = m.PushedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.Permissions != nil {
		l = m.Permissions.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.GitHub != nil {
		l = m.GitHub.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Origin)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTMLURL)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BadgeList) Size() (n int) {
	var l int
	_ = l
	if len(m.Badges) > 0 {
		for _, e := range m.Badges {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *CounterList) Size() (n int) {
	var l int
	_ = l
	if len(m.Counters) > 0 {
		for _, e := range m.Counters {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *RepoBadgesCountHitsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Since != nil {
		l = m.Since.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoBadgesCountHitsResult) Size() (n int) {
	var l int
	_ = l
	if m.Hits != 0 {
		n += 1 + sovSourcegraph(uint64(m.Hits))
	}
	return n
}

func (m *RepoListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoFork {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoPermissions) Size() (n int) {
	var l int
	_ = l
	if m.Read {
		n += 2
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *RepoRevSpec) Size() (n int) {
	var l int
	_ = l
	l = m.RepoSpec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.TargetURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.UpdatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoStatusesCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoList) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *SrclibDataVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CommitsBehind != 0 {
		n += 1 + sovSourcegraph(uint64(m.CommitsBehind))
	}
	return n
}

func (m *RepoConfigureAppOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	return n
}

func (m *StorageBucket) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *StorageKey) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = m.Bucket.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *StorageValue) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *StoragePutOp) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *StorageExists) Size() (n int) {
	var l int
	_ = l
	if m.Exists {
		n += 2
	}
	return n
}

func (m *StorageList) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ReposCreateOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.VCS)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Mirror {
		n += 2
	}
	if m.Private {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposUpdateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListCommitsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommitsOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Base)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.RefreshCache {
		n += 2
	}
	return n
}

func (m *CommitList) Size() (n int) {
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListBranchesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListBranchesOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.IncludeCommit {
		n += 2
	}
	l = len(m.BehindAheadBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContainsCommit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BranchList) Size() (n int) {
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListTagsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListCommittersOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommittersOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *CommitterList) Size() (n int) {
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, e := range m.Committers {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ChangesetCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Changeset != nil {
		l = m.Changeset.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ChangesetCreateReviewOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ChangesetID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ChangesetID))
	}
	if m.Review != nil {
		l = m.Review.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ChangesetListReviewsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ChangesetID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ChangesetID))
	}
	return n
}

func (m *ChangesetSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *ChangesetUpdateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Open {
		n += 2
	}
	if m.Close {
		n += 2
	}
	if m.Merged {
		n += 2
	}
	l = m.Author.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ChangesetMergeOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Squash {
		n += 2
	}
	return n
}

func (m *ChangesetUpdateAffectedOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Last)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ForcePush {
		n += 2
	}
	return n
}

func (m *RepoListTagsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TagList) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *MirrorReposRefreshVCSOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *VCSCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *MirroredRepoSSHKeysCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Key.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *SSHPrivateKey) Size() (n int) {
	var l int
	_ = l
	if m.PEM != nil {
		l = len(m.PEM)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Build) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeartbeatAt != nil {
		l = m.HeartbeatAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Killed {
		n += 2
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Purged {
		n += 2
	}
	l = m.BuildConfig.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildConfig) Size() (n int) {
	var l int
	_ = l
	if m.Queue {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovSourcegraph(uint64(m.Priority))
	}
	l = len(m.BuilderConfig)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildGetLogOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.MinID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Queued {
		n += 2
	}
	if m.Active {
		n += 2
	}
	if m.Ended {
		n += 2
	}
	if m.Succeeded {
		n += 2
	}
	if m.Failed {
		n += 2
	}
	if m.Purged {
		n += 2
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ChangesetListOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Open {
		n += 2
	}
	if m.Closed {
		n += 2
	}
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Base)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *BuildTask) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ParentID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ParentID))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Skipped {
		n += 2
	}
	if m.Warnings {
		n += 2
	}
	return n
}

func (m *BuildTaskListOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildUpdate) Size() (n int) {
	var l int
	_ = l
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeartbeatAt != nil {
		l = m.HeartbeatAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Purged {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Killed {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovSourcegraph(uint64(m.Priority))
	}
	l = len(m.BuilderConfig)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildList) Size() (n int) {
	var l int
	_ = l
	if len(m.Builds) > 0 {
		for _, e := range m.Builds {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsUpdateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Info.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsListBuildTasksOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildTaskList) Size() (n int) {
	var l int
	_ = l
	if len(m.BuildTasks) > 0 {
		for _, e := range m.BuildTasks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ChangesetReviewList) Size() (n int) {
	var l int
	_ = l
	if len(m.Reviews) > 0 {
		for _, e := range m.Reviews {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ChangesetList) Size() (n int) {
	var l int
	_ = l
	if len(m.Changesets) > 0 {
		for _, e := range m.Changesets {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ChangesetEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *BuildsCreateTasksOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *BuildsUpdateTaskOp) Size() (n int) {
	var l int
	_ = l
	l = m.Task.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Info.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsGetTaskLogOp) Size() (n int) {
	var l int
	_ = l
	l = m.Task.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildsDequeueNextOp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EmailAddr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Guessed {
		n += 2
	}
	if m.Blacklisted {
		n += 2
	}
	return n
}

func (m *LogEntries) Size() (n int) {
	var l int
	_ = l
	l = len(m.MaxID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Org) Size() (n int) {
	var l int
	_ = l
	l = m.User.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *OrgListMembersOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *OrgSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Org)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *OrgsListMembersOp) Size() (n int) {
	var l int
	_ = l
	l = m.Org.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UserList) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UserCount) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	return n
}

func (m *Person) Size() (n int) {
	var l int
	_ = l
	l = m.PersonSpec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.FullName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PersonSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *TaskSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *TaskUpdate) Size() (n int) {
	var l int
	_ = l
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Skipped {
		n += 2
	}
	if m.Warnings {
		n += 2
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.IsOrganization {
		n += 2
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if m.RegisteredAt != nil {
		l = m.RegisteredAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Admin {
		n += 2
	}
	if m.Write {
		n += 2
	}
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UsersListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *OrgsListOp) Size() (n int) {
	var l int
	_ = l
	l = m.Member.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *EmailAddrList) Size() (n int) {
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, e := range m.EmailAddrs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *OrgList) Size() (n int) {
	var l int
	_ = l
	if len(m.Orgs) > 0 {
		for _, e := range m.Orgs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *PasswordResetToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PendingPasswordReset) Size() (n int) {
	var l int
	_ = l
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EmailSent {
		n += 2
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NewPassword) Size() (n int) {
	var l int
	_ = l
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NewAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *AccountInvite) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *InviteSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PendingInvite) Size() (n int) {
	var l int
	_ = l
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EmailSent {
		n += 2
	}
	return n
}

func (m *AccountInviteList) Size() (n int) {
	var l int
	_ = l
	if len(m.Invites) > 0 {
		for _, e := range m.Invites {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *AcceptedInvite) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *SSHKeyList) Size() (n int) {
	var l int
	_ = l
	if len(m.SSHKeys) > 0 {
		for _, e := range m.SSHKeys {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *SSHPublicKey) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *AuthorizationCodeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResponseType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.RedirectURI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *AuthorizationCode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.RedirectURI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *LoginCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BearerJWT) Size() (n int) {
	var l int
	_ = l
	l = len(m.Assertion)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *AccessTokenRequest) Size() (n int) {
	var l int
	_ = l
	if m.AuthorizationGrant != nil {
		n += m.AuthorizationGrant.Size()
	}
	l = len(m.TokenURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 2 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *AccessTokenRequest_AuthorizationCode) Size() (n int) {
	var l int
	_ = l
	if m.AuthorizationCode != nil {
		l = m.AuthorizationCode.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *AccessTokenRequest_ResourceOwnerPassword) Size() (n int) {
	var l int
	_ = l
	if m.ResourceOwnerPassword != nil {
		l = m.ResourceOwnerPassword.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *AccessTokenRequest_BearerJWT) Size() (n int) {
	var l int
	_ = l
	if m.BearerJWT != nil {
		l = m.BearerJWT.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *AccessTokenResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ExpiresInSec != 0 {
		n += 1 + sovSourcegraph(uint64(m.ExpiresInSec))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *AuthInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *AuthorshipInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.AuthorEmail)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.LastCommitDate.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.LastCommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Def) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.DocHTML != nil {
		l = m.DocHTML.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FmtStrings != nil {
		l = m.FmtStrings.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefAuthor) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.DefAuthorship.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefAuthorship) Size() (n int) {
	var l int
	_ = l
	l = m.AuthorshipInfo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Exported {
		n += 2
	}
	if m.Bytes != 0 {
		n += 1 + sovSourcegraph(uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		n += 9
	}
	return n
}

func (m *DefClient) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.AuthorshipInfo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.UseCount != 0 {
		n += 1 + sovSourcegraph(uint64(m.UseCount))
	}
	return n
}

func (m *DefDelta) Size() (n int) {
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.Doc {
		n += 2
	}
	return n
}

func (m *DefListAuthorsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListClientsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListExamplesOptions) Size() (n int) {
	var l int
	_ = l
	if m.Formatted {
		n += 2
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.TokenizedSource {
		n += 2
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ByteStart != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, e := range m.DefKeys {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.FilePathPrefix)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Exported {
		n += 2
	}
	if m.Nonlocal {
		n += 2
	}
	if m.IncludeTest {
		n += 2
	}
	if m.Doc {
		n += 3
	}
	if m.Fuzzy {
		n += 3
	}
	l = len(m.Sort)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 2 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListRefsOptions) Size() (n int) {
	var l int
	_ = l
	if m.Authorship {
		n += 2
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListRefsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListExamplesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ExampleList) Size() (n int) {
	var l int
	_ = l
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListAuthorsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsListClientsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Delta) Size() (n int) {
	var l int
	_ = l
	l = m.Base.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Head.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.BaseCommit != nil {
		l = m.BaseCommit.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeadCommit != nil {
		l = m.HeadCommit.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.BaseRepo != nil {
		l = m.BaseRepo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeadRepo != nil {
		l = m.HeadRepo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltaAffectedPerson) Size() (n int) {
	var l int
	_ = l
	l = m.Person.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DeltaDefs) Size() (n int) {
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.DiffStat.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *FileDiff) Size() (n int) {
	var l int
	_ = l
	l = m.FileDiff.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.FileDiffHunks) > 0 {
		for _, e := range m.FileDiffHunks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.PreImage)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.PostImage)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Stats.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *Hunk) Size() (n int) {
	var l int
	_ = l
	l = m.Hunk.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.LinePrefixes)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.BaseSource != nil {
		l = m.BaseSource.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeadSource != nil {
		l = m.HeadSource.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.BodySource != nil {
		l = m.BodySource.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltaFiles) Size() (n int) {
	var l int
	_ = l
	if len(m.FileDiffs) > 0 {
		for _, e := range m.FileDiffs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Delta != nil {
		l = m.Delta.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Stats.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.OverThreshold {
		n += 2
	}
	return n
}

func (m *DeltaFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltaListAffectedAuthorsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.DeltaFilter.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltaListAffectedClientsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.DeltaFilter.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltaListDefsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.DeltaFilter.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltaListFilesOptions) Size() (n int) {
	var l int
	_ = l
	if m.Formatted {
		n += 2
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Tokenized {
		n += 2
	}
	if m.MaxSize != 0 {
		n += 1 + sovSourcegraph(uint64(m.MaxSize))
	}
	l = m.DeltaFilter.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltaListUnitsOptions) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeltaSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Base.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Head.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltasListUnitsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UnitDeltaList) Size() (n int) {
	var l int
	_ = l
	if len(m.UnitDeltas) > 0 {
		for _, e := range m.UnitDeltas {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DeltasListDefsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltasListFilesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltasListAffectedAuthorsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltaAffectedPersonList) Size() (n int) {
	var l int
	_ = l
	if len(m.DeltaAffectedPersons) > 0 {
		for _, e := range m.DeltaAffectedPersons {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DeltasListAffectedClientsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Example) Size() (n int) {
	var l int
	_ = l
	l = m.Ref.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.SrcHTML)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.SourceCode != nil {
		l = m.SourceCode.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.StartLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndLine))
	}
	if m.Error {
		n += 2
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *FormatResult) Size() (n int) {
	var l int
	_ = l
	if m.TooManyRefs {
		n += 2
	}
	if m.NumRefs != 0 {
		n += 1 + sovSourcegraph(uint64(m.NumRefs))
	}
	if len(m.LineStartByteOffsets) > 0 {
		for _, e := range m.LineStartByteOffsets {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	return n
}

func (m *MarkdownData) Size() (n int) {
	var l int
	_ = l
	if m.Rendered != nil {
		l = len(m.Rendered)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Checklist != nil {
		l = m.Checklist.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *MarkdownOpt) Size() (n int) {
	var l int
	_ = l
	if m.EnableCheckboxes {
		n += 2
	}
	return n
}

func (m *MarkdownRequestBody) Size() (n int) {
	var l int
	_ = l
	if m.Markdown != nil {
		l = len(m.Markdown)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.MarkdownOpt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *MarkdownRenderOp) Size() (n int) {
	var l int
	_ = l
	if m.Markdown != nil {
		l = len(m.Markdown)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.Opt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *Ref) Size() (n int) {
	var l int
	_ = l
	l = m.Ref.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Authorship != nil {
		l = m.Authorship.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.Formatted {
		n += 2
	}
	if len(m.HighlightStrings) > 0 {
		for _, s := range m.HighlightStrings {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.TokenizedSource {
		n += 2
	}
	if m.ContentsAsString {
		n += 2
	}
	l = m.GetFileOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = m.SearchOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Formatted {
		n += 2
	}
	return n
}

func (m *RepoTreeSearchResult) Size() (n int) {
	var l int
	_ = l
	l = m.SearchResult.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeSearchOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeListOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeListResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *VCSSearchResultList) Size() (n int) {
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, e := range m.SearchResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TokenSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TextSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *SourceCode) Size() (n int) {
	var l int
	_ = l
	if len(m.Lines) > 0 {
		for _, e := range m.Lines {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.NumRefs != 0 {
		n += 1 + sovSourcegraph(uint64(m.NumRefs))
	}
	if m.TooManyRefs {
		n += 2
	}
	return n
}

func (m *SourceCodeLine) Size() (n int) {
	var l int
	_ = l
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *SourceCodeToken) Size() (n int) {
	var l int
	_ = l
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	if len(m.URL) > 0 {
		for _, s := range m.URL {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.IsDef {
		n += 2
	}
	l = len(m.Class)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ExtraClasses)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *TreeEntry) Size() (n int) {
	var l int
	_ = l
	if m.TreeEntry != nil {
		l = m.TreeEntry.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FileRange != nil {
		l = m.FileRange.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContentsString)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.SourceCode != nil {
		l = m.SourceCode.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FormatResult != nil {
		l = m.FormatResult.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *TreeEntrySpec) Size() (n int) {
	var l int
	_ = l
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UnitDelta) Size() (n int) {
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UnitListOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.NameQuery)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *UnitSpec) Size() (n int) {
	var l int
	_ = l
	l = m.RepoRevSpec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSourceUnitList) Size() (n int) {
	var l int
	_ = l
	if len(m.Units) > 0 {
		for _, e := range m.Units {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DefAuthorList) Size() (n int) {
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, e := range m.DefAuthors {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DefClientList) Size() (n int) {
	var l int
	_ = l
	if len(m.DefClients) > 0 {
		for _, e := range m.DefClients {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Checklist) Size() (n int) {
	var l int
	_ = l
	if m.Todo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Todo))
	}
	if m.Done != 0 {
		n += 1 + sovSourcegraph(uint64(m.Done))
	}
	return n
}

func (m *FileToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ServerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ServerConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.FederationRootURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.IsFederationRoot {
		n += 2
	}
	l = len(m.IDKey)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.AllowAnonymousReaders {
		n += 2
	}
	l = len(m.AuthSource)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RegisteredClient) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.RedirectURIs) > 0 {
		for _, s := range m.RedirectURIs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.ClientName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.LogoURI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientURI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.JWKS)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	if m.Type != 0 {
		n += 1 + sovSourcegraph(uint64(m.Type))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.UpdatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RegisteredClientSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RegisteredClientCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RegisteredClientListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSourcegraph(uint64(m.Type))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RegisteredClientList) Size() (n int) {
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for _, e := range m.Clients {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *UserPermissions) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Read {
		n += 2
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	return n
}

func (m *UserPermissionsList) Size() (n int) {
	var l int
	_ = l
	if len(m.UserPermissions) > 0 {
		for _, e := range m.UserPermissions {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UserPermissionsOptions) Size() (n int) {
	var l int
	_ = l
	if m.ClientSpec != nil {
		l = m.ClientSpec.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *MetricsSnapshot) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSourcegraph(uint64(m.Type))
	}
	if m.TelemetryData != nil {
		l = len(m.TelemetryData)
		if l > 0 {
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UserEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UserEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.UserProperties) > 0 {
		for k, v := range m.UserProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	if len(m.EventProperties) > 0 {
		for k, v := range m.EventProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NotifyGenericEvent) Size() (n int) {
	var l int
	_ = l
	if m.Actor != nil {
		l = m.Actor.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Recipients) > 0 {
		for _, e := range m.Recipients {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.ActionType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ActionContent)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ObjectID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ObjectID))
	}
	l = len(m.ObjectRepo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectTitle)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SlackMsg)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.EmailHTML)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoEmail {
		n += 2
	}
	return n
}

func sovSourcegraph(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSourcegraph(x uint64) (n int) {
	return sovSourcegraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Badge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Badge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Badge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncountedImageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UncountedImageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markdown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markdown = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinedStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinedStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinedStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, &RepoStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Counter) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Counter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Counter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncountedImageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UncountedImageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markdown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markdown = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerPage", wireType)
			}
			m.PerPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PerPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Changeset) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Changeset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Changeset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeltaSpec == nil {
				m.DeltaSpec = &DeltaSpec{}
			}
			if err := m.DeltaSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Merged = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClosedAt == nil {
				m.ClosedAt = &pbtypes.Timestamp{}
			}
			if err := m.ClosedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetReview) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetReview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetReview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditedAt == nil {
				m.EditedAt = &pbtypes.Timestamp{}
			}
			if err := m.EditedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &InlineComment{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Changeset{}
			}
			if err := m.Before.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Changeset{}
			}
			if err := m.After.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Op == nil {
				m.Op = &ChangesetUpdateOp{}
			}
			if err := m.Op.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineComment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineComment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineComment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineNumber", wireType)
			}
			m.LineNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LineNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EditedAt == nil {
				m.EditedAt = &pbtypes.Timestamp{}
			}
			if err := m.EditedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Readme) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Readme: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Readme: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTML", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTML = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitHubRepo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitHubRepo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitHubRepo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			m.Stars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Stars |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCS = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deprecated = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fork = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &pbtypes.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedAt == nil {
				m.PushedAt = &pbtypes.Timestamp{}
			}
			if err := m.PushedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permissions == nil {
				m.Permissions = &RepoPermissions{}
			}
			if err := m.Permissions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHub", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GitHub == nil {
				m.GitHub = &GitHubRepo{}
			}
			if err := m.GitHub.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Origin = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTMLURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTMLURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadgeList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadgeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadgeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badges = append(m.Badges, &Badge{})
			if err := m.Badges[len(m.Badges)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CounterList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CounterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CounterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Counters = append(m.Counters, &Counter{})
			if err := m.Counters[len(m.Counters)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoBadgesCountHitsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoBadgesCountHitsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoBadgesCountHitsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Since == nil {
				m.Since = &pbtypes.Timestamp{}
			}
			if err := m.Since.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoBadgesCountHitsResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoBadgesCountHitsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoBadgesCountHitsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			m.Hits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Hits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoFork = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoPermissions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoRevSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoRevSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoRevSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatusesCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, &Repo{})
			if err := m.Repos[len(m.Repos)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrclibDataVersion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrclibDataVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrclibDataVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitsBehind", wireType)
			}
			m.CommitsBehind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitsBehind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfigureAppOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfigureAppOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfigureAppOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageBucket) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bucket == nil {
				m.Bucket = &StorageBucket{}
			}
			if err := m.Bucket.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoragePutOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoragePutOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoragePutOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageExists) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageExists: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageExists: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCS = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommitsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommitsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommitsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommitsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommitsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommitsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommitsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshCache = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &vcs.Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListBranchesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListBranchesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListBranchesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListBranchesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListBranchesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListBranchesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListBranchesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BehindAheadBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BehindAheadBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainsCommit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &vcs.Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListTagsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListTagsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListTagsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListTagsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommittersOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommittersOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommittersOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommittersOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommittersOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommittersOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommittersOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitterList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committers = append(m.Committers, &vcs.Committer{})
			if err := m.Committers[len(m.Committers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changeset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Changeset == nil {
				m.Changeset = &Changeset{}
			}
			if err := m.Changeset.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetCreateReviewOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetCreateReviewOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetCreateReviewOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetID", wireType)
			}
			m.ChangesetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChangesetID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Review", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Review == nil {
				m.Review = &ChangesetReview{}
			}
			if err := m.Review.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetListReviewsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetListReviewsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetListReviewsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangesetID", wireType)
			}
			m.ChangesetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChangesetID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Close = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Merged = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetMergeOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetMergeOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetMergeOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Squash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Squash = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetUpdateAffectedOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetUpdateAffectedOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetUpdateAffectedOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Last = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePush = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListTagsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListTagsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListTagsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &vcs.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorReposRefreshVCSOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VCSCredentials) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VCSCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VCSCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirroredRepoSSHKeysCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirroredRepoSSHKeysCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirroredRepoSSHKeysCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSHPrivateKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSHPrivateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSHPrivateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PEM", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PEM = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Build) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatAt == nil {
				m.HeartbeatAt = &pbtypes.Timestamp{}
			}
			if err := m.HeartbeatAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Killed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildConfig.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Queue = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderConfig = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildGetLogOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildGetLogOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildGetLogOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queued", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Queued = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ended = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeeded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Open = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Closed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Closed = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTask) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ParentID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skipped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skipped = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Warnings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTaskListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTaskListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTaskListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatAt == nil {
				m.HeartbeatAt = &pbtypes.Timestamp{}
			}
			if err := m.HeartbeatAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Killed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderConfig = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Builds = append(m.Builds, &Build{})
			if err := m.Builds[len(m.Builds)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsListBuildTasksOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsListBuildTasksOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsListBuildTasksOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &BuildTaskListOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTaskList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTaskList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTaskList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTasks = append(m.BuildTasks, &BuildTask{})
			if err := m.BuildTasks[len(m.BuildTasks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetReviewList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetReviewList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetReviewList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviews", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviews = append(m.Reviews, &ChangesetReview{})
			if err := m.Reviews[len(m.Reviews)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changesets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changesets = append(m.Changesets, &Changeset{})
			if err := m.Changesets[len(m.Changesets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangesetEventList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangesetEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangesetEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &ChangesetEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsCreateTasksOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsCreateTasksOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsCreateTasksOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &BuildTask{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsUpdateTaskOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsUpdateTaskOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsUpdateTaskOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Task.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsGetTaskLogOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsGetTaskLogOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsGetTaskLogOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Task.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &BuildGetLogOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsDequeueNextOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsDequeueNextOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsDequeueNextOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guessed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Guessed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklisted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blacklisted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntries) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Org) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Org: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Org: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgListMembersOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgListMembersOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgListMembersOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Org = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgsListMembersOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgsListMembersOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgsListMembersOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Org.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &OrgListMembersOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Person) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Person: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Person: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PersonSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skipped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skipped = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Warnings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOrganization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOrganization = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredAt == nil {
				m.RegisteredAt = &pbtypes.Timestamp{}
			}
			if err := m.RegisteredAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgsListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgsListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgsListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Member.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddrList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailAddrs = append(m.EmailAddrs, &EmailAddr{})
			if err := m.EmailAddrs[len(m.EmailAddrs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orgs = append(m.Orgs, &Org{})
			if err := m.Orgs[len(m.Orgs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordResetToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordResetToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordResetToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingPasswordReset) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingPasswordReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingPasswordReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &PasswordResetToken{}
			}
			if err := m.Token.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailSent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmailSent = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewPassword) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &PasswordResetToken{}
			}
			if err := m.Token.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInvite) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingInvite) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailSent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmailSent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInviteList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInviteList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInviteList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invites = append(m.Invites, &AccountInvite{})
			if err := m.Invites[len(m.Invites)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptedInvite) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptedInvite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptedInvite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &NewAccount{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSHKeyList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSHKeyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSHKeyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHKeys = append(m.SSHKeys, SSHPublicKey{})
			if err := m.SSHKeys[len(m.SSHKeys)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSHPublicKey) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSHPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSHPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationCodeRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationCodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationCodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationCode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginCredentials) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerJWT) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerJWT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerJWT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assertion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assertion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessTokenRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizationCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthorizationCode{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthorizationGrant = &AccessTokenRequest_AuthorizationCode{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOwnerPassword", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoginCredentials{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthorizationGrant = &AccessTokenRequest_ResourceOwnerPassword{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerJWT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerJWT{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthorizationGrant = &AccessTokenRequest_BearerJWT{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessTokenResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresInSec", wireType)
			}
			m.ExpiresInSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpiresInSec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorshipInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorshipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorshipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorEmail = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCommitDate.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Def) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Def: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Def: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocHTML", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocHTML == nil {
				m.DocHTML = &pbtypes2.HTML{}
			}
			if err := m.DocHTML.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmtStrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmtStrings == nil {
				m.FmtStrings = &graph.DefFormatStrings{}
			}
			if err := m.FmtStrings.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthorship", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefAuthorship.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorship) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorshipInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthorshipInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exported = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Bytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesProportion", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.BytesProportion = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefClient) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorshipInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthorshipInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCount", wireType)
			}
			m.UseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UseCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefDelta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &Def{}
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Def{}
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListAuthorsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListAuthorsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListAuthorsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListClientsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListClientsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListClientsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListExamplesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListExamplesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListExamplesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formatted = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenizedSource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TokenizedSource = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteStart", wireType)
			}
			m.ByteStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteStart |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteEnd", wireType)
			}
			m.ByteEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteEnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefKeys = append(m.DefKeys, &graph.DefKey{})
			if err := m.DefKeys[len(m.DefKeys)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRevs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRevs = append(m.RepoRevs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePathPrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exported = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonlocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nonlocal = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeTest = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fuzzy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fuzzy = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListRefsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListRefsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListRefsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorship", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Authorship = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &Def{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListRefsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListRefsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListRefsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListRefsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &Ref{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListExamplesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListExamplesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListExamplesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListExamplesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExampleList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExampleList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExampleList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &Example{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListAuthorsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListAuthorsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListAuthorsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListAuthorsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListClientsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListClientsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListClientsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListClientsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseCommit == nil {
				m.BaseCommit = &vcs.Commit{}
			}
			if err := m.BaseCommit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeadCommit == nil {
				m.HeadCommit = &vcs.Commit{}
			}
			if err := m.HeadCommit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseRepo == nil {
				m.BaseRepo = &Repo{}
			}
			if err := m.BaseRepo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeadRepo == nil {
				m.HeadRepo = &Repo{}
			}
			if err := m.HeadRepo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaAffectedPerson) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaAffectedPerson: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaAffectedPerson: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Person", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Person.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &Def{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaDefs) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaDefs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaDefs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &DefDelta{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DiffStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDiff) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileDiff.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiffHunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDiffHunks = append(m.FileDiffHunks, &Hunk{})
			if err := m.FileDiffHunks[len(m.FileDiffHunks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreImage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostImage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hunk) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Hunk.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinePrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinePrefixes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseSource == nil {
				m.BaseSource = &SourceCode{}
			}
			if err := m.BaseSource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeadSource == nil {
				m.HeadSource = &SourceCode{}
			}
			if err := m.HeadSource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodySource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodySource == nil {
				m.BodySource = &SourceCode{}
			}
			if err := m.BodySource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaFiles) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDiffs = append(m.FileDiffs, &FileDiff{})
			if err := m.FileDiffs[len(m.FileDiffs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta == nil {
				m.Delta = &Delta{}
			}
			if err := m.Delta.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverThreshold", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverThreshold = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaFilter) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListAffectedAuthorsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListAffectedAuthorsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListAffectedAuthorsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaFilter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListAffectedClientsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListAffectedClientsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListAffectedClientsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaFilter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListDefsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListDefsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListDefsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaFilter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListFilesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListFilesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListFilesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formatted = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokenized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tokenized = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaFilter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListUnitsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListUnitsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListUnitsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListUnitsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListUnitsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListUnitsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListUnitsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitDeltaList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitDeltaList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitDeltaList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitDeltas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitDeltas = append(m.UnitDeltas, &UnitDelta{})
			if err := m.UnitDeltas[len(m.UnitDeltas)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListDefsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListDefsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListDefsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListDefsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListFilesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListFilesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListFilesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListFilesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListAffectedAuthorsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListAffectedAuthorsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListAffectedAuthorsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListAffectedAuthorsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaAffectedPersonList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaAffectedPersonList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaAffectedPersonList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaAffectedPersons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeltaAffectedPersons = append(m.DeltaAffectedPersons, &DeltaAffectedPerson{})
			if err := m.DeltaAffectedPersons[len(m.DeltaAffectedPersons)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListAffectedClientsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListAffectedClientsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListAffectedClientsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListAffectedClientsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Example) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Example: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Example: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ref.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcHTML", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcHTML = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceCode == nil {
				m.SourceCode = &SourceCode{}
			}
			if err := m.SourceCode.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Error = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FormatResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FormatResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FormatResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TooManyRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TooManyRefs = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRefs", wireType)
			}
			m.NumRefs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumRefs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineStartByteOffsets", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LineStartByteOffsets = append(m.LineStartByteOffsets, v)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkdownData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkdownData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkdownData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rendered", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rendered = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checklist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Checklist == nil {
				m.Checklist = &Checklist{}
			}
			if err := m.Checklist.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkdownOpt) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkdownOpt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkdownOpt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCheckboxes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCheckboxes = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkdownRequestBody) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkdownRequestBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkdownRequestBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markdown", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markdown = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkdownOpt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MarkdownOpt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkdownRenderOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkdownRenderOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkdownRenderOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markdown", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markdown = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ref) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ref: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ref: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ref.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorship", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Authorship == nil {
				m.Authorship = &AuthorshipInfo{}
			}
			if err := m.Authorship.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formatted = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighlightStrings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HighlightStrings = append(m.HighlightStrings, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenizedSource", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TokenizedSource = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsAsString", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentsAsString = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFileOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetFileOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formatted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Formatted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchResult.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeSearchOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VCSSearchResultList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VCSSearchResultList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VCSSearchResultList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchResults = append(m.SearchResults, &vcs.SearchResult{})
			if err := m.SearchResults[len(m.SearchResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenSearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextSearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lines = append(m.Lines, &SourceCodeLine{})
			if err := m.Lines[len(m.Lines)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRefs", wireType)
			}
			m.NumRefs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumRefs |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TooManyRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TooManyRefs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeLine) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCodeLine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCodeLine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, &SourceCodeToken{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceCodeToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCodeToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCodeToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = append(m.URL, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDef = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Class = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraClasses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraClasses = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeEntry == nil {
				m.TreeEntry = &vcsclient.TreeEntry{}
			}
			if err := m.TreeEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileRange == nil {
				m.FileRange = &vcsclient.FileRange{}
			}
			if err := m.FileRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentsString = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceCode == nil {
				m.SourceCode = &SourceCode{}
			}
			if err := m.SourceCode.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormatResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FormatResult == nil {
				m.FormatResult = &FormatResult{}
			}
			if err := m.FormatResult.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntrySpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntrySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntrySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitDelta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &unit.RepoSourceUnit{}
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &unit.RepoSourceUnit{}
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRevs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRevs = append(m.RepoRevs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameQuery = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRevSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRevSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSourceUnitList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSourceUnitList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSourceUnitList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Units = append(m.Units, &unit.RepoSourceUnit{})
			if err := m.Units[len(m.Units)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefAuthors = append(m.DefAuthors, &DefAuthor{})
			if err := m.DefAuthors[len(m.DefAuthors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefClientList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefClientList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefClientList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefClients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefClients = append(m.DefClients, &DefClient{})
			if err := m.DefClients[len(m.DefClients)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Checklist) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checklist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checklist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Todo", wireType)
			}
			m.Todo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Todo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			m.Done = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Done |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &vcsclient.TreeEntry{}
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FederationRootURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FederationRootURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFederationRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFederationRoot = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAnonymousReaders", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowAnonymousReaders = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredClient) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURIs = append(m.RedirectURIs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogoURI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientURI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JWKS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JWKS = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Meta == nil {
				m.Meta = make(map[string]string)
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (RegisteredClientType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredClientSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredClientSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredClientSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredClientCredentials) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredClientCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredClientCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredClientListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredClientListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredClientListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (RegisteredClientType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredClientList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredClientList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredClientList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clients = append(m.Clients, &RegisteredClient{})
			if err := m.Clients[len(m.Clients)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Read", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Read = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissionsList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissionsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissionsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPermissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPermissions = append(m.UserPermissions, &UserPermissions{})
			if err := m.UserPermissions[len(m.UserPermissions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPermissionsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPermissionsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPermissionsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientSpec == nil {
				m.ClientSpec = &RegisteredClientSpec{}
			}
			if err := m.ClientSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsSnapshot) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (TelemetryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelemetryData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelemetryData = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEventList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &UserEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &pbtypes.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.UserProperties == nil {
				m.UserProperties = make(map[string]string)
			}
			m.UserProperties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.EventProperties == nil {
				m.EventProperties = make(map[string]string)
			}
			m.EventProperties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifyGenericEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifyGenericEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifyGenericEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Actor == nil {
				m.Actor = &UserSpec{}
			}
			if err := m.Actor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipients = append(m.Recipients, &UserSpec{})
			if err := m.Recipients[len(m.Recipients)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionContent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ObjectID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRepo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRepo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTitle = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlackMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlackMsg = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailHTML", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailHTML = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoEmail = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSourcegraph(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSourcegraph
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSourcegraph
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSourcegraph(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSourcegraph = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSourcegraph   = fmt.Errorf("proto: integer overflow")
)
