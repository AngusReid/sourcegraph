// Package sharedsecret generates client-authenticated OAuth2 access
// tokens derived from the ID key to allow different components of
// Sourcegraph to communicate securely without sharing the private
// key.
package sharedsecret

import (
	"time"

	"golang.org/x/net/context"
	"golang.org/x/oauth2"

	"src.sourcegraph.com/sourcegraph/auth"
	"src.sourcegraph.com/sourcegraph/auth/accesstoken"
	"src.sourcegraph.com/sourcegraph/auth/idkey"
	"src.sourcegraph.com/sourcegraph/go-sourcegraph/sourcegraph"
)

// TokenSource returns an OAuth2 token source that produces temporary,
// client-authenticated shared secret access tokens that may be
// verified using the public ID key.
//
// Using a TokenSource to generate temporary secrets is preferable to
// using permanent shared secrets (which this package could
// theoretically also generate) because if tokens are leaked, they
// will eventually expire. It also fits more cleanly into the rest of
// the architecture, which assumes OAuth2. Finally, it avoids us
// having to develop our own signature scheme, which is easy to mess
// up (and could lead to a security vulnerability).
func TokenSource(k *idkey.IDKey, scope ...string) oauth2.TokenSource {
	return &tokenSource{k, scope}
}

type tokenSource struct {
	k     *idkey.IDKey
	scope []string
}

func (ts *tokenSource) Token() (*oauth2.Token, error) {
	return accesstoken.New(ts.k, auth.Actor{
		ClientID: ts.k.ID,
		Scope:    ts.scope,
	}, map[string]string{"GrantType": "SharedSecret"}, expiry)
}

// SelfSignedTokenSource returns an OAuth2 token source whose tokens
// are HMAC-signed using a key derived from the private ID key. They
// are shorter than tokens generated by TokenSource (~180 chars. vs
// 500+ chars) and thus are suitable for use in places where long
// tokens exceed length restrictions (e.g., git <1.9 credentials).
func ShortTokenSource(k *idkey.IDKey, scope ...string) oauth2.TokenSource {
	return &shortTokenSource{k, scope}
}

type shortTokenSource struct {
	k     *idkey.IDKey
	scope []string
}

func (ts *shortTokenSource) Token() (*oauth2.Token, error) {
	return accesstoken.NewSelfSigned(ts.k, ts.scope, map[string]string{"GrantType": "ShortSharedSecret"}, expiry)
}

// expiry must be greater than golang.org/x/oauth2's expiryDelta,
// which currently is 10 seconds. Otherwise tokens will be considered
// invalid immediately when they are issued.
//
// This also must be long enough for any single subprocess CLI
// operation to complete; for example, the worker runs "src"
// subprocesses (such as for importing srclib data) and passes the
// access token to them, and the token must be valid for the entire
// duration of the operation (which could be 10+ minutes for large
// imports).
const expiry = 60 * time.Minute

// NewContext returns a copy of ctx that uses a shared secret
// TokenSource as API credentials to authenticate future calls.
func NewContext(ctx context.Context, scope ...string) context.Context {
	return sourcegraph.WithCredentials(ctx, TokenSource(idkey.FromContext(ctx), scope...))
}
