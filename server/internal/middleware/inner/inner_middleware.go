// GENERATED CODE - DO NOT EDIT!
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package inner

import (
	"time"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sourcegraph/srclib/unit"
	"sourcegraph.com/sqs/pbtypes"
	"src.sourcegraph.com/sourcegraph/gitserver/gitpb"
	"src.sourcegraph.com/sourcegraph/go-sourcegraph/sourcegraph"
	"src.sourcegraph.com/sourcegraph/pkg/inventory"
	"src.sourcegraph.com/sourcegraph/pkg/vcs"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/auth"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/federated"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/trace"
	"src.sourcegraph.com/sourcegraph/server/local"
	"src.sourcegraph.com/sourcegraph/svc"
)

// Services returns the local services wrapped with auth, federation, etc.
func Services(c *auth.Config) svc.Services {
	return svc.Services{

		GitTransport: wrappedGitTransport{c},

		MultiRepoImporter: wrappedMultiRepoImporter{c},

		Accounts: wrappedAccounts{c},

		Auth: wrappedAuth{c},

		Builds: wrappedBuilds{c},

		Changesets: wrappedChangesets{c},

		Defs: wrappedDefs{c},

		Deltas: wrappedDeltas{c},

		GraphUplink: wrappedGraphUplink{c},

		Markdown: wrappedMarkdown{c},

		Meta: wrappedMeta{c},

		MirrorRepos: wrappedMirrorRepos{c},

		MirroredRepoSSHKeys: wrappedMirroredRepoSSHKeys{c},

		Notify: wrappedNotify{c},

		Orgs: wrappedOrgs{c},

		People: wrappedPeople{c},

		RegisteredClients: wrappedRegisteredClients{c},

		RepoBadges: wrappedRepoBadges{c},

		RepoStatuses: wrappedRepoStatuses{c},

		RepoTree: wrappedRepoTree{c},

		Repos: wrappedRepos{c},

		Search: wrappedSearch{c},

		Storage: wrappedStorage{c},

		Units: wrappedUnits{c},

		UserKeys: wrappedUserKeys{c},

		Users: wrappedUsers{c},
	}
}

type wrappedGitTransport struct {
	c *auth.Config
}

func (s wrappedGitTransport) InfoRefs(ctx context.Context, param *gitpb.InfoRefsOp) (res *gitpb.Packet, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "GitTransport", "InfoRefs", param)
	defer func() {
		trace.After(ctx, "GitTransport", "InfoRefs", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "GitTransport.InfoRefs", repoURI)
	if err != nil {
		return
	}

	target := local.Services.GitTransport

	res, err = target.InfoRefs(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "GitTransport.InfoRefs returned nil, nil")
	}
	return
}

func (s wrappedGitTransport) ReceivePack(ctx context.Context, param *gitpb.ReceivePackOp) (res *gitpb.Packet, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "GitTransport", "ReceivePack", param)
	defer func() {
		trace.After(ctx, "GitTransport", "ReceivePack", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "GitTransport.ReceivePack", repoURI)
	if err != nil {
		return
	}

	target := local.Services.GitTransport

	res, err = target.ReceivePack(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "GitTransport.ReceivePack returned nil, nil")
	}
	return
}

func (s wrappedGitTransport) UploadPack(ctx context.Context, param *gitpb.UploadPackOp) (res *gitpb.Packet, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "GitTransport", "UploadPack", param)
	defer func() {
		trace.After(ctx, "GitTransport", "UploadPack", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "GitTransport.UploadPack", repoURI)
	if err != nil {
		return
	}

	target := local.Services.GitTransport

	res, err = target.UploadPack(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "GitTransport.UploadPack returned nil, nil")
	}
	return
}

type wrappedMultiRepoImporter struct {
	c *auth.Config
}

func (s wrappedMultiRepoImporter) Import(ctx context.Context, param *pb.ImportOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MultiRepoImporter", "Import", param)
	defer func() {
		trace.After(ctx, "MultiRepoImporter", "Import", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "MultiRepoImporter.Import", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MultiRepoImporter

	res, err = target.Import(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MultiRepoImporter.Import returned nil, nil")
	}
	return
}

func (s wrappedMultiRepoImporter) Index(ctx context.Context, param *pb.IndexOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MultiRepoImporter", "Index", param)
	defer func() {
		trace.After(ctx, "MultiRepoImporter", "Index", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "MultiRepoImporter.Index", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MultiRepoImporter

	res, err = target.Index(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MultiRepoImporter.Index returned nil, nil")
	}
	return
}

type wrappedAccounts struct {
	c *auth.Config
}

func (s wrappedAccounts) Create(ctx context.Context, param *sourcegraph.NewAccount) (res *sourcegraph.UserSpec, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "Create", param)
	defer func() {
		trace.After(ctx, "Accounts", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Accounts.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.Create returned nil, nil")
	}
	return
}

func (s wrappedAccounts) RequestPasswordReset(ctx context.Context, param *sourcegraph.PersonSpec) (res *sourcegraph.PendingPasswordReset, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "RequestPasswordReset", param)
	defer func() {
		trace.After(ctx, "Accounts", "RequestPasswordReset", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Accounts.RequestPasswordReset", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.RequestPasswordReset(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.RequestPasswordReset returned nil, nil")
	}
	return
}

func (s wrappedAccounts) ResetPassword(ctx context.Context, param *sourcegraph.NewPassword) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "ResetPassword", param)
	defer func() {
		trace.After(ctx, "Accounts", "ResetPassword", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Accounts.ResetPassword", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.ResetPassword(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.ResetPassword returned nil, nil")
	}
	return
}

func (s wrappedAccounts) Update(ctx context.Context, param *sourcegraph.User) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "Update", param)
	defer func() {
		trace.After(ctx, "Accounts", "Update", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Accounts.Update", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.Update(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.Update returned nil, nil")
	}
	return
}

func (s wrappedAccounts) Invite(ctx context.Context, param *sourcegraph.AccountInvite) (res *sourcegraph.PendingInvite, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "Invite", param)
	defer func() {
		trace.After(ctx, "Accounts", "Invite", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Accounts.Invite", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.Invite(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.Invite returned nil, nil")
	}
	return
}

func (s wrappedAccounts) AcceptInvite(ctx context.Context, param *sourcegraph.AcceptedInvite) (res *sourcegraph.UserSpec, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "AcceptInvite", param)
	defer func() {
		trace.After(ctx, "Accounts", "AcceptInvite", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Accounts.AcceptInvite", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.AcceptInvite(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.AcceptInvite returned nil, nil")
	}
	return
}

func (s wrappedAccounts) ListInvites(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.AccountInviteList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "ListInvites", param)
	defer func() {
		trace.After(ctx, "Accounts", "ListInvites", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "admin", "Accounts.ListInvites", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.ListInvites(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.ListInvites returned nil, nil")
	}
	return
}

func (s wrappedAccounts) DeleteInvite(ctx context.Context, param *sourcegraph.InviteSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "DeleteInvite", param)
	defer func() {
		trace.After(ctx, "Accounts", "DeleteInvite", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "admin", "Accounts.DeleteInvite", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.DeleteInvite(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.DeleteInvite returned nil, nil")
	}
	return
}

func (s wrappedAccounts) Delete(ctx context.Context, param *sourcegraph.PersonSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Accounts", "Delete", param)
	defer func() {
		trace.After(ctx, "Accounts", "Delete", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "admin", "Accounts.Delete", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Accounts

	res, err = target.Delete(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Accounts.Delete returned nil, nil")
	}
	return
}

type wrappedAuth struct {
	c *auth.Config
}

func (s wrappedAuth) GetAuthorizationCode(ctx context.Context, param *sourcegraph.AuthorizationCodeRequest) (res *sourcegraph.AuthorizationCode, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Auth", "GetAuthorizationCode", param)
	defer func() {
		trace.After(ctx, "Auth", "GetAuthorizationCode", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Auth.GetAuthorizationCode", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Auth

	res, err = target.GetAuthorizationCode(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Auth.GetAuthorizationCode returned nil, nil")
	}
	return
}

func (s wrappedAuth) GetAccessToken(ctx context.Context, param *sourcegraph.AccessTokenRequest) (res *sourcegraph.AccessTokenResponse, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Auth", "GetAccessToken", param)
	defer func() {
		trace.After(ctx, "Auth", "GetAccessToken", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Auth.GetAccessToken", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Auth

	res, err = target.GetAccessToken(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Auth.GetAccessToken returned nil, nil")
	}
	return
}

func (s wrappedAuth) Identify(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.AuthInfo, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Auth", "Identify", param)
	defer func() {
		trace.After(ctx, "Auth", "Identify", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Auth.Identify", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Auth

	res, err = target.Identify(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Auth.Identify returned nil, nil")
	}
	return
}

func (s wrappedAuth) GetExternalToken(ctx context.Context, param *sourcegraph.ExternalTokenRequest) (res *sourcegraph.ExternalToken, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Auth", "GetExternalToken", param)
	defer func() {
		trace.After(ctx, "Auth", "GetExternalToken", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Auth.GetExternalToken", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Auth

	res, err = target.GetExternalToken(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Auth.GetExternalToken returned nil, nil")
	}
	return
}

func (s wrappedAuth) SetExternalToken(ctx context.Context, param *sourcegraph.ExternalToken) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Auth", "SetExternalToken", param)
	defer func() {
		trace.After(ctx, "Auth", "SetExternalToken", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Auth.SetExternalToken", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Auth

	res, err = target.SetExternalToken(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Auth.SetExternalToken returned nil, nil")
	}
	return
}

type wrappedBuilds struct {
	c *auth.Config
}

func (s wrappedBuilds) Get(ctx context.Context, param *sourcegraph.BuildSpec) (res *sourcegraph.Build, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "Get", param)
	defer func() {
		trace.After(ctx, "Builds", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Builds.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.Get returned nil, nil")
	}
	return
}

func (s wrappedBuilds) GetRepoBuild(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *sourcegraph.Build, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "GetRepoBuild", param)
	defer func() {
		trace.After(ctx, "Builds", "GetRepoBuild", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Builds.GetRepoBuild", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetRepoBuild(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.GetRepoBuild returned nil, nil")
	}
	return
}

func (s wrappedBuilds) List(ctx context.Context, param *sourcegraph.BuildListOptions) (res *sourcegraph.BuildList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "List", param)
	defer func() {
		trace.After(ctx, "Builds", "List", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Builds.List", repoURI)
	if err != nil {
		return
	}

	res, err = federated.CustomBuildsList(ctx, param, local.Services.Builds)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.List returned nil, nil")
	}
	return
}

func (s wrappedBuilds) Create(ctx context.Context, param *sourcegraph.BuildsCreateOp) (res *sourcegraph.Build, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "Create", param)
	defer func() {
		trace.After(ctx, "Builds", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Builds.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.Create returned nil, nil")
	}
	return
}

func (s wrappedBuilds) Update(ctx context.Context, param *sourcegraph.BuildsUpdateOp) (res *sourcegraph.Build, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "Update", param)
	defer func() {
		trace.After(ctx, "Builds", "Update", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Build.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Builds.Update", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Build.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Update(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.Update returned nil, nil")
	}
	return
}

func (s wrappedBuilds) ListBuildTasks(ctx context.Context, param *sourcegraph.BuildsListBuildTasksOp) (res *sourcegraph.BuildTaskList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "ListBuildTasks", param)
	defer func() {
		trace.After(ctx, "Builds", "ListBuildTasks", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Build.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Builds.ListBuildTasks", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Build.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListBuildTasks(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.ListBuildTasks returned nil, nil")
	}
	return
}

func (s wrappedBuilds) CreateTasks(ctx context.Context, param *sourcegraph.BuildsCreateTasksOp) (res *sourcegraph.BuildTaskList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "CreateTasks", param)
	defer func() {
		trace.After(ctx, "Builds", "CreateTasks", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Build.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Builds.CreateTasks", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Build.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.CreateTasks(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.CreateTasks returned nil, nil")
	}
	return
}

func (s wrappedBuilds) UpdateTask(ctx context.Context, param *sourcegraph.BuildsUpdateTaskOp) (res *sourcegraph.BuildTask, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "UpdateTask", param)
	defer func() {
		trace.After(ctx, "Builds", "UpdateTask", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Task.Build.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Builds.UpdateTask", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Task.Build.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.UpdateTask(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.UpdateTask returned nil, nil")
	}
	return
}

func (s wrappedBuilds) GetTaskLog(ctx context.Context, param *sourcegraph.BuildsGetTaskLogOp) (res *sourcegraph.LogEntries, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "GetTaskLog", param)
	defer func() {
		trace.After(ctx, "Builds", "GetTaskLog", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Task.Build.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Builds.GetTaskLog", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Task.Build.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Builds(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetTaskLog(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.GetTaskLog returned nil, nil")
	}
	return
}

func (s wrappedBuilds) DequeueNext(ctx context.Context, param *sourcegraph.BuildsDequeueNextOp) (res *sourcegraph.Build, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Builds", "DequeueNext", param)
	defer func() {
		trace.After(ctx, "Builds", "DequeueNext", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "admin", "Builds.DequeueNext", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Builds

	res, err = target.DequeueNext(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Builds.DequeueNext returned nil, nil")
	}
	return
}

type wrappedChangesets struct {
	c *auth.Config
}

func (s wrappedChangesets) Create(ctx context.Context, param *sourcegraph.ChangesetCreateOp) (res *sourcegraph.Changeset, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "Create", param)
	defer func() {
		trace.After(ctx, "Changesets", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Changesets.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.Create returned nil, nil")
	}
	return
}

func (s wrappedChangesets) Get(ctx context.Context, param *sourcegraph.ChangesetGetOp) (res *sourcegraph.Changeset, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "Get", param)
	defer func() {
		trace.After(ctx, "Changesets", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Spec.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Changesets.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.Get returned nil, nil")
	}
	return
}

func (s wrappedChangesets) List(ctx context.Context, param *sourcegraph.ChangesetListOp) (res *sourcegraph.ChangesetList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "List", param)
	defer func() {
		trace.After(ctx, "Changesets", "List", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Changesets.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.List returned nil, nil")
	}
	return
}

func (s wrappedChangesets) Update(ctx context.Context, param *sourcegraph.ChangesetUpdateOp) (res *sourcegraph.ChangesetEvent, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "Update", param)
	defer func() {
		trace.After(ctx, "Changesets", "Update", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Changesets.Update", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.Update(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.Update returned nil, nil")
	}
	return
}

func (s wrappedChangesets) Merge(ctx context.Context, param *sourcegraph.ChangesetMergeOp) (res *sourcegraph.ChangesetEvent, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "Merge", param)
	defer func() {
		trace.After(ctx, "Changesets", "Merge", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Changesets.Merge", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.Merge(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.Merge returned nil, nil")
	}
	return
}

func (s wrappedChangesets) UpdateAffected(ctx context.Context, param *sourcegraph.ChangesetUpdateAffectedOp) (res *sourcegraph.ChangesetEventList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "UpdateAffected", param)
	defer func() {
		trace.After(ctx, "Changesets", "UpdateAffected", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Changesets.UpdateAffected", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.UpdateAffected(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.UpdateAffected returned nil, nil")
	}
	return
}

func (s wrappedChangesets) CreateReview(ctx context.Context, param *sourcegraph.ChangesetCreateReviewOp) (res *sourcegraph.ChangesetReview, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "CreateReview", param)
	defer func() {
		trace.After(ctx, "Changesets", "CreateReview", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Changesets.CreateReview", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.CreateReview(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.CreateReview returned nil, nil")
	}
	return
}

func (s wrappedChangesets) ListReviews(ctx context.Context, param *sourcegraph.ChangesetListReviewsOp) (res *sourcegraph.ChangesetReviewList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "ListReviews", param)
	defer func() {
		trace.After(ctx, "Changesets", "ListReviews", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Changesets.ListReviews", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.ListReviews(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.ListReviews returned nil, nil")
	}
	return
}

func (s wrappedChangesets) ListEvents(ctx context.Context, param *sourcegraph.ChangesetSpec) (res *sourcegraph.ChangesetEventList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Changesets", "ListEvents", param)
	defer func() {
		trace.After(ctx, "Changesets", "ListEvents", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Changesets.ListEvents", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Changesets

	res, err = target.ListEvents(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Changesets.ListEvents returned nil, nil")
	}
	return
}

type wrappedDefs struct {
	c *auth.Config
}

func (s wrappedDefs) Get(ctx context.Context, param *sourcegraph.DefsGetOp) (res *sourcegraph.Def, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "Get", param)
	defer func() {
		trace.After(ctx, "Defs", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Def.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Defs.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Defs

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Def.Repo)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Defs(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.Get returned nil, nil")
	}
	return
}

func (s wrappedDefs) List(ctx context.Context, param *sourcegraph.DefListOptions) (res *sourcegraph.DefList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "List", param)
	defer func() {
		trace.After(ctx, "Defs", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Defs.List", repoURI)
	if err != nil {
		return
	}

	res, err = federated.CustomDefsList(ctx, param, local.Services.Defs)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.List returned nil, nil")
	}
	return
}

func (s wrappedDefs) ListRefs(ctx context.Context, param *sourcegraph.DefsListRefsOp) (res *sourcegraph.RefList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListRefs", param)
	defer func() {
		trace.After(ctx, "Defs", "ListRefs", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Def.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Defs.ListRefs", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Defs

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Def.Repo)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Defs(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListRefs(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.ListRefs returned nil, nil")
	}
	return
}

func (s wrappedDefs) ListExamples(ctx context.Context, param *sourcegraph.DefsListExamplesOp) (res *sourcegraph.ExampleList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListExamples", param)
	defer func() {
		trace.After(ctx, "Defs", "ListExamples", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Def.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Defs.ListExamples", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Defs

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Def.Repo)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Defs(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListExamples(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.ListExamples returned nil, nil")
	}
	return
}

func (s wrappedDefs) ListAuthors(ctx context.Context, param *sourcegraph.DefsListAuthorsOp) (res *sourcegraph.DefAuthorList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListAuthors", param)
	defer func() {
		trace.After(ctx, "Defs", "ListAuthors", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Def.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Defs.ListAuthors", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Defs

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Def.Repo)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Defs(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListAuthors(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.ListAuthors returned nil, nil")
	}
	return
}

func (s wrappedDefs) ListClients(ctx context.Context, param *sourcegraph.DefsListClientsOp) (res *sourcegraph.DefClientList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Defs", "ListClients", param)
	defer func() {
		trace.After(ctx, "Defs", "ListClients", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Def.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Defs.ListClients", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Defs

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Def.Repo)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Defs(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListClients(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Defs.ListClients returned nil, nil")
	}
	return
}

type wrappedDeltas struct {
	c *auth.Config
}

func (s wrappedDeltas) Get(ctx context.Context, param *sourcegraph.DeltaSpec) (res *sourcegraph.Delta, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "Get", param)
	defer func() {
		trace.After(ctx, "Deltas", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.Get returned nil, nil")
	}
	return
}

func (s wrappedDeltas) ListUnits(ctx context.Context, param *sourcegraph.DeltasListUnitsOp) (res *sourcegraph.UnitDeltaList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "ListUnits", param)
	defer func() {
		trace.After(ctx, "Deltas", "ListUnits", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Ds.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.ListUnits", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Ds.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListUnits(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.ListUnits returned nil, nil")
	}
	return
}

func (s wrappedDeltas) ListDefs(ctx context.Context, param *sourcegraph.DeltasListDefsOp) (res *sourcegraph.DeltaDefs, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "ListDefs", param)
	defer func() {
		trace.After(ctx, "Deltas", "ListDefs", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Ds.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.ListDefs", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Ds.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListDefs(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.ListDefs returned nil, nil")
	}
	return
}

func (s wrappedDeltas) ListFiles(ctx context.Context, param *sourcegraph.DeltasListFilesOp) (res *sourcegraph.DeltaFiles, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "ListFiles", param)
	defer func() {
		trace.After(ctx, "Deltas", "ListFiles", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Ds.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.ListFiles", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Ds.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListFiles(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.ListFiles returned nil, nil")
	}
	return
}

func (s wrappedDeltas) ListAffectedAuthors(ctx context.Context, param *sourcegraph.DeltasListAffectedAuthorsOp) (res *sourcegraph.DeltaAffectedPersonList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "ListAffectedAuthors", param)
	defer func() {
		trace.After(ctx, "Deltas", "ListAffectedAuthors", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Ds.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.ListAffectedAuthors", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Ds.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListAffectedAuthors(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.ListAffectedAuthors returned nil, nil")
	}
	return
}

func (s wrappedDeltas) ListAffectedClients(ctx context.Context, param *sourcegraph.DeltasListAffectedClientsOp) (res *sourcegraph.DeltaAffectedPersonList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Deltas", "ListAffectedClients", param)
	defer func() {
		trace.After(ctx, "Deltas", "ListAffectedClients", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Ds.Base.URI
	}

	err = s.c.Authenticate(ctx, "read", "Deltas.ListAffectedClients", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Deltas

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Ds.Base.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Deltas(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListAffectedClients(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Deltas.ListAffectedClients returned nil, nil")
	}
	return
}

type wrappedGraphUplink struct {
	c *auth.Config
}

func (s wrappedGraphUplink) Push(ctx context.Context, param *sourcegraph.MetricsSnapshot) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "GraphUplink", "Push", param)
	defer func() {
		trace.After(ctx, "GraphUplink", "Push", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "GraphUplink.Push", repoURI)
	if err != nil {
		return
	}

	target := local.Services.GraphUplink

	res, err = target.Push(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "GraphUplink.Push returned nil, nil")
	}
	return
}

func (s wrappedGraphUplink) PushEvents(ctx context.Context, param *sourcegraph.UserEventList) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "GraphUplink", "PushEvents", param)
	defer func() {
		trace.After(ctx, "GraphUplink", "PushEvents", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "GraphUplink.PushEvents", repoURI)
	if err != nil {
		return
	}

	target := local.Services.GraphUplink

	res, err = target.PushEvents(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "GraphUplink.PushEvents returned nil, nil")
	}
	return
}

type wrappedMarkdown struct {
	c *auth.Config
}

func (s wrappedMarkdown) Render(ctx context.Context, param *sourcegraph.MarkdownRenderOp) (res *sourcegraph.MarkdownData, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Markdown", "Render", param)
	defer func() {
		trace.After(ctx, "Markdown", "Render", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Markdown.Render", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Markdown

	res, err = target.Render(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Markdown.Render returned nil, nil")
	}
	return
}

type wrappedMeta struct {
	c *auth.Config
}

func (s wrappedMeta) Status(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.ServerStatus, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Meta", "Status", param)
	defer func() {
		trace.After(ctx, "Meta", "Status", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Meta.Status", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Meta

	res, err = target.Status(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Meta.Status returned nil, nil")
	}
	return
}

func (s wrappedMeta) Config(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.ServerConfig, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Meta", "Config", param)
	defer func() {
		trace.After(ctx, "Meta", "Config", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "Meta.Config", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Meta

	res, err = target.Config(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Meta.Config returned nil, nil")
	}
	return
}

type wrappedMirrorRepos struct {
	c *auth.Config
}

func (s wrappedMirrorRepos) RefreshVCS(ctx context.Context, param *sourcegraph.MirrorReposRefreshVCSOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirrorRepos", "RefreshVCS", param)
	defer func() {
		trace.After(ctx, "MirrorRepos", "RefreshVCS", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "MirrorRepos.RefreshVCS", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirrorRepos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.MirrorRepos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.RefreshVCS(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirrorRepos.RefreshVCS returned nil, nil")
	}
	return
}

func (s wrappedMirrorRepos) GetUserData(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.UserMirrorData, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirrorRepos", "GetUserData", param)
	defer func() {
		trace.After(ctx, "MirrorRepos", "GetUserData", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "MirrorRepos.GetUserData", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirrorRepos

	res, err = target.GetUserData(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirrorRepos.GetUserData returned nil, nil")
	}
	return
}

func (s wrappedMirrorRepos) AddToWaitlist(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.WaitlistState, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirrorRepos", "AddToWaitlist", param)
	defer func() {
		trace.After(ctx, "MirrorRepos", "AddToWaitlist", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "MirrorRepos.AddToWaitlist", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirrorRepos

	res, err = target.AddToWaitlist(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirrorRepos.AddToWaitlist returned nil, nil")
	}
	return
}

type wrappedMirroredRepoSSHKeys struct {
	c *auth.Config
}

func (s wrappedMirroredRepoSSHKeys) Create(ctx context.Context, param *sourcegraph.MirroredRepoSSHKeysCreateOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirroredRepoSSHKeys", "Create", param)
	defer func() {
		trace.After(ctx, "MirroredRepoSSHKeys", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "MirroredRepoSSHKeys.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirroredRepoSSHKeys

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirroredRepoSSHKeys.Create returned nil, nil")
	}
	return
}

func (s wrappedMirroredRepoSSHKeys) Get(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.SSHPrivateKey, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirroredRepoSSHKeys", "Get", param)
	defer func() {
		trace.After(ctx, "MirroredRepoSSHKeys", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "MirroredRepoSSHKeys.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirroredRepoSSHKeys

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirroredRepoSSHKeys.Get returned nil, nil")
	}
	return
}

func (s wrappedMirroredRepoSSHKeys) Delete(ctx context.Context, param *sourcegraph.RepoSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "MirroredRepoSSHKeys", "Delete", param)
	defer func() {
		trace.After(ctx, "MirroredRepoSSHKeys", "Delete", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "write", "MirroredRepoSSHKeys.Delete", repoURI)
	if err != nil {
		return
	}

	target := local.Services.MirroredRepoSSHKeys

	res, err = target.Delete(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "MirroredRepoSSHKeys.Delete returned nil, nil")
	}
	return
}

type wrappedNotify struct {
	c *auth.Config
}

func (s wrappedNotify) GenericEvent(ctx context.Context, param *sourcegraph.NotifyGenericEvent) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Notify", "GenericEvent", param)
	defer func() {
		trace.After(ctx, "Notify", "GenericEvent", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Notify.GenericEvent", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Notify

	res, err = target.GenericEvent(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Notify.GenericEvent returned nil, nil")
	}
	return
}

type wrappedOrgs struct {
	c *auth.Config
}

func (s wrappedOrgs) Get(ctx context.Context, param *sourcegraph.OrgSpec) (res *sourcegraph.Org, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Orgs", "Get", param)
	defer func() {
		trace.After(ctx, "Orgs", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Orgs.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Orgs

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Orgs.Get returned nil, nil")
	}
	return
}

func (s wrappedOrgs) List(ctx context.Context, param *sourcegraph.OrgsListOp) (res *sourcegraph.OrgList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Orgs", "List", param)
	defer func() {
		trace.After(ctx, "Orgs", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Orgs.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Orgs

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Orgs.List returned nil, nil")
	}
	return
}

func (s wrappedOrgs) ListMembers(ctx context.Context, param *sourcegraph.OrgsListMembersOp) (res *sourcegraph.UserList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Orgs", "ListMembers", param)
	defer func() {
		trace.After(ctx, "Orgs", "ListMembers", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Orgs.ListMembers", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Orgs

	res, err = target.ListMembers(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Orgs.ListMembers returned nil, nil")
	}
	return
}

type wrappedPeople struct {
	c *auth.Config
}

func (s wrappedPeople) Get(ctx context.Context, param *sourcegraph.PersonSpec) (res *sourcegraph.Person, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "People", "Get", param)
	defer func() {
		trace.After(ctx, "People", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "People.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.People

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "People.Get returned nil, nil")
	}
	return
}

type wrappedRegisteredClients struct {
	c *auth.Config
}

func (s wrappedRegisteredClients) Get(ctx context.Context, param *sourcegraph.RegisteredClientSpec) (res *sourcegraph.RegisteredClient, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "Get", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.Get returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) GetCurrent(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.RegisteredClient, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "GetCurrent", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "GetCurrent", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.GetCurrent", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.GetCurrent(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.GetCurrent returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) Create(ctx context.Context, param *sourcegraph.RegisteredClient) (res *sourcegraph.RegisteredClient, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "Create", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.Create returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) Update(ctx context.Context, param *sourcegraph.RegisteredClient) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "Update", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "Update", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.Update", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.Update(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.Update returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) Delete(ctx context.Context, param *sourcegraph.RegisteredClientSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "Delete", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "Delete", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.Delete", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.Delete(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.Delete returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) List(ctx context.Context, param *sourcegraph.RegisteredClientListOptions) (res *sourcegraph.RegisteredClientList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "List", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.List returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) GetUserPermissions(ctx context.Context, param *sourcegraph.UserPermissionsOptions) (res *sourcegraph.UserPermissions, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "GetUserPermissions", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "GetUserPermissions", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.GetUserPermissions", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.GetUserPermissions(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.GetUserPermissions returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) SetUserPermissions(ctx context.Context, param *sourcegraph.UserPermissions) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "SetUserPermissions", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "SetUserPermissions", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.SetUserPermissions", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.SetUserPermissions(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.SetUserPermissions returned nil, nil")
	}
	return
}

func (s wrappedRegisteredClients) ListUserPermissions(ctx context.Context, param *sourcegraph.RegisteredClientSpec) (res *sourcegraph.UserPermissionsList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RegisteredClients", "ListUserPermissions", param)
	defer func() {
		trace.After(ctx, "RegisteredClients", "ListUserPermissions", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "none", "RegisteredClients.ListUserPermissions", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RegisteredClients

	res, err = target.ListUserPermissions(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RegisteredClients.ListUserPermissions returned nil, nil")
	}
	return
}

type wrappedRepoBadges struct {
	c *auth.Config
}

func (s wrappedRepoBadges) ListBadges(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.BadgeList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoBadges", "ListBadges", param)
	defer func() {
		trace.After(ctx, "RepoBadges", "ListBadges", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoBadges.ListBadges", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoBadges

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoBadges(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListBadges(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoBadges.ListBadges returned nil, nil")
	}
	return
}

func (s wrappedRepoBadges) ListCounters(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.CounterList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoBadges", "ListCounters", param)
	defer func() {
		trace.After(ctx, "RepoBadges", "ListCounters", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoBadges.ListCounters", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoBadges

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoBadges(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListCounters(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoBadges.ListCounters returned nil, nil")
	}
	return
}

func (s wrappedRepoBadges) RecordHit(ctx context.Context, param *sourcegraph.RepoSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoBadges", "RecordHit", param)
	defer func() {
		trace.After(ctx, "RepoBadges", "RecordHit", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoBadges.RecordHit", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoBadges

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoBadges(fedCtx)
		ctx = fedCtx
	}

	res, err = target.RecordHit(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoBadges.RecordHit returned nil, nil")
	}
	return
}

func (s wrappedRepoBadges) CountHits(ctx context.Context, param *sourcegraph.RepoBadgesCountHitsOp) (res *sourcegraph.RepoBadgesCountHitsResult, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoBadges", "CountHits", param)
	defer func() {
		trace.After(ctx, "RepoBadges", "CountHits", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoBadges.CountHits", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoBadges

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoBadges(fedCtx)
		ctx = fedCtx
	}

	res, err = target.CountHits(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoBadges.CountHits returned nil, nil")
	}
	return
}

type wrappedRepoStatuses struct {
	c *auth.Config
}

func (s wrappedRepoStatuses) GetCombined(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *sourcegraph.CombinedStatus, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoStatuses", "GetCombined", param)
	defer func() {
		trace.After(ctx, "RepoStatuses", "GetCombined", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoStatuses.GetCombined", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoStatuses

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoStatuses(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetCombined(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoStatuses.GetCombined returned nil, nil")
	}
	return
}

func (s wrappedRepoStatuses) Create(ctx context.Context, param *sourcegraph.RepoStatusesCreateOp) (res *sourcegraph.RepoStatus, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoStatuses", "Create", param)
	defer func() {
		trace.After(ctx, "RepoStatuses", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "RepoStatuses.Create", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoStatuses

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoStatuses(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Create(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoStatuses.Create returned nil, nil")
	}
	return
}

type wrappedRepoTree struct {
	c *auth.Config
}

func (s wrappedRepoTree) Get(ctx context.Context, param *sourcegraph.RepoTreeGetOp) (res *sourcegraph.TreeEntry, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "Get", param)
	defer func() {
		trace.After(ctx, "RepoTree", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Entry.RepoRev.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoTree.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoTree

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Entry.RepoRev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoTree(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoTree.Get returned nil, nil")
	}
	return
}

func (s wrappedRepoTree) Search(ctx context.Context, param *sourcegraph.RepoTreeSearchOp) (res *sourcegraph.VCSSearchResultList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "Search", param)
	defer func() {
		trace.After(ctx, "RepoTree", "Search", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Rev.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoTree.Search", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoTree

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Rev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoTree(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Search(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoTree.Search returned nil, nil")
	}
	return
}

func (s wrappedRepoTree) List(ctx context.Context, param *sourcegraph.RepoTreeListOp) (res *sourcegraph.RepoTreeListResult, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "RepoTree", "List", param)
	defer func() {
		trace.After(ctx, "RepoTree", "List", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Rev.URI
	}

	err = s.c.Authenticate(ctx, "read", "RepoTree.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.RepoTree

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Rev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.RepoTree(fedCtx)
		ctx = fedCtx
	}

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "RepoTree.List returned nil, nil")
	}
	return
}

type wrappedRepos struct {
	c *auth.Config
}

func (s wrappedRepos) Get(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.Repo, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Get", param)
	defer func() {
		trace.After(ctx, "Repos", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.Get", repoURI)
	if err != nil {
		return
	}

	res, err = federated.CustomReposGet(ctx, param, local.Services.Repos)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.Get returned nil, nil")
	}
	return
}

func (s wrappedRepos) List(ctx context.Context, param *sourcegraph.RepoListOptions) (res *sourcegraph.RepoList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "List", param)
	defer func() {
		trace.After(ctx, "Repos", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Repos.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.List returned nil, nil")
	}
	return
}

func (s wrappedRepos) Create(ctx context.Context, param *sourcegraph.ReposCreateOp) (res *sourcegraph.Repo, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Create", param)
	defer func() {
		trace.After(ctx, "Repos", "Create", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "write", "Repos.Create", repoURI)
	if err != nil {
		return
	}

	res, err = federated.CustomReposCreate(ctx, param, local.Services.Repos)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.Create returned nil, nil")
	}
	return
}

func (s wrappedRepos) Update(ctx context.Context, param *sourcegraph.ReposUpdateOp) (res *sourcegraph.Repo, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Update", param)
	defer func() {
		trace.After(ctx, "Repos", "Update", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Repos.Update", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Update(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.Update returned nil, nil")
	}
	return
}

func (s wrappedRepos) Delete(ctx context.Context, param *sourcegraph.RepoSpec) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "Delete", param)
	defer func() {
		trace.After(ctx, "Repos", "Delete", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "write", "Repos.Delete", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Delete(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.Delete returned nil, nil")
	}
	return
}

func (s wrappedRepos) GetReadme(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *sourcegraph.Readme, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetReadme", param)
	defer func() {
		trace.After(ctx, "Repos", "GetReadme", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.GetReadme", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetReadme(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.GetReadme returned nil, nil")
	}
	return
}

func (s wrappedRepos) GetConfig(ctx context.Context, param *sourcegraph.RepoSpec) (res *sourcegraph.RepoConfig, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetConfig", param)
	defer func() {
		trace.After(ctx, "Repos", "GetConfig", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.GetConfig", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetConfig(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.GetConfig returned nil, nil")
	}
	return
}

func (s wrappedRepos) GetCommit(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *vcs.Commit, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetCommit", param)
	defer func() {
		trace.After(ctx, "Repos", "GetCommit", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.GetCommit", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetCommit(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.GetCommit returned nil, nil")
	}
	return
}

func (s wrappedRepos) ListCommits(ctx context.Context, param *sourcegraph.ReposListCommitsOp) (res *sourcegraph.CommitList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListCommits", param)
	defer func() {
		trace.After(ctx, "Repos", "ListCommits", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.ListCommits", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListCommits(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.ListCommits returned nil, nil")
	}
	return
}

func (s wrappedRepos) ListBranches(ctx context.Context, param *sourcegraph.ReposListBranchesOp) (res *sourcegraph.BranchList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListBranches", param)
	defer func() {
		trace.After(ctx, "Repos", "ListBranches", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.ListBranches", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListBranches(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.ListBranches returned nil, nil")
	}
	return
}

func (s wrappedRepos) ListTags(ctx context.Context, param *sourcegraph.ReposListTagsOp) (res *sourcegraph.TagList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListTags", param)
	defer func() {
		trace.After(ctx, "Repos", "ListTags", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.ListTags", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListTags(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.ListTags returned nil, nil")
	}
	return
}

func (s wrappedRepos) ListCommitters(ctx context.Context, param *sourcegraph.ReposListCommittersOp) (res *sourcegraph.CommitterList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ListCommitters", param)
	defer func() {
		trace.After(ctx, "Repos", "ListCommitters", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.ListCommitters", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ListCommitters(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.ListCommitters returned nil, nil")
	}
	return
}

func (s wrappedRepos) GetSrclibDataVersionForPath(ctx context.Context, param *sourcegraph.TreeEntrySpec) (res *sourcegraph.SrclibDataVersion, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetSrclibDataVersionForPath", param)
	defer func() {
		trace.After(ctx, "Repos", "GetSrclibDataVersionForPath", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.RepoRev.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.GetSrclibDataVersionForPath", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.RepoRev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetSrclibDataVersionForPath(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.GetSrclibDataVersionForPath returned nil, nil")
	}
	return
}

func (s wrappedRepos) ConfigureApp(ctx context.Context, param *sourcegraph.RepoConfigureAppOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "ConfigureApp", param)
	defer func() {
		trace.After(ctx, "Repos", "ConfigureApp", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Repo.URI
	}

	err = s.c.Authenticate(ctx, "write", "Repos.ConfigureApp", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.Repo.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.ConfigureApp(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.ConfigureApp returned nil, nil")
	}
	return
}

func (s wrappedRepos) GetInventory(ctx context.Context, param *sourcegraph.RepoRevSpec) (res *inventory.Inventory, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Repos", "GetInventory", param)
	defer func() {
		trace.After(ctx, "Repos", "GetInventory", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Repos.GetInventory", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Repos

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Repos(fedCtx)
		ctx = fedCtx
	}

	res, err = target.GetInventory(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Repos.GetInventory returned nil, nil")
	}
	return
}

type wrappedSearch struct {
	c *auth.Config
}

func (s wrappedSearch) SearchTokens(ctx context.Context, param *sourcegraph.TokenSearchOptions) (res *sourcegraph.DefList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Search", "SearchTokens", param)
	defer func() {
		trace.After(ctx, "Search", "SearchTokens", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.RepoRev.URI
	}

	err = s.c.Authenticate(ctx, "read", "Search.SearchTokens", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Search

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.RepoRev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Search(fedCtx)
		ctx = fedCtx
	}

	res, err = target.SearchTokens(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Search.SearchTokens returned nil, nil")
	}
	return
}

func (s wrappedSearch) SearchText(ctx context.Context, param *sourcegraph.TextSearchOptions) (res *sourcegraph.VCSSearchResultList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Search", "SearchText", param)
	defer func() {
		trace.After(ctx, "Search", "SearchText", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.RepoRev.URI
	}

	err = s.c.Authenticate(ctx, "read", "Search.SearchText", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Search

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.RepoRev.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Search(fedCtx)
		ctx = fedCtx
	}

	res, err = target.SearchText(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Search.SearchText returned nil, nil")
	}
	return
}

type wrappedStorage struct {
	c *auth.Config
}

func (s wrappedStorage) Get(ctx context.Context, param *sourcegraph.StorageKey) (res *sourcegraph.StorageValue, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "Get", param)
	defer func() {
		trace.After(ctx, "Storage", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Storage.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.Get returned nil, nil")
	}
	return
}

func (s wrappedStorage) Put(ctx context.Context, param *sourcegraph.StoragePutOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "Put", param)
	defer func() {
		trace.After(ctx, "Storage", "Put", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Key.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "write", "Storage.Put", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.Put(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.Put returned nil, nil")
	}
	return
}

func (s wrappedStorage) PutNoOverwrite(ctx context.Context, param *sourcegraph.StoragePutOp) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "PutNoOverwrite", param)
	defer func() {
		trace.After(ctx, "Storage", "PutNoOverwrite", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Key.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "write", "Storage.PutNoOverwrite", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.PutNoOverwrite(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.PutNoOverwrite returned nil, nil")
	}
	return
}

func (s wrappedStorage) Delete(ctx context.Context, param *sourcegraph.StorageKey) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "Delete", param)
	defer func() {
		trace.After(ctx, "Storage", "Delete", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "write", "Storage.Delete", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.Delete(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.Delete returned nil, nil")
	}
	return
}

func (s wrappedStorage) Exists(ctx context.Context, param *sourcegraph.StorageKey) (res *sourcegraph.StorageExists, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "Exists", param)
	defer func() {
		trace.After(ctx, "Storage", "Exists", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Storage.Exists", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.Exists(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.Exists returned nil, nil")
	}
	return
}

func (s wrappedStorage) List(ctx context.Context, param *sourcegraph.StorageKey) (res *sourcegraph.StorageList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Storage", "List", param)
	defer func() {
		trace.After(ctx, "Storage", "List", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.Bucket.Repo
	}

	err = s.c.Authenticate(ctx, "read", "Storage.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Storage

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Storage.List returned nil, nil")
	}
	return
}

type wrappedUnits struct {
	c *auth.Config
}

func (s wrappedUnits) Get(ctx context.Context, param *sourcegraph.UnitSpec) (res *unit.RepoSourceUnit, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Units", "Get", param)
	defer func() {
		trace.After(ctx, "Units", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	if param != nil {
		repoURI = param.URI
	}

	err = s.c.Authenticate(ctx, "read", "Units.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Units

	var fedCtx context.Context
	fedCtx, err = federated.RepoContext(ctx, &param.URI)
	if err != nil {
		return
	}
	if fedCtx != nil {
		target = svc.Units(fedCtx)
		ctx = fedCtx
	}

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Units.Get returned nil, nil")
	}
	return
}

func (s wrappedUnits) List(ctx context.Context, param *sourcegraph.UnitListOptions) (res *sourcegraph.RepoSourceUnitList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Units", "List", param)
	defer func() {
		trace.After(ctx, "Units", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Units.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Units

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Units.List returned nil, nil")
	}
	return
}

type wrappedUserKeys struct {
	c *auth.Config
}

func (s wrappedUserKeys) AddKey(ctx context.Context, param *sourcegraph.SSHPublicKey) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "UserKeys", "AddKey", param)
	defer func() {
		trace.After(ctx, "UserKeys", "AddKey", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "UserKeys.AddKey", repoURI)
	if err != nil {
		return
	}

	target := local.Services.UserKeys

	res, err = target.AddKey(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "UserKeys.AddKey returned nil, nil")
	}
	return
}

func (s wrappedUserKeys) LookupUser(ctx context.Context, param *sourcegraph.SSHPublicKey) (res *sourcegraph.UserSpec, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "UserKeys", "LookupUser", param)
	defer func() {
		trace.After(ctx, "UserKeys", "LookupUser", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "UserKeys.LookupUser", repoURI)
	if err != nil {
		return
	}

	target := local.Services.UserKeys

	res, err = target.LookupUser(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "UserKeys.LookupUser returned nil, nil")
	}
	return
}

func (s wrappedUserKeys) DeleteKey(ctx context.Context, param *sourcegraph.SSHPublicKey) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "UserKeys", "DeleteKey", param)
	defer func() {
		trace.After(ctx, "UserKeys", "DeleteKey", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "UserKeys.DeleteKey", repoURI)
	if err != nil {
		return
	}

	target := local.Services.UserKeys

	res, err = target.DeleteKey(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "UserKeys.DeleteKey returned nil, nil")
	}
	return
}

func (s wrappedUserKeys) ListKeys(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.SSHKeyList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "UserKeys", "ListKeys", param)
	defer func() {
		trace.After(ctx, "UserKeys", "ListKeys", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "UserKeys.ListKeys", repoURI)
	if err != nil {
		return
	}

	target := local.Services.UserKeys

	res, err = target.ListKeys(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "UserKeys.ListKeys returned nil, nil")
	}
	return
}

func (s wrappedUserKeys) DeleteAllKeys(ctx context.Context, param *pbtypes.Void) (res *pbtypes.Void, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "UserKeys", "DeleteAllKeys", param)
	defer func() {
		trace.After(ctx, "UserKeys", "DeleteAllKeys", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "UserKeys.DeleteAllKeys", repoURI)
	if err != nil {
		return
	}

	target := local.Services.UserKeys

	res, err = target.DeleteAllKeys(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "UserKeys.DeleteAllKeys returned nil, nil")
	}
	return
}

type wrappedUsers struct {
	c *auth.Config
}

func (s wrappedUsers) Get(ctx context.Context, param *sourcegraph.UserSpec) (res *sourcegraph.User, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "Get", param)
	defer func() {
		trace.After(ctx, "Users", "Get", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Users.Get", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.Get(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.Get returned nil, nil")
	}
	return
}

func (s wrappedUsers) GetWithEmail(ctx context.Context, param *sourcegraph.EmailAddr) (res *sourcegraph.User, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "GetWithEmail", param)
	defer func() {
		trace.After(ctx, "Users", "GetWithEmail", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Users.GetWithEmail", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.GetWithEmail(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.GetWithEmail returned nil, nil")
	}
	return
}

func (s wrappedUsers) ListEmails(ctx context.Context, param *sourcegraph.UserSpec) (res *sourcegraph.EmailAddrList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "ListEmails", param)
	defer func() {
		trace.After(ctx, "Users", "ListEmails", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Users.ListEmails", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.ListEmails(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.ListEmails returned nil, nil")
	}
	return
}

func (s wrappedUsers) List(ctx context.Context, param *sourcegraph.UsersListOptions) (res *sourcegraph.UserList, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "List", param)
	defer func() {
		trace.After(ctx, "Users", "List", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "write", "Users.List", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.List(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.List returned nil, nil")
	}
	return
}

func (s wrappedUsers) ListTeammates(ctx context.Context, param *sourcegraph.UserSpec) (res *sourcegraph.Teammates, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "ListTeammates", param)
	defer func() {
		trace.After(ctx, "Users", "ListTeammates", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Users.ListTeammates", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.ListTeammates(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.ListTeammates returned nil, nil")
	}
	return
}

func (s wrappedUsers) Count(ctx context.Context, param *pbtypes.Void) (res *sourcegraph.UserCount, err error) {
	start := time.Now()
	ctx = trace.Before(ctx, "Users", "Count", param)
	defer func() {
		trace.After(ctx, "Users", "Count", param, err, time.Since(start))
	}()

	var repoURI string

	err = s.c.Authenticate(ctx, "read", "Users.Count", repoURI)
	if err != nil {
		return
	}

	target := local.Services.Users

	res, err = target.Count(ctx, param)

	if res == nil && err == nil {
		err = grpc.Errorf(codes.Internal, "Users.Count returned nil, nil")
	}
	return
}
