// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"log"
	"text/template"

	"src.sourcegraph.com/sourcegraph/gen"
	"src.sourcegraph.com/sourcegraph/server/accesscontrol/accesslevels"
)

func main() {
	svcs := []string{
		"../../../../go-sourcegraph/sourcegraph/sourcegraph.pb.go",
		"../../../../Godeps/_workspace/src/sourcegraph.com/sourcegraph/srclib/store/pb/srcstore.pb.go",
		"../../../../gitserver/gitpb/git_transport.pb.go",
	}
	gen.Generate("inner_middleware.go", tmpl, svcs, nil, "")
}

func serviceIsFederated(x *gen.Service) bool {
	switch x.Name {
	case "Builds", "Defs", "Deltas", "MirrorRepos", "RepoBadges", "RepoStatuses", "RepoTree", "Repos", "Search", "Units", "Users":
		return true
	}
	return false
}

func methodHasCustomFederation(x gen.Service, method string) bool {
	switch x.Name {
	case "Builds":
		return method == "List"
	case "Defs":
		return method == "List"
	case "Repos":
		switch method {
		case "Create", "Get":
			return true
		default:
			return false
		}
	default:
		return false
	}
}

func repoURIExpr(m *gen.Method) string {
	expr := gen.RepoURIExpr(ast.NewIdent("param"), m.Type.Params.List[1].Type)
	if expr == nil {
		return ""
	}
	return gen.AstString(expr)
}

func userSpecExpr(m *gen.Method) string {
	expr := gen.UserSpecExpr(ast.NewIdent("param"), m.Type.Params.List[1].Type)
	if expr == nil {
		return ""
	}
	return gen.AstString(expr)
}

func methodAccessLevel(serviceName, methodName string) string {
	fullMethodName := fmt.Sprintf("%s.%s", serviceName, methodName)
	accessLevel := accesslevels.GetMethodAccessLevel(fullMethodName)
	if accessLevel == "" {
		log.Fatalf("gRPC method %s.%s does not have an access level defined. Please define an access level in server/accesscontrol/grpc_perms.go.", serviceName, methodName)
	}
	return accessLevel
}

var tmpl = template.Must(template.New("").Delims("<<<", ">>>").Funcs(template.FuncMap{
	"serviceIsFederated":        serviceIsFederated,
	"methodHasCustomFederation": methodHasCustomFederation,
	"repoURIExpr":               repoURIExpr,
	"userSpecExpr":              userSpecExpr,
	"methodAccessLevel":         methodAccessLevel,
}).Parse(`// GENERATED CODE - DO NOT EDIT!
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package inner

import (
	"time"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"src.sourcegraph.com/sourcegraph/pkg/vcs"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sourcegraph/srclib/unit"
	"sourcegraph.com/sqs/pbtypes"
	"src.sourcegraph.com/sourcegraph/gitserver/gitpb"
	"src.sourcegraph.com/sourcegraph/go-sourcegraph/sourcegraph"
	"src.sourcegraph.com/sourcegraph/pkg/inventory"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/auth"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/federated"
	"src.sourcegraph.com/sourcegraph/server/internal/middleware/inner/trace"
	"src.sourcegraph.com/sourcegraph/server/local"
	"src.sourcegraph.com/sourcegraph/svc"
)

// Services returns the local services wrapped with auth, federation, etc.
func Services(c *auth.Config) svc.Services {
	return svc.Services{
		<<<range .>>>
			<<<.Name>>>: wrapped<<<.Name>>>{c},
		<<<end>>>
	}
}

<<<range .>>>
	type wrapped<<<.Name>>> struct{
		c *auth.Config
	}

  <<<$service := .>>>
	<<<range .Methods>>>
		func (s wrapped<<<$service.Name>>>) <<<.Name>>>(ctx context.Context, param *<<<.ParamType>>>) (res *<<<.ResultType>>>, err error) {
			start := time.Now()
			ctx = trace.Before(ctx, "<<<$service.Name>>>", "<<<.Name>>>", param)
			defer func(){
		  	trace.After(ctx, "<<<$service.Name>>>", "<<<.Name>>>", param, err, time.Since(start))
			}()

			<<<$methodAccessLevel := methodAccessLevel $service.Name .Name>>>
			<<<$repoURIExpr := repoURIExpr .>>>
			var repoURI string
			<<<if (ne $repoURIExpr "")>>>
			if param != nil {
				repoURI = <<<$repoURIExpr>>>
			}
			<<<end>>>
			err = s.c.Authenticate(ctx, "<<<$methodAccessLevel>>>", "<<<$service.Name>>>.<<<.Name>>>", repoURI)
			if err != nil {
				return
			}

			<<<if methodHasCustomFederation $service .Name>>>
				res, err = federated.Custom<<<$service.Name>>><<<.Name>>>(ctx, param, local.Services.<<<$service.Name>>>)
			<<<else>>>
				target := local.Services.<<<$service.Name>>>
				<<<$userSpecExpr := userSpecExpr .>>>
				<<<if and (serviceIsFederated $service) (ne $repoURIExpr "")>>>
					var fedCtx context.Context
					fedCtx, err = federated.RepoContext(ctx, &<<<$repoURIExpr>>>)
					if err != nil {
						return
					}
					if fedCtx != nil {
						target = svc.<<<$service.Name>>>(fedCtx)
						ctx = fedCtx
					}
				<<<end>>>

				res, err = target.<<<.Name>>>(ctx, param)
			<<<end>>>
			if res == nil && err == nil {
				err = grpc.Errorf(codes.Internal, "<<<$service.Name>>>.<<<.Name>>> returned nil, nil")
			}
			return
		}
	<<<end>>>
<<<end>>>
`))
