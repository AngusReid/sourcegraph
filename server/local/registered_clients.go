package local

import (
	"fmt"
	"net/url"
	"os"
	"time"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"sourcegraph.com/sqs/pbtypes"
	authpkg "src.sourcegraph.com/sourcegraph/auth"
	"src.sourcegraph.com/sourcegraph/auth/idkey"
	"src.sourcegraph.com/sourcegraph/events"
	"src.sourcegraph.com/sourcegraph/fed"
	"src.sourcegraph.com/sourcegraph/go-sourcegraph/sourcegraph"
	"src.sourcegraph.com/sourcegraph/pkg/oauth2util"
	"src.sourcegraph.com/sourcegraph/store"
	"src.sourcegraph.com/sourcegraph/util/metricutil"
	"src.sourcegraph.com/sourcegraph/util/randstring"
)

var RegisteredClients sourcegraph.RegisteredClientsServer = &registeredClients{}

type registeredClients struct{}

var _ sourcegraph.RegisteredClientsServer = (*registeredClients)(nil)

func (s *registeredClients) Get(ctx context.Context, client *sourcegraph.RegisteredClientSpec) (*sourcegraph.RegisteredClient, error) {
	// Catch a common programming mistake: trying to look up a host's
	// client ID in its own list of registered clients. It doesn't
	// make any sense for a host to register with itself as a
	// client. This means there's a bug somewhere upstream.
	if k := idkey.FromContext(ctx); k.ID == client.ID {
		msg := fmt.Sprintf("attempted to look up this server's own client ID %s (almost certainly indicates the presence of a bug)", k.ID)
		if os.Getenv("DEBUG") == "" {
			return nil, grpc.Errorf(codes.InvalidArgument, "%s", msg)
		}
		panic(msg)
	}

	store, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}
	return store.Get(ctx, *client)
}

func (s *registeredClients) GetCurrent(ctx context.Context, _ *pbtypes.Void) (*sourcegraph.RegisteredClient, error) {
	actor := authpkg.ActorFromContext(ctx)
	if actor.ClientID == "" {
		return nil, grpc.Errorf(codes.NotFound, "RegisteredClients.GetCurrent: no authenticated registered API client")
	}
	if actor.ClientID == idkey.FromContext(ctx).ID {
		return nil, grpc.Errorf(codes.NotFound, "RegisteredClients.GetCurrent: current credentials represent the server itself, which is not a registered client of itself")
	}

	store, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}
	return store.Get(ctx, sourcegraph.RegisteredClientSpec{ID: actor.ClientID})
}

func (s *registeredClients) Create(ctx context.Context, client *sourcegraph.RegisteredClient) (*sourcegraph.RegisteredClient, error) {
	clientStore, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}

	if err := checkRedirectURIs(client); err != nil {
		return nil, err
	}

	if client.ClientSecret != "" {
		return nil, grpc.Errorf(codes.InvalidArgument, "client secret must be empty (it is generated by the server)")
	}

	if client.JWKS == "" {
		// Client ID and secret auth.

		if client.ID != "" {
			return nil, grpc.Errorf(codes.InvalidArgument, "client ID must be empty when using client ID/secret credentials (it is generated by the server)")
		}

		// Generate credentials.
		client.ID = randstring.NewLen(30)
		client.ClientSecret = randstring.NewLen(45)
	} else {
		// JWKS public key auth.

		if client.ID == "" {
			return nil, grpc.Errorf(codes.InvalidArgument, "client ID must be set when using JWKS public keys")
		}

		pubKey, err := idkey.UnmarshalJWKSPublicKey([]byte(client.JWKS))
		if err != nil {
			return nil, err
		}
		fp, err := idkey.Fingerprint(pubKey)
		if err != nil {
			return nil, err
		}
		if fp != client.ID {
			return nil, grpc.Errorf(codes.InvalidArgument, "client ID must be set to public key fingerprint")
		}
	}

	if client.ID == idkey.FromContext(ctx).ID {
		return nil, grpc.Errorf(codes.InvalidArgument, "can't register this server as its own client (ClientID == %q)", client.ID)
	}

	if client.ClientSecret != "" && client.JWKS != "" {
		return nil, grpc.Errorf(codes.InvalidArgument, "client ID/secret and JWKS public key auth schemes are mutually exclusive")
	}

	client.CreatedAt = pbtypes.NewTimestamp(time.Now())
	client.UpdatedAt = client.CreatedAt

	if err := clientStore.Create(ctx, *client); err != nil {
		return nil, err
	}

	metricutil.LogEvent(ctx, &sourcegraph.UserEvent{
		Type:     "notif",
		ClientID: client.ID,
		Service:  "RegisteredClients",
		Method:   "Create",
		URL:      client.ClientName,
		Result:   "success",
	})

	events.Publish(events.ClientRegisterEvent, events.ClientPayload{
		Actor:    authpkg.UserSpecFromContext(ctx),
		ClientID: client.ID,
	})

	return client, nil
}

func (s *registeredClients) Update(ctx context.Context, client *sourcegraph.RegisteredClient) (*pbtypes.Void, error) {
	store, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}

	if err := checkRedirectURIs(client); err != nil {
		return nil, err
	}

	if client.ClientSecret != "" {
		return nil, grpc.Errorf(codes.InvalidArgument, "RegisteredClients.Update of secret is not allowed")
	}

	client.UpdatedAt = pbtypes.NewTimestamp(time.Now())

	if err := store.Update(ctx, *client); err != nil {
		return nil, err
	}

	metricutil.LogEvent(ctx, &sourcegraph.UserEvent{
		Type:     "notif",
		ClientID: client.ID,
		Service:  "RegisteredClients",
		Method:   "Update",
		URL:      client.ClientName,
		Result:   "success",
	})

	events.Publish(events.ClientUpdateEvent, events.ClientPayload{
		Actor:    authpkg.UserSpecFromContext(ctx),
		ClientID: client.ID,
	})
	return &pbtypes.Void{}, nil
}

func (s *registeredClients) Delete(ctx context.Context, client *sourcegraph.RegisteredClientSpec) (*pbtypes.Void, error) {
	store, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}

	if err := store.Delete(ctx, *client); err != nil {
		return nil, err
	}
	return &pbtypes.Void{}, nil
}

func (s *registeredClients) List(ctx context.Context, opt *sourcegraph.RegisteredClientListOptions) (*sourcegraph.RegisteredClientList, error) {
	store, err := registeredClientsOrError(ctx)
	if err != nil {
		return nil, err
	}

	return store.List(ctx, *opt)
}

func registeredClientsOrError(ctx context.Context) (store.RegisteredClients, error) {
	s := store.RegisteredClientsFromContext(ctx)
	if !fed.Config.AllowsClientRegistration() {
		return nil, grpc.Errorf(codes.Unimplemented, "server is not a federation root and therefore does not allow client registration")
	}
	return s, nil
}

func checkRedirectURIs(client *sourcegraph.RegisteredClient) error {
	for _, urlStr := range client.RedirectURIs {
		u, err := url.Parse(urlStr)
		if err != nil {
			return err
		}
		if err := oauth2util.CheckRedirectURI(u); err != nil {
			return err
		}
	}
	return nil
}
