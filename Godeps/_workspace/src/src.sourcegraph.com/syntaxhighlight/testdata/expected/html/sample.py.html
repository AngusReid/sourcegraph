<span class="com"># Copyright (c) 2004 Python Software Foundation.</span><span class="">
</span><span class="com"># All rights reserved.</span><span class="">

</span><span class="com"># Written by Eric Price &lt;eprice at tjhsst.edu&gt;</span><span class="">
</span><span class="com">#    and Facundo Batista &lt;facundo at taniquetil.com.ar&gt;</span><span class="">
</span><span class="com">#    and Raymond Hettinger &lt;python at rcn.com&gt;</span><span class="">
</span><span class="com">#    and Aahz &lt;aahz at pobox.com&gt;</span><span class="">
</span><span class="com">#    and Tim Peters</span><span class="">

</span><span class="com"># This module is currently Py2.3 compatible and should be kept that way</span><span class="">
</span><span class="com"># unless a major compelling advantage arises.  IOW, 2.3 compatibility is</span><span class="">
</span><span class="com"># strongly preferred, but not guaranteed.</span><span class="">

</span><span class="com"># Also, this module should be kept in sync with the latest updates of</span><span class="">
</span><span class="com"># the IBM specification as it evolves.  Those updates will be treated</span><span class="">
</span><span class="com"># as bug fixes (deviation from the spec is a compatibility, usability</span><span class="">
</span><span class="com"># bug) and will be backported.  At this point the spec is stabilizing</span><span class="">
</span><span class="com"># and the updates are becoming fewer, smaller, and less significant.</span><span class="">

</span><span class="str">&#34;&#34;&#34;
This is a Py2.3 implementation of decimal floating point arithmetic based on
the General Decimal Arithmetic Specification:

    http://speleotrove.com/decimal/decarith.html

and IEEE standard 854-1987:

    http://en.wikipedia.org/wiki/IEEE_854-1987

Decimal floating point has finite precision with arbitrarily large bounds.

The purpose of this module is to support arithmetic using familiar
&#34;schoolhouse&#34; rules and to avoid some of the tricky representation
issues associated with binary floating point.  The package is especially
useful for financial applications or for contexts where users have
expectations that are at odds with binary floating point (for instance,
in binary floating point, 1.00 % 0.1 gives 0.09999999999999995 instead
of the expected Decimal(&#39;0.00&#39;) returned by decimal floating point).

Here are some examples of using the decimal module:

&gt;&gt;&gt; from decimal import *
&gt;&gt;&gt; setcontext(ExtendedContext)
&gt;&gt;&gt; Decimal(0)
Decimal(&#39;0&#39;)
&gt;&gt;&gt; Decimal(&#39;1&#39;)
Decimal(&#39;1&#39;)
&gt;&gt;&gt; Decimal(&#39;-.0123&#39;)
Decimal(&#39;-0.0123&#39;)
&gt;&gt;&gt; Decimal(123456)
Decimal(&#39;123456&#39;)
&gt;&gt;&gt; Decimal(&#39;123.45e12345678901234567890&#39;)
Decimal(&#39;1.2345E+12345678901234567892&#39;)
&gt;&gt;&gt; Decimal(&#39;1.33&#39;) + Decimal(&#39;1.27&#39;)
Decimal(&#39;2.60&#39;)
&gt;&gt;&gt; Decimal(&#39;12.34&#39;) + Decimal(&#39;3.87&#39;) - Decimal(&#39;18.41&#39;)
Decimal(&#39;-2.20&#39;)
&gt;&gt;&gt; dig = Decimal(1)
&gt;&gt;&gt; print dig / Decimal(3)
0.333333333
&gt;&gt;&gt; getcontext().prec = 18
&gt;&gt;&gt; print dig / Decimal(3)
0.333333333333333333
&gt;&gt;&gt; print dig.sqrt()
1
&gt;&gt;&gt; print Decimal(3).sqrt()
1.73205080756887729
&gt;&gt;&gt; print Decimal(3) ** 123
4.85192780976896427E+58
&gt;&gt;&gt; inf = Decimal(1) / Decimal(0)
&gt;&gt;&gt; print inf
Infinity
&gt;&gt;&gt; neginf = Decimal(-1) / Decimal(0)
&gt;&gt;&gt; print neginf
-Infinity
&gt;&gt;&gt; print neginf + inf
NaN
&gt;&gt;&gt; print neginf * inf
-Infinity
&gt;&gt;&gt; print dig / 0
Infinity
&gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1
&gt;&gt;&gt; print dig / 0
Traceback (most recent call last):
  ...
  ...
  ...
DivisionByZero: x / 0
&gt;&gt;&gt; c = Context()
&gt;&gt;&gt; c.traps[InvalidOperation] = 0
&gt;&gt;&gt; print c.flags[InvalidOperation]
0
&gt;&gt;&gt; c.divide(Decimal(0), Decimal(0))
Decimal(&#39;NaN&#39;)
&gt;&gt;&gt; c.traps[InvalidOperation] = 1
&gt;&gt;&gt; print c.flags[InvalidOperation]
1
&gt;&gt;&gt; c.flags[InvalidOperation] = 0
&gt;&gt;&gt; print c.flags[InvalidOperation]
0
&gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))
Traceback (most recent call last):
  ...
  ...
  ...
InvalidOperation: 0 / 0
&gt;&gt;&gt; print c.flags[InvalidOperation]
1
&gt;&gt;&gt; c.flags[InvalidOperation] = 0
&gt;&gt;&gt; c.traps[InvalidOperation] = 0
&gt;&gt;&gt; print c.divide(Decimal(0), Decimal(0))
NaN
&gt;&gt;&gt; print c.flags[InvalidOperation]
1
&gt;&gt;&gt;
&#34;&#34;&#34;</span><span class="">

</span><span class="pln">__all__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="">
    </span><span class="com"># Two major classes</span><span class="">
    </span><span class="str">&#39;Decimal&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Context&#39;</span><span class="pun">,</span><span class="">

    </span><span class="com"># Contexts</span><span class="">
    </span><span class="str">&#39;DefaultContext&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;BasicContext&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ExtendedContext&#39;</span><span class="pun">,</span><span class="">

    </span><span class="com"># Exceptions</span><span class="">
    </span><span class="str">&#39;DecimalException&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Clamped&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;InvalidOperation&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;DivisionByZero&#39;</span><span class="pun">,</span><span class="">
    </span><span class="str">&#39;Inexact&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Rounded&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Subnormal&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Overflow&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Underflow&#39;</span><span class="pun">,</span><span class="">

    </span><span class="com"># Constants for use in setting up contexts</span><span class="">
    </span><span class="str">&#39;ROUND_DOWN&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_HALF_UP&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_HALF_EVEN&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_CEILING&#39;</span><span class="pun">,</span><span class="">
    </span><span class="str">&#39;ROUND_FLOOR&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_UP&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_HALF_DOWN&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;ROUND_05UP&#39;</span><span class="pun">,</span><span class="">

    </span><span class="com"># Functions for manipulating contexts</span><span class="">
    </span><span class="str">&#39;setcontext&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;getcontext&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;localcontext&#39;</span><span class="">
</span><span class="pun">]</span><span class="">

</span><span class="pln">__version__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;1.70&#39;</span><span class="">    </span><span class="com"># Highest version of the spec this complies with</span><span class="">

</span><span class="kwd">import</span><span class=""> </span><span class="pln">math</span><span class=""> </span><span class="kwd">as</span><span class=""> </span><span class="pln">_math</span><span class="">
</span><span class="kwd">import</span><span class=""> </span><span class="pln">numbers</span><span class=""> </span><span class="kwd">as</span><span class=""> </span><span class="pln">_numbers</span><span class="">

</span><span class="kwd">try</span><span class="pun">:</span><span class="">
    </span><span class="kwd">from</span><span class=""> </span><span class="pln">collections</span><span class=""> </span><span class="kwd">import</span><span class=""> </span><span class="pln">namedtuple</span><span class=""> </span><span class="kwd">as</span><span class=""> </span><span class="pln">_namedtuple</span><span class="">
    </span><span class="pln">DecimalTuple</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_namedtuple</span><span class="pun">(</span><span class="str">&#39;DecimalTuple&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sign digits exponent&#39;</span><span class="pun">)</span><span class="">
</span><span class="kwd">except</span><span class=""> </span><span class="pln">ImportError</span><span class="pun">:</span><span class="">
    </span><span class="pln">DecimalTuple</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="kwd">lambda</span><span class=""> *</span><span class="pln">args</span><span class="pun">:</span><span class=""> </span><span class="pln">args</span><span class="">

</span><span class="com"># Rounding</span><span class="">
</span><span class="pln">ROUND_DOWN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_DOWN&#39;</span><span class="">
</span><span class="pln">ROUND_HALF_UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_HALF_UP&#39;</span><span class="">
</span><span class="pln">ROUND_HALF_EVEN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_HALF_EVEN&#39;</span><span class="">
</span><span class="pln">ROUND_CEILING</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_CEILING&#39;</span><span class="">
</span><span class="pln">ROUND_FLOOR</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_FLOOR&#39;</span><span class="">
</span><span class="pln">ROUND_UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_UP&#39;</span><span class="">
</span><span class="pln">ROUND_HALF_DOWN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_HALF_DOWN&#39;</span><span class="">
</span><span class="pln">ROUND_05UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;ROUND_05UP&#39;</span><span class="">

</span><span class="com"># Errors</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">DecimalException</span><span class="pun">(</span><span class="pln">ArithmeticError</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Base exception class.

    Used exceptions derive from this.
    If an exception derives from another exception besides this (such as
    Underflow (Inexact, Rounded, Subnormal) that indicates that it is only
    called if the others are present.  This isn&#39;t actually used for
    anything, though.

    handle  -- Called when context._raise_error is called and the
               trap_enabler is not set.  First argument is self, second is the
               context.  More arguments can be given, those being after
               the explanation in _raise_error (For example,
               context._raise_error(NewError, &#39;(-x)!&#39;, self._sign) would
               call NewError().handle(context, self._sign).)

    To define a new exception, it should be sufficient to have it derive
    from DecimalException.
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">pass</span><span class="">


</span><span class="kwd">class</span><span class=""> </span><span class="pln">Clamped</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Exponent of a 0 changed to fit bounds.

    This occurs and signals clamped if the exponent of a result has been
    altered in order to fit the constraints of a specific concrete
    representation.  This may occur when the exponent of a zero result would
    be outside the bounds of a representation, or when a large normal
    number would have an encoded exponent that cannot be represented.  In
    this latter case, the exponent is reduced to fit and the corresponding
    number of zero digits are appended to the coefficient (&#34;fold-down&#34;).
    &#34;&#34;&#34;</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">InvalidOperation</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;An invalid operation was performed.

    Various bad things cause this:

    Something creates a signaling NaN
    -INF + INF
    0 * (+-)INF
    (+-)INF / (+-)INF
    x % 0
    (+-)INF % x
    x._rescale( non-integer )
    sqrt(-x) , x &gt; 0
    0 ** 0
    x ** (non-integer)
    x ** (+-)INF
    An operand is invalid

    The result of the operation after these is a quiet positive NaN,
    except when the cause is a signaling NaN, in which case the result is
    also a quiet NaN, but with the original sign, and an optional
    diagnostic information.
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">args</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">args</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">args</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">True</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NaN</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">ConversionSyntax</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Trying to convert badly formed string.

    This occurs and signals invalid-operation if an string is being
    converted to a number and it does not conform to the numeric string
    syntax.  The result is [0,qNaN].
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NaN</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">DivisionByZero</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">,</span><span class=""> </span><span class="pln">ZeroDivisionError</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Division by 0.

    This occurs and signals division-by-zero if division of a finite number
    by zero was attempted (during a divide-integer or divide operation, or a
    power operation with negative right-hand operand), and the dividend was
    not zero.

    The result of the operation is [sign,inf], where sign is the exclusive
    or of the signs of the operands for divide, or is 1 for an odd power of
    -0, for power.
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">sign</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">DivisionImpossible</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Cannot perform the division adequately.

    This occurs and signals invalid-operation if the integer result of a
    divide-integer or remainder operation had too many digits (would be
    longer than precision).  The result is [0,qNaN].
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NaN</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">DivisionUndefined</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="pln">ZeroDivisionError</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Undefined result of division.

    This occurs and signals invalid-operation if division by zero was
    attempted (during a divide-integer, divide, or remainder operation), and
    the dividend is also zero.  The result is [0,qNaN].
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NaN</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Inexact</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Had to round, losing information.

    This occurs and signals inexact whenever the result of an operation is
    not exact (that is, it needed to be rounded and any discarded digits
    were non-zero), or if an overflow or underflow condition occurs.  The
    result in all cases is unchanged.

    The inexact signal may be tested (or trapped) to determine if a given
    operation (or sequence of operations) was inexact.
    &#34;&#34;&#34;</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">InvalidContext</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Invalid context.  Unknown rounding, for example.

    This occurs and signals invalid-operation if an invalid context was
    detected during an operation.  This can occur if contexts are not checked
    on creation and either the precision exceeds the capability of the
    underlying concrete representation or an unknown or unsupported rounding
    was specified.  These aspects of the context need only be checked when
    the values are required to be used.  The result is [0,qNaN].
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NaN</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Rounded</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Number got rounded (not  necessarily changed during rounding).

    This occurs and signals rounded whenever the result of an operation is
    rounded (that is, some zero or non-zero digits were discarded from the
    coefficient), or if an overflow or underflow condition occurs.  The
    result in all cases is unchanged.

    The rounded signal may be tested (or trapped) to determine if a given
    operation (or sequence of operations) caused a loss of precision.
    &#34;&#34;&#34;</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Subnormal</span><span class="pun">(</span><span class="pln">DecimalException</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Exponent &lt; Emin before rounding.

    This occurs and signals subnormal whenever the result of a conversion or
    operation is subnormal (that is, its adjusted exponent is less than
    Emin, before any rounding).  The result in all cases is unchanged.

    The subnormal signal may be tested (or trapped) to determine if a given
    or operation (or sequence of operations) yielded a subnormal result.
    &#34;&#34;&#34;</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Overflow</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">,</span><span class=""> </span><span class="pln">Rounded</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Numerical overflow.

    This occurs and signals overflow if the adjusted exponent of a result
    (from a conversion or from an operation that is not an attempt to divide
    by zero), after rounding, would be greater than the largest value that
    can be handled by the implementation (the value Emax).

    The result depends on the rounding mode:

    For round-half-up and round-half-even (and for round-half-down and
    round-up, if implemented), the result of the operation is [sign,inf],
    where sign is the sign of the intermediate result.  For round-down, the
    result is the largest finite number that can be represented in the
    current precision, with the sign of the intermediate result.  For
    round-ceiling, the result is the same as for round-down if the sign of
    the intermediate result is 1, or is [0,inf] otherwise.  For round-floor,
    the result is the same as for round-down if the sign of the intermediate
    result is 0, or is [1,inf] otherwise.  In all cases, Inexact and Rounded
    will also be raised.
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">sign</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="pln">ROUND_HALF_UP</span><span class="pun">,</span><span class=""> </span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">,</span><span class="">
                                </span><span class="pln">ROUND_HALF_DOWN</span><span class="pun">,</span><span class=""> </span><span class="pln">ROUND_UP</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">ROUND_CEILING</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">,</span><span class="">
                            </span><span class="pln">context.Emax</span><span class="">-</span><span class="pln">context.prec</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">ROUND_FLOOR</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">,</span><span class="">
                             </span><span class="pln">context.Emax</span><span class="">-</span><span class="pln">context.prec</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">


</span><span class="kwd">class</span><span class=""> </span><span class="pln">Underflow</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">,</span><span class=""> </span><span class="pln">Rounded</span><span class="pun">,</span><span class=""> </span><span class="pln">Subnormal</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Numerical underflow with result rounded to 0.

    This occurs and signals underflow if a result is inexact and the
    adjusted exponent of the result would be smaller (more negative) than
    the smallest value that can be handled by the implementation (the value
    Emin).  That is, the result is both inexact and subnormal.

    The result after an underflow will be a subnormal number rounded, if
    necessary, so that its exponent is not less than Etiny.  This may result
    in 0 with the sign of the intermediate result and an exponent of Etiny.

    In all cases, Inexact, Rounded, and Subnormal will also be raised.
    &#34;&#34;&#34;</span><span class="">

</span><span class="com"># List of public traps and flags</span><span class="">
</span><span class="pln">_signals</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pln">Clamped</span><span class="pun">,</span><span class=""> </span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="pln">Inexact</span><span class="pun">,</span><span class=""> </span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="pln">Rounded</span><span class="pun">,</span><span class="">
           </span><span class="pln">Underflow</span><span class="pun">,</span><span class=""> </span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="pln">Subnormal</span><span class="pun">]</span><span class="">

</span><span class="com"># Map conditions (per the spec) to signals</span><span class="">
</span><span class="pln">_condition_map</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">{</span><span class="pln">ConversionSyntax</span><span class="pun">:</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                  </span><span class="pln">DivisionImpossible</span><span class="pun">:</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                  </span><span class="pln">DivisionUndefined</span><span class="pun">:</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                  </span><span class="pln">InvalidContext</span><span class="pun">:</span><span class="pln">InvalidOperation</span><span class="pun">}</span><span class="">

</span><span class="com">##### Context Functions ##################################################</span><span class="">

</span><span class="com"># The getcontext() and setcontext() function manage access to a thread-local</span><span class="">
</span><span class="com"># current context.  Py2.4 offers direct support for thread locals.  If that</span><span class="">
</span><span class="com"># is not available, use threading.currentThread() which is slower but will</span><span class="">
</span><span class="com"># work for older Pythons.  If threads are not part of the build, create a</span><span class="">
</span><span class="com"># mock threading object with threading.local() returning the module namespace.</span><span class="">

</span><span class="kwd">try</span><span class="pun">:</span><span class="">
    </span><span class="kwd">import</span><span class=""> </span><span class="pln">threading</span><span class="">
</span><span class="pln">except</span><span class=""> </span><span class="pln">ImportError</span><span class="pun">:</span><span class="">
    </span><span class="com"># Python was compiled without threads; create a mock object instead</span><span class="">
    </span><span class="kwd">import</span><span class=""> </span><span class="pln">sys</span><span class="">
    </span><span class="pln">class</span><span class=""> </span><span class="pln">MockThreading</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">def</span><span class=""> </span><span class="pln">local</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">sys</span><span class="">=</span><span class="pln">sys</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">sys.modules</span><span class="pun">[</span><span class="pln">__name__</span><span class="pun">]</span><span class="">
    </span><span class="pln">threading</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">MockThreading</span><span class="pun">(</span><span class="pun">)</span><span class="">
    </span><span class="kwd">del</span><span class=""> </span><span class="pln">sys</span><span class="pun">,</span><span class=""> </span><span class="pln">MockThreading</span><span class="">

</span><span class="kwd">try</span><span class="pun">:</span><span class="">
    </span><span class="pln">threading.local</span><span class="">

</span><span class="kwd">except</span><span class=""> </span><span class="pln">AttributeError</span><span class="pun">:</span><span class="">

    </span><span class="com"># To fix reloading, force it to create a new context</span><span class="">
    </span><span class="com"># Old contexts have different exceptions in their dicts, making problems.</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">hasattr</span><span class="pun">(</span><span class="pln">threading.currentThread</span><span class="pun">(</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;__decimal_context__&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">del</span><span class=""> </span><span class="pln">threading.currentThread</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">__decimal_context__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">setcontext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Set this thread&#39;s context to context.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="pln">DefaultContext</span><span class="pun">,</span><span class=""> </span><span class="pln">BasicContext</span><span class="pun">,</span><span class=""> </span><span class="pln">ExtendedContext</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">context.clear_flags</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">threading.currentThread</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">__decimal_context__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns this thread&#39;s context.

        If this thread does not yet have a context, returns
        a new context and sets this thread&#39;s context.
        New contexts are copies of DefaultContext.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">try</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">threading.currentThread</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">__decimal_context__</span><span class="">
        </span><span class="kwd">except</span><span class=""> </span><span class="pln">AttributeError</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">threading.currentThread</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">__decimal_context__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context</span><span class="">

</span><span class="kwd">else</span><span class="pun">:</span><span class="">

    </span><span class="pln">local</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">threading.local</span><span class="pun">(</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">hasattr</span><span class="pun">(</span><span class="pln">local</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;__decimal_context__&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">del</span><span class=""> </span><span class="pln">local.__decimal_context__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pln">_local</span><span class="">=</span><span class="pln">local</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns this thread&#39;s context.

        If this thread does not yet have a context, returns
        a new context and sets this thread&#39;s context.
        New contexts are copies of DefaultContext.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">try</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_local.__decimal_context__</span><span class="">
        </span><span class="kwd">except</span><span class=""> </span><span class="pln">AttributeError</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">_local.__decimal_context__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">setcontext</span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">_local</span><span class="">=</span><span class="pln">local</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Set this thread&#39;s context to context.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="pln">DefaultContext</span><span class="pun">,</span><span class=""> </span><span class="pln">BasicContext</span><span class="pun">,</span><span class=""> </span><span class="pln">ExtendedContext</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">context.clear_flags</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">_local.__decimal_context__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context</span><span class="">

    </span><span class="kwd">del</span><span class=""> </span><span class="pln">threading</span><span class="pun">,</span><span class=""> </span><span class="pln">local</span><span class="">        </span><span class="com"># Don&#39;t contaminate the namespace</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">localcontext</span><span class="pun">(</span><span class="pln">ctx</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Return a context manager for a copy of the supplied context

    Uses a copy of the current context if no context is specified
    The returned context manager creates a local decimal context
    in a with statement:
        def sin(x):
             with localcontext() as ctx:
                 ctx.prec += 2
                 # Rest of sin calculation algorithm
                 # uses a precision 2 greater than normal
             return +s  # Convert result to normal precision

         def sin(x):
             with localcontext(ExtendedContext):
                 # Rest of sin calculation algorithm
                 # uses the Extended Context from the
                 # General Decimal Arithmetic Specification
             return +s  # Convert result to normal context

    &gt;&gt;&gt; setcontext(DefaultContext)
    &gt;&gt;&gt; print getcontext().prec
    28
    &gt;&gt;&gt; with localcontext():
    ...     ctx = getcontext()
    ...     ctx.prec += 2
    ...     print ctx.prec
    ...
    30
    &gt;&gt;&gt; with localcontext(ExtendedContext):
    ...     print getcontext().prec
    ...
    9
    &gt;&gt;&gt; print getcontext().prec
    28
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">ctx</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class=""> </span><span class="pln">ctx</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_ContextManager</span><span class="pun">(</span><span class="pln">ctx</span><span class="pun">)</span><span class="">


</span><span class="com">##### Decimal class #######################################################</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Floating point class for decimal arithmetic.&#34;&#34;&#34;</span><span class="">

    </span><span class="pln">__slots__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="str">&#39;_exp&#39;</span><span class="pun">,</span><span class="str">&#39;_int&#39;</span><span class="pun">,</span><span class="str">&#39;_sign&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;_is_special&#39;</span><span class="pun">)</span><span class="">
    </span><span class="com"># Generally, the value of the Decimal instance is given by</span><span class="">
    </span><span class="com">#  (-1)**_sign * _int * 10**_exp</span><span class="">
    </span><span class="com"># Special values are signified by _is_special == True</span><span class="">

    </span><span class="com"># We&#39;re immutable, so use __new__ not __init__</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__new__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class=""> </span><span class="pln">value</span><span class="pun">=</span><span class="str">&#34;0&#34;</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Create a decimal point instance.

        &gt;&gt;&gt; Decimal(&#39;3.14&#39;)              # string input
        Decimal(&#39;3.14&#39;)
        &gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)
        Decimal(&#39;3.14&#39;)
        &gt;&gt;&gt; Decimal(314)                 # int or long
        Decimal(&#39;314&#39;)
        &gt;&gt;&gt; Decimal(Decimal(314))        # another decimal instance
        Decimal(&#39;314&#39;)
        &gt;&gt;&gt; Decimal(&#39;  3.14  \\n&#39;)        # leading and trailing whitespace okay
        Decimal(&#39;3.14&#39;)
        &#34;&#34;&#34;</span><span class="">

        </span><span class="com"># Note that the coefficient, self._int, is actually stored as</span><span class="">
        </span><span class="com"># a string rather than as a tuple of digits.  This speeds up</span><span class="">
        </span><span class="com"># the &#34;digits to integer&#34; and &#34;integer to digits&#34; conversions</span><span class="">
        </span><span class="com"># that are used in almost every arithmetic operation on</span><span class="">
        </span><span class="com"># Decimals.  This is an internal detail: the as_tuple function</span><span class="">
        </span><span class="com"># and the Decimal constructor still deal with tuples of</span><span class="">
        </span><span class="com"># digits.</span><span class="">

        </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">object</span><span class="">.</span><span class="pln">__new__</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">)</span><span class="">

        </span><span class="com"># From a string</span><span class="">
        </span><span class="com"># REs insist on real strings, so we can too.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pln">basestring</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">m</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_parser</span><span class="pun">(</span><span class="pln">value.strip</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">m</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                    </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">ConversionSyntax</span><span class="pun">,</span><span class="">
                                </span><span class="str">&#34;Invalid literal for Decimal: %r&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">value</span><span class="pun">)</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;sign&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#34;-&#34;</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;int&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">intpart</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="com"># finite number</span><span class="">
                </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;frac&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">
                </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;exp&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">intpart</span><span class="">+</span><span class="pln">fracpart</span><span class="pun">)</span><span class="pun">)</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">fracpart</span><span class="pun">)</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">diag</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;diag&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">diag</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                    </span><span class="com"># NaN</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">diag</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="pun">)</span><span class="">.</span><span class="pln">lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="">
                    </span><span class="kwd">if</span><span class=""> </span><span class="pln">m.group</span><span class="pun">(</span><span class="str">&#39;signal&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
                        </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="">
                    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                        </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="">
                </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                    </span><span class="com"># infinity</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="com"># From an integer</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">value</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">value</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="com"># From another decimal</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._exp</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value._sign</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._int</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._is_special</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="com"># From an internal working value</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value.sign</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">value.int</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">value.exp</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="com"># tuple/list conversion (possibly from as_tuple())</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">list</span><span class="pun">,</span><span class="pln">tuple</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">value</span><span class="pun">)</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">3</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#39;Invalid tuple size in creation of Decimal &#39;</span><span class="">
                                 </span><span class="str">&#39;from list or tuple.  The list or tuple &#39;</span><span class="">
                                 </span><span class="str">&#39;should have exactly three elements.&#39;</span><span class="pun">)</span><span class="">
            </span><span class="com"># process sign.  The isinstance test rejects floats</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Invalid sign.  The first value in the tuple &#34;</span><span class="">
                                 </span><span class="str">&#34;should be an integer; either 0 for a &#34;</span><span class="">
                                 </span><span class="str">&#34;positive number or 1 for a negative number.&#34;</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="pun">:</span><span class="">
                </span><span class="com"># infinity: value[1] is ignored</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="">
                </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="com"># process and validate the digits in value[1]</span><span class="">
                </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pun">]</span><span class="">
                </span><span class="kwd">for</span><span class=""> </span><span class="pln">digit</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">1</span><span class="pun">]</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">digit</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">digit</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">9</span><span class="pun">:</span><span class="">
                        </span><span class="com"># skip leading zeros</span><span class="">
                        </span><span class="kwd">if</span><span class=""> </span><span class="pln">digits</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">digit</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                            </span><span class="pln">digits.append</span><span class="pun">(</span><span class="pln">digit</span><span class="pun">)</span><span class="">
                    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;The second value in the tuple must &#34;</span><span class="">
                                         </span><span class="str">&#34;be composed of integers in the range &#34;</span><span class="">
                                         </span><span class="str">&#34;0 through 9.&#34;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="str">&#39;n&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="com"># NaN: digits form the diagnostic</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">map</span><span class="pun">(</span><span class="pln">str</span><span class="pun">,</span><span class=""> </span><span class="pln">digits</span><span class="pun">)</span><span class="pun">)</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="">
                </span><span class="kwd">elif</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="com"># finite number: digits give the coefficient</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">map</span><span class="pun">(</span><span class="pln">str</span><span class="pun">,</span><span class=""> </span><span class="pln">digits</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="pun">)</span><span class="pun">)</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">
                </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;The third value in the tuple must &#34;</span><span class="">
                                     </span><span class="str">&#34;be an integer, or one of the &#34;</span><span class="">
                                     </span><span class="str">&#34;strings &#39;F&#39;, &#39;n&#39;, &#39;N&#39;.&#34;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pln">float</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">value</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal.from_float</span><span class="pun">(</span><span class="pln">value</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._exp</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value._sign</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._int</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="">  </span><span class="pun">=</span><span class=""> </span><span class="pln">value._is_special</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Cannot convert %r to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">value</span><span class="pun">)</span><span class="">

    </span><span class="com"># @classmethod, but @decorator is not valid Python 2.3 syntax, so</span><span class="">
    </span><span class="com"># don&#39;t use it (see notes on Py2.3 compatibility at top of file)</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">from_float</span><span class="pun">(</span><span class="pln">cls</span><span class="pun">,</span><span class=""> </span><span class="pln">f</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Converts a float to a decimal number, exactly.

        Note that Decimal.from_float(0.1) is not the same as Decimal(&#39;0.1&#39;).
        Since 0.1 is not exactly representable in binary floating point, the
        value is stored as the nearest representable value which is
        0x1.999999999999ap-4.  The exact equivalent of the value in decimal
        is 0.1000000000000000055511151231257827021181583404541015625.

        &gt;&gt;&gt; Decimal.from_float(0.1)
        Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)
        &gt;&gt;&gt; Decimal.from_float(float(&#39;nan&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; Decimal.from_float(float(&#39;inf&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; Decimal.from_float(-float(&#39;inf&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; Decimal.from_float(-0.0)
        Decimal(&#39;-0&#39;)

        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">        </span><span class="com"># handle integer inputs</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">cls</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_math.isinf</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">_math.isnan</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="pun">:</span><span class="">  </span><span class="com"># raises TypeError if not a float</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">cls</span><span class="pun">(</span><span class="pln">repr</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_math.copysign</span><span class="pun">(</span><span class="dec">1.0</span><span class="pun">,</span><span class=""> </span><span class="pln">f</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1.0</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="pln">n</span><span class="pun">,</span><span class=""> </span><span class="pln">d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">abs</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="">.</span><span class="pln">as_integer_ratio</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">k</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">d.bit_length</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">n</span><span class="">*</span><span class="dec">5</span><span class="pun">*</span><span class="">*</span><span class="pln">k</span><span class="pun">)</span><span class="pun">,</span><span class=""> -</span><span class="pln">k</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">cls</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">result</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">cls</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="">
    </span><span class="pln">from_float</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">classmethod</span><span class="pun">(</span><span class="pln">from_float</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_isnan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns whether the number is not actually one.

        0 if a number
        1 if NaN
        2 if sNaN
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">2</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns whether the number is infinite

        0 if finite or not a number
        1 if +INF
        -1 if -INF
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns whether the number is not actually one.

        if self, other are sNaN, signal
        if self, other are NaN return nan
        return 0

        Done before operations.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other_is_nan</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Version of _check_nans used for the signaling comparisons
        compare_signal, __le__, __lt__, __ge__, __gt__.

        Signal InvalidOperation if either self or other is a (quiet
        or signaling) NaN.  Signaling NaNs take precedence over quiet
        NaNs.

        Return 0 if neither operand is a NaN.

        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;comparison involving sNaN&#39;</span><span class="pun">,</span><span class="">
                                            </span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">other.is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;comparison involving sNaN&#39;</span><span class="pun">,</span><span class="">
                                            </span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_qnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;comparison involving NaN&#39;</span><span class="pun">,</span><span class="">
                                            </span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">other.is_qnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;comparison involving NaN&#39;</span><span class="pun">,</span><span class="">
                                            </span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__nonzero__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is nonzero; otherwise return False.

        NaNs and infinities are considered nonzero.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compare the two non-NaN decimal instances self and other.

        Returns -1 if self &lt; other, 0 if self == other and 1
        if self &gt; other.  This routine is for internal use only.&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">self_inf</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">other_inf</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_inf</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">other_inf</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self_inf</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other_inf</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="com"># check for zeros;  Decimal(&#39;0&#39;) == Decimal(&#39;-0&#39;)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">-</span><span class="pun">(</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">other._sign</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">

        </span><span class="com"># If different signs, neg one is less</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">other_adjusted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">other_adjusted</span><span class="pun">:</span><span class="">
            </span><span class="pln">self_padded</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">)</span><span class="">
            </span><span class="pln">other_padded</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">other._exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_padded</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">other_padded</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self_padded</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other_padded</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">-</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">other_adjusted</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class=""> </span><span class="com"># self_adjusted &lt; other_adjusted</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">-</span><span class="pun">(</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">)</span><span class="">

    </span><span class="com"># Note: The Decimal standard doesn&#39;t cover rich comparisons for</span><span class="">
    </span><span class="com"># Decimals.  In particular, the specification is silent on the</span><span class="">
    </span><span class="com"># subject of what should happen for a comparison involving a NaN.</span><span class="">
    </span><span class="com"># We take the following approach:</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#   == comparisons involving a quiet NaN always return False</span><span class="">
    </span><span class="com">#   != comparisons involving a quiet NaN always return True</span><span class="">
    </span><span class="com">#   == or != comparisons involving a signaling NaN signal</span><span class="">
    </span><span class="com">#      InvalidOperation, and return False or True as above if the</span><span class="">
    </span><span class="com">#      InvalidOperation is not trapped.</span><span class="">
    </span><span class="com">#   &lt;, &gt;, &lt;= and &gt;= comparisons involving a (quiet or signaling)</span><span class="">
    </span><span class="com">#      NaN signal InvalidOperation, and return False if the</span><span class="">
    </span><span class="com">#      InvalidOperation is not trapped.</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># This behavior is designed to conform as closely as possible to</span><span class="">
    </span><span class="com"># that specified by IEEE 754.</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__eq__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__ne__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">True</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__lt__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__le__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__gt__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__ge__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares one to another.

        -1 =&gt; a &lt; b
        0  =&gt; a = b
        1  =&gt; a &gt; b
        NaN =&gt; one is NaN
        Like __cmp__, but returns Decimal instances.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="com"># Compare(NaN, NaN) = NaN</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__hash__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;x.__hash__() &lt;==&gt; hash(x)&#34;&#34;&#34;</span><span class="">
        </span><span class="com"># Decimal integers must hash the same as the ints</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com"># The hash of a nonspecial noninteger Decimal must depend only</span><span class="">
        </span><span class="com"># on the value of that Decimal, and not on its representation.</span><span class="">
        </span><span class="com"># For example: hash(Decimal(&#39;100E-1&#39;)) == hash(Decimal(&#39;10&#39;)).</span><span class="">

        </span><span class="com"># Equality comparisons involving signaling nans can raise an</span><span class="">
        </span><span class="com"># exception; since equality checks are implicitly and</span><span class="">
        </span><span class="com"># unpredictably used when checking set and dict membership, we</span><span class="">
        </span><span class="com"># prevent signaling nans from being used as set elements or</span><span class="">
        </span><span class="com"># dict keys by making __hash__ raise an exception.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#39;Cannot hash a signaling NaN value.&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_nan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="com"># 0 to match hash(float(&#39;nan&#39;))</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="com"># values chosen to match hash(float(&#39;inf&#39;)) and</span><span class="">
                </span><span class="com"># hash(float(&#39;-inf&#39;)).</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> -</span><span class="dec">271828</span><span class="">
                </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="dec">314159</span><span class="">

        </span><span class="com"># In Python 2.7, we&#39;re allowing comparisons (but not</span><span class="">
        </span><span class="com"># arithmetic operations) between floats and Decimals;  so if</span><span class="">
        </span><span class="com"># a Decimal instance is exactly representable as a float then</span><span class="">
        </span><span class="com"># its hash should match that of the float.</span><span class="">
        </span><span class="pln">self_as_float</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">float</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">Decimal.from_float</span><span class="pun">(</span><span class="pln">self_as_float</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">hash</span><span class="pun">(</span><span class="pln">self_as_float</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinteger</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">to_integral_value</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="com"># to make computation feasible for Decimals with large</span><span class="">
            </span><span class="com"># exponent, we use the fact that hash(n) == hash(m) for</span><span class="">
            </span><span class="com"># any two nonzero integers n and m such that (i) n and m</span><span class="">
            </span><span class="com"># have the same sign, and (ii) n is congruent to m modulo</span><span class="">
            </span><span class="com"># 2**64-1.  So we can replace hash((-1)**s*c*10**e) with</span><span class="">
            </span><span class="com"># hash((-1)**s*c*pow(10, e, 2**64-1).</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">hash</span><span class="pun">(</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">op.sign</span><span class="">*</span><span class="pln">op.int</span><span class="">*</span><span class="pln">pow</span><span class="pun">(</span><span class="dec">10</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="pun">,</span><span class=""> </span><span class="dec">2</span><span class="pun">*</span><span class="">*</span><span class="dec">64</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="com"># The value of a nonzero nonspecial Decimal instance is</span><span class="">
        </span><span class="com"># faithfully represented by the triple consisting of its sign,</span><span class="">
        </span><span class="com"># its adjusted exponent, and its coefficient with trailing</span><span class="">
        </span><span class="com"># zeros removed.</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">hash</span><span class="pun">(</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">+</span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">_int.rstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">as_tuple</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Represents the number as a triple tuple.

        To show the internals exactly as they are.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">DecimalTuple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">tuple</span><span class="pun">(</span><span class="pln">map</span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__repr__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Represents the number as an instance of Decimal.&#34;&#34;&#34;</span><span class="">
        </span><span class="com"># Invariant:  eval(repr(d)) == d</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;Decimal(&#39;%s&#39;)&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__str__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">eng</span><span class="">=</span><span class="pln">False</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return string representation of the number in scientific notation.

        Captures all of the information in the underlying representation.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="str">&#39;&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;-&#39;</span><span class="pun">]</span><span class="pun">[</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">]</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;Infinity&#39;</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;NaN&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class=""> </span><span class="com"># self._exp == &#39;N&#39;</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">

        </span><span class="com"># number of digits of self._int to left of decimal point</span><span class="">
        </span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="">

        </span><span class="com"># dotplace is number of digits of self._int to the left of the</span><span class="">
        </span><span class="com"># decimal point in the mantissa of the output string (that is,</span><span class="">
        </span><span class="com"># after adjusting the exponent)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">&gt;</span><span class=""> -</span><span class="dec">6</span><span class="pun">:</span><span class="">
            </span><span class="com"># no exponent required</span><span class="">
            </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">leftdigits</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">eng</span><span class="pun">:</span><span class="">
            </span><span class="com"># usual scientific notation: 1 digit on left of the point</span><span class="">
            </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">:</span><span class="">
            </span><span class="com"># engineering notation, zero</span><span class="">
            </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">3</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># engineering notation, nonzero</span><span class="">
            </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">3</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;.&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="">-</span><span class="pln">dotplace</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">+</span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">dotplace</span><span class="">-</span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">dotplace</span><span class="pun">]</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;.&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">dotplace</span><span class="pun">:</span><span class="pun">]</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">dotplace</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="str">&#39;e&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;E&#39;</span><span class="pun">]</span><span class="pun">[</span><span class="pln">context.capitals</span><span class="pun">]</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#34;%+d&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="pln">leftdigits</span><span class="">-</span><span class="pln">dotplace</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">intpart</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">exp</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_eng_string</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Convert to engineering-type string.

        Engineering notation has an exponent which is a multiple of 3, so there
        are up to 3 digits left of the decimal place.

        Same rules for when in exponential and when as a value as in __str__.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__str__</span><span class="pun">(</span><span class="pln">eng</span><span class="">=</span><span class="pln">True</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__neg__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy with the sign switched.

        Rounds, if it has reason.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">ROUND_FLOOR</span><span class="pun">:</span><span class="">
            </span><span class="com"># -Decimal(&#39;0&#39;) is Decimal(&#39;0&#39;), not Decimal(&#39;-0&#39;), except</span><span class="">
            </span><span class="com"># in ROUND_FLOOR rounding mode.</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_negate</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__pos__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy, unless it is a sNaN.

        Rounds the number (if more then precision digits)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">ROUND_FLOOR</span><span class="pun">:</span><span class="">
            </span><span class="com"># + (-0) = 0, except in ROUND_FLOOR rounding mode.</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__abs__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">round</span><span class="">=</span><span class="pln">True</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the absolute value of self.

        If the keyword argument &#39;round&#39; is false, do not round.  The
        expression self.__abs__(round=False) is equivalent to
        self.copy_abs().
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">round</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__neg__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__pos__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__add__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns self + other.

        -INF + INF (or the reverse) cause InvalidOperation errors.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="com"># If both INF, same sign =&gt; same as both, opposite =&gt; error.</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;-INF + INF&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">  </span><span class="com"># Can&#39;t both be infinity here</span><span class="">

        </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">)</span><span class="">
        </span><span class="pln">negativezero</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">ROUND_FLOOR</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">:</span><span class="">
            </span><span class="com"># If the answer is 0, the sign should be negative, in this case.</span><span class="">
            </span><span class="pln">negativezero</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">negativezero</span><span class="pun">:</span><span class="">
                </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">context.prec</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._rescale</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">context.rounding</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">context.prec</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">context.rounding</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="pln">op1</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="pln">op1</span><span class="pun">,</span><span class=""> </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_normalize</span><span class="pun">(</span><span class="pln">op1</span><span class="pun">,</span><span class=""> </span><span class="pln">op2</span><span class="pun">,</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">)</span><span class="">

        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.sign</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">op2.sign</span><span class="pun">:</span><span class="">
            </span><span class="com"># Equal and opposite</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">negativezero</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">:</span><span class="">
                </span><span class="pln">op1</span><span class="pun">,</span><span class=""> </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op2</span><span class="pun">,</span><span class=""> </span><span class="pln">op1</span><span class="">
                </span><span class="com"># OK, now abs(op1) &gt; abs(op2)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                </span><span class="pln">result.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
                </span><span class="pln">op1.sign</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op2.sign</span><span class="pun">,</span><span class=""> </span><span class="pln">op1.sign</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">result.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
                </span><span class="com"># So we know the sign, and op1 &gt; 0.</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">op1.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">result.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="pln">op1.sign</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">result.sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="com"># Now, op1 &gt; abs(op2) &gt; 0</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">op2.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">result.int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">op2.int</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">result.int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">op2.int</span><span class="">

        </span><span class="pln">result.exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op1.exp</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="pln">__radd__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__add__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__sub__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return self - other&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># self - other is computed as self + other.copy_negate()</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__add__</span><span class="pun">(</span><span class="pln">other.copy_negate</span><span class="pun">(</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rsub__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return other - self&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__sub__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__mul__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return self * other.

        (+-) INF * 0 (or its reverse) raise InvalidOperation.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">resultsign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;(+-)INF * 0&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">resultsign</span><span class="pun">]</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0 * (+-)INF&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">resultsign</span><span class="pun">]</span><span class="">

        </span><span class="pln">resultexp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">other._exp</span><span class="">

        </span><span class="com"># Special case for multiplying by zero</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">resultsign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">resultexp</span><span class="pun">)</span><span class="">
            </span><span class="com"># Fixing in case the exponent is out of bounds</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># Special case for multiplying by power of 10</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">resultsign</span><span class="pun">,</span><span class=""> </span><span class="pln">other._int</span><span class="pun">,</span><span class=""> </span><span class="pln">resultexp</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._int</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">resultsign</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">resultexp</span><span class="pun">)</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="pln">op1</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">resultsign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">op1.int</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">resultexp</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
    </span><span class="pln">__rmul__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__mul__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__truediv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return self / other.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">NotImplemented</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;(+-)INF/(+-)INF&#39;</span><span class="pun">)</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Clamped</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;Division by infinity&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="com"># Special cases for zeroes</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionUndefined</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0 / 0&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;x / 0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">sign</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other._exp</span><span class="">
            </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># OK, so neither = 0, INF or NaN</span><span class="">
            </span><span class="pln">shift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">other._int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">shift</span><span class="">
            </span><span class="pln">op1</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">shift</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">op1.int</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">shift</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">op1.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.int</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">shift</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">remainder</span><span class="pun">:</span><span class="">
                </span><span class="com"># result is not exact; adjust to ensure correct rounding</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">5</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="pln">coeff</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="com"># result is exact; get as close to ideal exponent as possible</span><span class="">
                </span><span class="pln">ideal_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other._exp</span><span class="">
                </span><span class="kwd">while</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">ideal_exp</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">10</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="pln">coeff</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="">
                    </span><span class="pln">exp</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_divide</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return (self // other, self % other), to context.prec precision.

        Assumes that neither self nor other is a NaN, that self is not
        infinite and that other is nonzero.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">ideal_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ideal_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">)</span><span class="">

        </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="dec">2</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">,</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">ideal_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">context.rounding</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
            </span><span class="pln">op1</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">op2.exp</span><span class="pun">:</span><span class="">
                </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">op1.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">op2.exp</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">op2.int</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">op2.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">op1.exp</span><span class="pun">)</span><span class="">
            </span><span class="pln">q</span><span class="pun">,</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">op1.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">q</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">,</span><span class="">
                        </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">r</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">ideal_exp</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="com"># Here the quotient is too large to be representable</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionImpossible</span><span class="pun">,</span><span class="">
                                   </span><span class="str">&#39;quotient too large in //, % or divmod&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="pun">,</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rtruediv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Swaps self/other and returns __truediv__.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__truediv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="pln">__div__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__truediv__</span><span class="">
    </span><span class="pln">__rdiv__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__rtruediv__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__divmod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;
        Return (self // other, self % other)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class=""> </span><span class="pln">ans</span><span class="pun">)</span><span class="">

        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;divmod(INF, INF)&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="pun">,</span><span class=""> </span><span class="pln">ans</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">sign</span><span class="pun">]</span><span class="pun">,</span><span class="">
                        </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;INF % x&#39;</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionUndefined</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;divmod(0, 0)&#39;</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="pun">,</span><span class=""> </span><span class="pln">ans</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;x // 0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">sign</span><span class="pun">)</span><span class="pun">,</span><span class="">
                        </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;x % 0&#39;</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="pln">quotient</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_divide</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">remainder._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">quotient</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rdivmod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Swaps self/other and returns __divmod__.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__divmod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__mod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;
        self % other
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;INF % x&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;x % 0&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionUndefined</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0 % 0&#39;</span><span class="pun">)</span><span class="">

        </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_divide</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">[</span><span class="dec">1</span><span class="pun">]</span><span class="">
        </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">remainder._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">remainder</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rmod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Swaps self/other and returns __mod__.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__mod__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">remainder_near</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;
        Remainder nearest to 0-  abs(remainder-near) &lt;= other/2
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># self == +/-infinity -&gt; InvalidOperation</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;remainder_near(infinity, x)&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># other == 0 -&gt; either InvalidOperation or DivisionUndefined</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;remainder_near(x, 0)&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionUndefined</span><span class="pun">,</span><span class="">
                                            </span><span class="str">&#39;remainder_near(0, 0)&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># other = +/-infinity -&gt; remainder = self</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="com"># self = 0 -&gt; remainder = self, with ideal exponent</span><span class="">
        </span><span class="pln">ideal_exponent</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">ideal_exponent</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="com"># catch most cases of large or small quotient</span><span class="">
        </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="com"># expdiff &gt;= prec+1 =&gt; abs(self/other) &gt; 10**prec</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionImpossible</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="dec">2</span><span class="pun">:</span><span class="">
            </span><span class="com"># expdiff &lt;= -2 =&gt; abs(self/other) &lt; 0.1</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">ideal_exponent</span><span class="pun">,</span><span class=""> </span><span class="pln">context.rounding</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="com"># adjust both arguments to have the same exponent, then divide</span><span class="">
        </span><span class="pln">op1</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">op2</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">op2.exp</span><span class="pun">:</span><span class="">
            </span><span class="pln">op1.int</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">op1.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">op2.exp</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">op2.int</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">op2.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">op1.exp</span><span class="pun">)</span><span class="">
        </span><span class="pln">q</span><span class="pun">,</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">op1.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">)</span><span class="">
        </span><span class="com"># remainder is r*10**ideal_exponent; other is +/-op2.int *</span><span class="">
        </span><span class="com"># 10**ideal_exponent.   Apply correction to ensure that</span><span class="">
        </span><span class="com"># abs(remainder) &lt;= abs(other)/2</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="dec">2</span><span class="">*</span><span class="pln">r</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pun">(</span><span class="pln">q</span><span class="">&amp;</span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">op2.int</span><span class="pun">:</span><span class="">
            </span><span class="pln">r</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="pln">op2.int</span><span class="">
            </span><span class="pln">q</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionImpossible</span><span class="pun">)</span><span class="">

        </span><span class="com"># result has same sign as self unless r is negative</span><span class="">
        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">-</span><span class="pln">sign</span><span class="">
            </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">r</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">r</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">ideal_exponent</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__floordiv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;self // other&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;INF // INF&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">]</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;x // 0&#39;</span><span class="pun">,</span><span class="">
                                            </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionUndefined</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0 // 0&#39;</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_divide</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rfloordiv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Swaps self/other and returns __floordiv__.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__floordiv__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__float__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Float representation.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Cannot convert signaling NaN to float&#34;</span><span class="pun">)</span><span class="">
            </span><span class="pln">s</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;-nan&#34;</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="str">&#34;nan&#34;</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">s</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">float</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__int__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Converts self to an int, truncating if necessary.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Cannot convert NaN to integer&#34;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">raise</span><span class=""> </span><span class="pln">OverflowError</span><span class="pun">(</span><span class="str">&#34;Cannot convert infinity to integer&#34;</span><span class="pun">)</span><span class="">
        </span><span class="pln">s</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">s</span><span class="">*</span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">s</span><span class="">*</span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">]</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="">

    </span><span class="pln">__trunc__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__int__</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">real</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">
    </span><span class="pln">real</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">property</span><span class="pun">(</span><span class="pln">real</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">imag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="dec">0</span><span class="pun">)</span><span class="">
    </span><span class="pln">imag</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">property</span><span class="pun">(</span><span class="pln">imag</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">conjugate</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__complex__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">complex</span><span class="pun">(</span><span class="pln">float</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__long__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Converts to a long.

        Equivalent to long(int(self))
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">long</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">__int__</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_fix_nan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Decapitate the payload of a NaN to fit the context&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">payload</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">

        </span><span class="com"># maximum length of payload is precision if _clamp=0,</span><span class="">
        </span><span class="com"># precision-1 if _clamp=1.</span><span class="">
        </span><span class="pln">max_payload_len</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">context._clamp</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">payload</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">max_payload_len</span><span class="pun">:</span><span class="">
            </span><span class="pln">payload</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">payload</span><span class="pun">[</span><span class="pln">len</span><span class="pun">(</span><span class="pln">payload</span><span class="pun">)</span><span class="">-</span><span class="pln">max_payload_len</span><span class="pun">:</span><span class="pun">]</span><span class="">.</span><span class="pln">lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">payload</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Round if it is necessary to keep self within prec precision.

        Rounds and fixes the exponent.  Does not raise on a sNaN.

        Arguments:
        self - Decimal instance
        context - context used.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="com"># decapitate payload if necessary</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="com"># self is +/-Infinity; return unaltered</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="com"># if self is zero then exponent should be between Etiny and</span><span class="">
        </span><span class="com"># Emax if _clamp==0, and between Etiny and Etop if _clamp==1.</span><span class="">
        </span><span class="pln">Etiny</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">Etop</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.Etop</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp_max</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pln">context.Emax</span><span class="pun">,</span><span class=""> </span><span class="pln">Etop</span><span class="pun">]</span><span class="pun">[</span><span class="pln">context._clamp</span><span class="pun">]</span><span class="">
            </span><span class="pln">new_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">max</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">Etiny</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">exp_max</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">new_exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Clamped</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">new_exp</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="com"># exp_min is the smallest allowable exponent of the result,</span><span class="">
        </span><span class="com"># equal to max(self.adjusted()-context.prec+1, Etiny)</span><span class="">
        </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">context.prec</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">Etop</span><span class="pun">:</span><span class="">
            </span><span class="com"># overflow: exp_min &gt; Etop iff self.adjusted() &gt; Emax</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;above Emax&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="pln">self_is_subnormal</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">Etiny</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_subnormal</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Etiny</span><span class="">

        </span><span class="com"># round if self has too many digits</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">exp_min</span><span class="pun">:</span><span class="">
            </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">exp_min</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">digits</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp_min</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
                </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="pln">rounding_method</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_pick_rounding_function</span><span class="pun">[</span><span class="pln">context.rounding</span><span class="pun">]</span><span class="">
            </span><span class="pln">changed</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding_method</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">digits</span><span class="pun">)</span><span class="">
            </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">digits</span><span class="pun">]</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">changed</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
                    </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">coeff</span><span class="pun">[</span><span class="pun">:</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class="">
                    </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

            </span><span class="com"># check whether the rounding pushed the exponent out of range</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp_min</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">Etop</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;above Emax&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp_min</span><span class="pun">)</span><span class="">

            </span><span class="com"># raise the appropriate signals, taking care to respect</span><span class="">
            </span><span class="com"># the precedence described in the specification</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">changed</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self_is_subnormal</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Underflow</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_subnormal</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Subnormal</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">changed</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="com"># raise Clamped on underflow to 0</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Clamped</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_subnormal</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Subnormal</span><span class="pun">)</span><span class="">

        </span><span class="com"># fold down if _clamp == 1 and self has too few digits</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context._clamp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">Etop</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Clamped</span><span class="pun">)</span><span class="">
            </span><span class="pln">self_padded</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">Etop</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">self_padded</span><span class="pun">,</span><span class=""> </span><span class="pln">Etop</span><span class="pun">)</span><span class="">

        </span><span class="com"># here self was representable to begin with; return unchanged</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="com"># for each of the rounding functions below:</span><span class="">
    </span><span class="com">#   self is a finite, nonzero Decimal</span><span class="">
    </span><span class="com">#   prec is an integer satisfying 0 &lt;= prec &lt; len(self._int)</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># each function returns either -1, 0, or 1, as follows:</span><span class="">
    </span><span class="com">#   1 indicates that self should be rounded up (away from zero)</span><span class="">
    </span><span class="com">#   0 indicates that self should be truncated, and that all the</span><span class="">
    </span><span class="com">#     digits to be truncated are zeros (so the value is unchanged)</span><span class="">
    </span><span class="com">#  -1 indicates that there are nonzero digits to be truncated</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Also known as round-towards-0, truncate.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_all_zeros</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_up</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds away from 0.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> -</span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_half_up</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds 5 up (away from 0)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">prec</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;56789&#39;</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">_all_zeros</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_half_down</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Round 5 down&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_exact_half</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round_half_up</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_half_even</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Round 5 to even, rest to nearest.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_exact_half</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> \
                </span><span class="pun">(</span><span class="pln">prec</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">prec</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;02468&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="dec">1</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round_half_up</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_ceiling</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds up (not away from 0 if negative.)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_floor</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds down (not towards 0 if negative)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round_05up</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Round down unless digit prec-1 is 0 or 5.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">prec</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">prec</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;05&#39;</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> -</span><span class="pln">self</span><span class="">.</span><span class="pln">_round_down</span><span class="pun">(</span><span class="pln">prec</span><span class="pun">)</span><span class="">

    </span><span class="pln">_pick_rounding_function</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dict</span><span class="pun">(</span><span class="">
        </span><span class="pln">ROUND_DOWN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_down</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_up</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_HALF_UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_half_up</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_HALF_DOWN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_half_down</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_HALF_EVEN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_half_even</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_CEILING</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_ceiling</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_FLOOR</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_floor</span><span class="pun">,</span><span class="">
        </span><span class="pln">ROUND_05UP</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_round_05up</span><span class="pun">,</span><span class="">
    </span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">fma</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">third</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Fused multiply-add.

        Returns self*other+third with no rounding of the intermediate
        product self*other.

        self and other are multiplied together, with no rounding of
        the result.  The third operand is then added to the result,
        and a single final rounding is performed.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="com"># compute product; raise InvalidOperation if either operand is</span><span class="">
        </span><span class="com"># a signaling NaN or if the product is zero times infinity.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">:</span><span class="">
                </span><span class="pln">product</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">:</span><span class="">
                </span><span class="pln">product</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                                </span><span class="str">&#39;INF * 0 in fma&#39;</span><span class="pun">)</span><span class="">
                </span><span class="pln">product</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">]</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                                </span><span class="str">&#39;0 * INF in fma&#39;</span><span class="pun">)</span><span class="">
                </span><span class="pln">product</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">]</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">product</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">^</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">,</span><span class="">
                                       </span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other._int</span><span class="pun">)</span><span class="pun">)</span><span class="pun">,</span><span class="">
                                       </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">)</span><span class="">

        </span><span class="pln">third</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">third</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">product.__add__</span><span class="pun">(</span><span class="pln">third</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_power_modulo</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Three argument version of __pow__&#34;&#34;&#34;</span><span class="">

        </span><span class="com"># if can&#39;t convert other and modulo to Decimal, raise</span><span class="">
        </span><span class="com"># TypeError; there&#39;s no point returning NotImplemented (no</span><span class="">
        </span><span class="com"># equivalent of __rpow__ for three argument pow)</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">modulo</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">modulo</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># deal with NaNs: if there are any sNaNs then first one wins,</span><span class="">
        </span><span class="com"># (i.e. behaviour for NaNs is identical to that of fma)</span><span class="">
        </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">modulo_is_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">modulo._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">modulo_is_nan</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_is_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">modulo_is_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sNaN&#39;</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">modulo</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_is_nan</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_is_nan</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">modulo._fix_nan</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="com"># check inputs: we apply same restrictions as Python&#39;s pow()</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_isinteger</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class="">
                </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class="">
                </span><span class="pln">modulo._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;pow() 3rd argument not allowed &#39;</span><span class="">
                                        </span><span class="str">&#39;unless all arguments are integers&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;pow() 2nd argument cannot be &#39;</span><span class="">
                                        </span><span class="str">&#39;negative when 3rd argument specified&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">modulo</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;pow() 3rd argument cannot be 0&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># additional restriction for decimal: the modulus must be less</span><span class="">
        </span><span class="com"># than 10**prec in absolute value</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">modulo.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;insufficient precision: pow() 3rd &#39;</span><span class="">
                                        </span><span class="str">&#39;argument must not have more than &#39;</span><span class="">
                                        </span><span class="str">&#39;precision digits&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># define 0**0 == NaN, for consistency with two-argument pow</span><span class="">
        </span><span class="com"># (even though it hurts!)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;at least one of pow() 1st argument &#39;</span><span class="">
                                        </span><span class="str">&#39;and 2nd argument must be nonzero ;&#39;</span><span class="">
                                        </span><span class="str">&#39;0**0 is not defined&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># compute sign of result</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._iseven</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">

        </span><span class="com"># convert modulo to a Python integer, and self and other to</span><span class="">
        </span><span class="com"># Decimal integers (i.e. force their exponents to be &gt;= 0)</span><span class="">
        </span><span class="pln">modulo</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">abs</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">modulo</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">base</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">to_integral_value</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">exponent</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other.to_integral_value</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="com"># compute result using integer pow()</span><span class="">
        </span><span class="pln">base</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">base.int</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">modulo</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">pow</span><span class="pun">(</span><span class="dec">10</span><span class="pun">,</span><span class=""> </span><span class="pln">base.exp</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">modulo</span><span class="">
        </span><span class="kwd">for</span><span class=""> </span><span class="pln">i</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">xrange</span><span class="pun">(</span><span class="pln">exponent.exp</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">base</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">pow</span><span class="pun">(</span><span class="pln">base</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">)</span><span class="">
        </span><span class="pln">base</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">pow</span><span class="pun">(</span><span class="pln">base</span><span class="pun">,</span><span class=""> </span><span class="pln">exponent.int</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">base</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_power_exact</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Attempt to compute self**other exactly.

        Given Decimals self and other and an integer p, attempt to
        compute an exact result for the power self**other, with p
        digits of precision.  Return None if self**other is not
        exactly representable in p digits.

        Assumes that elimination of special cases has already been
        performed: self and other must both be nonspecial; self must
        be positive and not numerically equal to 1; other must be
        nonzero.  For efficiency, other._exp should not be too large,
        so that 10**abs(other._exp) is a feasible calculation.&#34;&#34;&#34;</span><span class="">

        </span><span class="com"># In the comments below, we write x for the value of self and y for the</span><span class="">
        </span><span class="com"># value of other.  Write x = xc*10**xe and abs(y) = yc*10**ye, with xc</span><span class="">
        </span><span class="com"># and yc positive integers not divisible by 10.</span><span class="">

        </span><span class="com"># The main purpose of this method is to identify the *failure*</span><span class="">
        </span><span class="com"># of x**y to be exactly representable with as little effort as</span><span class="">
        </span><span class="com"># possible.  So we look for cheap and easy tests that</span><span class="">
        </span><span class="com"># eliminate the possibility of x**y being exact.  Only if all</span><span class="">
        </span><span class="com"># these tests are passed do we go on to actually compute x**y.</span><span class="">

        </span><span class="com"># Here&#39;s the main idea.  Express y as a rational number m/n, with m and</span><span class="">
        </span><span class="com"># n relatively prime and n&gt;0.  Then for x**y to be exactly</span><span class="">
        </span><span class="com"># representable (at *any* precision), xc must be the nth power of a</span><span class="">
        </span><span class="com"># positive integer and xe must be divisible by n.  If y is negative</span><span class="">
        </span><span class="com"># then additionally xc must be a power of either 2 or 5, hence a power</span><span class="">
        </span><span class="com"># of 2**n or 5**n.</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com"># There&#39;s a limit to how small |y| can be: if y=m/n as above</span><span class="">
        </span><span class="com"># then:</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com">#  (1) if xc != 1 then for the result to be representable we</span><span class="">
        </span><span class="com">#      need xc**(1/n) &gt;= 2, and hence also xc**|y| &gt;= 2.  So</span><span class="">
        </span><span class="com">#      if |y| &lt;= 1/nbits(xc) then xc &lt; 2**nbits(xc) &lt;=</span><span class="">
        </span><span class="com">#      2**(1/|y|), hence xc**|y| &lt; 2 and the result is not</span><span class="">
        </span><span class="com">#      representable.</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com">#  (2) if xe != 0, |xe|*(1/n) &gt;= 1, so |xe|*|y| &gt;= 1.  Hence if</span><span class="">
        </span><span class="com">#      |y| &lt; 1/|xe| then the result is not representable.</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com"># Note that since x is not equal to 1, at least one of (1) and</span><span class="">
        </span><span class="com"># (2) must apply.  Now |y| &lt; 1/nbits(xc) iff |yc|*nbits(xc) &lt;</span><span class="">
        </span><span class="com"># 10**-ye iff len(str(|yc|*nbits(xc)) &lt;= -ye.</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com"># There&#39;s also a limit to how large y can be, at least if it&#39;s</span><span class="">
        </span><span class="com"># positive: the normalized result will have coefficient xc**y,</span><span class="">
        </span><span class="com"># so if it&#39;s representable then xc**y &lt; 10**p, and y &lt;</span><span class="">
        </span><span class="com"># p/log10(xc).  Hence if y*log10(xc) &gt;= p then the result is</span><span class="">
        </span><span class="com"># not exactly representable.</span><span class="">

        </span><span class="com"># if len(str(abs(yc*xe)) &lt;= -ye then abs(yc*xe) &lt; 10**-ye,</span><span class="">
        </span><span class="com"># so |y| &lt; 1/xe and the result is not representable.</span><span class="">
        </span><span class="com"># Similarly, len(str(abs(yc)*xc_bits)) &lt;= -ye implies |y|</span><span class="">
        </span><span class="com"># &lt; 1/nbits(xc).</span><span class="">

        </span><span class="pln">x</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">x.int</span><span class="pun">,</span><span class=""> </span><span class="pln">x.exp</span><span class="">
        </span><span class="kwd">while</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">10</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">xc</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="">
            </span><span class="pln">xe</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">y.int</span><span class="pun">,</span><span class=""> </span><span class="pln">y.exp</span><span class="">
        </span><span class="kwd">while</span><span class=""> </span><span class="pln">yc</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">10</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">yc</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="">
            </span><span class="pln">ye</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="com"># case where xc == 1: result is 10**(xe*y), with xe*y</span><span class="">
        </span><span class="com"># required to be an integer</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">xe</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="pln">yc</span><span class="">
            </span><span class="com"># result is now 10**(xe * 10**ye);  xe * 10**ye must be integral</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">10</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">xe</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="">
                </span><span class="pln">ye</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">exponent</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">ye</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">y.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                </span><span class="pln">exponent</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">exponent</span><span class="">
            </span><span class="com"># if other is a nonnegative integer, use ideal exponent</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">ideal_exponent</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">*</span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
                </span><span class="pln">zeros</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">exponent</span><span class="">-</span><span class="pln">ideal_exponent</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">zeros</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">zeros</span><span class="pun">,</span><span class=""> </span><span class="pln">exponent</span><span class="">-</span><span class="pln">zeros</span><span class="pun">)</span><span class="">

        </span><span class="com"># case where y is negative: xc must be either a power</span><span class="">
        </span><span class="com"># of 2 or a power of 5.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">y.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">last_digit</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">10</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">last_digit</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="dec">2</span><span class="pun">,</span><span class="dec">4</span><span class="pun">,</span><span class="dec">6</span><span class="pun">,</span><span class="dec">8</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="com"># quick test for power of 2</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">&amp;</span><span class=""> -</span><span class="pln">xc</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">xc</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
                </span><span class="com"># now xc is a power of 2; e is its exponent</span><span class="">
                </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_nbits</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="">

                </span><span class="com"># We now have:</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com">#   x = 2**e * 10**xe, e &gt; 0, and y &lt; 0.</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com"># The exact result is:</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com">#   x**y = 5**(-e*y) * 10**(e*y + xe*y)</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com"># provided that both e*y and xe*y are integers.  Note that if</span><span class="">
                </span><span class="com"># 5**(-e*y) &gt;= 10**p, then the result can&#39;t be expressed</span><span class="">
                </span><span class="com"># exactly with p digits of precision.</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com"># Using the above, we can guard against large values of ye.</span><span class="">
                </span><span class="com"># 93/65 is an upper bound for log(10)/log(5), so if</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com">#   ye &gt;= len(str(93*p//65))</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com"># then</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com">#   -e*y &gt;= -y &gt;= 10**ye &gt; 93*p/65 &gt; p*log(10)/log(5),</span><span class="">
                </span><span class="com">#</span><span class="">
                </span><span class="com"># so 5**(-e*y) &gt;= 10**p, and the coefficient of the result</span><span class="">
                </span><span class="com"># can&#39;t be expressed in p digits.</span><span class="">

                </span><span class="com"># emax &gt;= largest e such that 5**e &lt; 10**p.</span><span class="">
                </span><span class="pln">emax</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">p</span><span class="">*</span><span class="dec">93</span><span class="pun">/</span><span class="">/</span><span class="dec">65</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">emax</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

                </span><span class="com"># Find -e*y and -xe*y; both must be integers</span><span class="">
                </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_decimal_lshift_exact</span><span class="pun">(</span><span class="pln">e</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">)</span><span class="">
                </span><span class="pln">xe</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_decimal_lshift_exact</span><span class="pun">(</span><span class="pln">xe</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

                </span><span class="kwd">if</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">emax</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
                </span><span class="pln">xc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">5</span><span class="pun">*</span><span class="">*</span><span class="pln">e</span><span class="">

            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">last_digit</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">5</span><span class="pun">:</span><span class="">
                </span><span class="com"># e &gt;= log_5(xc) if xc is a power of 5; we have</span><span class="">
                </span><span class="com"># equality all the way up to xc=5**2658</span><span class="">
                </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_nbits</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="">*</span><span class="dec">28</span><span class="pun">/</span><span class="">/</span><span class="dec">65</span><span class="">
                </span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="dec">5</span><span class="pun">*</span><span class="">*</span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">xc</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">remainder</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
                </span><span class="kwd">while</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">5</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="pln">xc</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">5</span><span class="">
                    </span><span class="pln">e</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

                </span><span class="com"># Guard against large values of ye, using the same logic as in</span><span class="">
                </span><span class="com"># the &#39;xc is a power of 2&#39; branch.  10/3 is an upper bound for</span><span class="">
                </span><span class="com"># log(10)/log(2).</span><span class="">
                </span><span class="pln">emax</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">p</span><span class="">*</span><span class="dec">10</span><span class="pun">/</span><span class="">/</span><span class="dec">3</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">emax</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

                </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_decimal_lshift_exact</span><span class="pun">(</span><span class="pln">e</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">)</span><span class="">
                </span><span class="pln">xe</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_decimal_lshift_exact</span><span class="pun">(</span><span class="pln">xe</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

                </span><span class="kwd">if</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">emax</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
                </span><span class="pln">xc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="pun">*</span><span class="">*</span><span class="pln">e</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">xe</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">e</span><span class="">-</span><span class="pln">xe</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class="pun">)</span><span class="">

        </span><span class="com"># now y is positive; find m and n such that y = m/n</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">m</span><span class="pun">,</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">yc</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">ye</span><span class="pun">,</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">yc</span><span class="">*</span><span class="pln">xe</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="pln">ye</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">xc_bits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_nbits</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">yc</span><span class="pun">)</span><span class="">*</span><span class="pln">xc_bits</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="pln">ye</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">m</span><span class="pun">,</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="">-</span><span class="pln">ye</span><span class="pun">)</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">m</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">2</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">2</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">m</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">m</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">5</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">5</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">m</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">5</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">5</span><span class="">

        </span><span class="com"># compute nth root of xc*10**xe</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="com"># if 1 &lt; xc &lt; 2**n then xc isn&#39;t an nth power</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">xc_bits</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">n</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

            </span><span class="pln">xe</span><span class="pun">,</span><span class=""> </span><span class="pln">rem</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">xe</span><span class="pun">,</span><span class=""> </span><span class="pln">n</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">rem</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

            </span><span class="com"># compute nth root of xc using Newton&#39;s method</span><span class="">
            </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1L</span><span class=""> </span><span class="pun">&lt;&lt;</span><span class=""> </span><span class="pun">-</span><span class="pun">(</span><span class="">-</span><span class="pln">_nbits</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="pun">/</span><span class="">/</span><span class="pln">n</span><span class="pun">)</span><span class=""> </span><span class="com"># initial estimate</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
                </span><span class="pln">q</span><span class="pun">,</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">n</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">a</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">q</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">break</span><span class="">
                </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                    </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">*</span><span class="pun">(</span><span class="pln">n</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">q</span><span class="pun">)</span><span class="pun">/</span><span class="">/</span><span class="pln">n</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="pln">a</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">xc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a</span><span class="">

        </span><span class="com"># now xc*10**xe is the nth root of the original xc*10**xe</span><span class="">
        </span><span class="com"># compute mth power of xc*10**xe</span><span class="">

        </span><span class="com"># if m &gt; p*100//_log10_lb(xc) then m &gt; p/log10(xc), hence xc**m &gt;</span><span class="">
        </span><span class="com"># 10**p and the result is not representable.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">m</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">p</span><span class="">*</span><span class="dec">100</span><span class="pun">/</span><span class="">/</span><span class="pln">_log10_lb</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">
        </span><span class="pln">xc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">xc</span><span class="pun">*</span><span class="">*</span><span class="pln">m</span><span class="">
        </span><span class="pln">xe</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="pln">m</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">xc</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class="">

        </span><span class="com"># by this point the result *is* exactly representable</span><span class="">
        </span><span class="com"># adjust the exponent to get as close as possible to the ideal</span><span class="">
        </span><span class="com"># exponent, if necessary</span><span class="">
        </span><span class="pln">str_xc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">ideal_exponent</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">*</span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="pln">zeros</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">xe</span><span class="">-</span><span class="pln">ideal_exponent</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">-</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str_xc</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">zeros</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">str_xc</span><span class="pun">+</span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">zeros</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class="">-</span><span class="pln">zeros</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__pow__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return self ** other [ % modulo].

        With two arguments, compute self**other.

        With three arguments, compute (self**other) % modulo.  For the
        three argument form, the following restrictions on the
        arguments hold:

         - all three arguments must be integral
         - other must be nonnegative
         - either self or other (or both) must be nonzero
         - modulo must be nonzero and must have at most p digits,
           where p is the context precision.

        If any of these restrictions is violated the InvalidOperation
        flag is raised.

        The result of pow(self, other, modulo) is identical to the
        result that would be obtained by computing (self**other) %
        modulo with unbounded precision, but is computed more
        efficiently.  It is always exact.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">modulo</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_power_modulo</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># either argument is a NaN =&gt; result is NaN</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># 0**0 = NaN (!), x**0 = 1 for nonzero x (including +/-Infinity)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0 ** 0&#39;</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">

        </span><span class="com"># result has sign 1 iff self._sign is 1 and other is an odd integer</span><span class="">
        </span><span class="pln">result_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._iseven</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="pln">result_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="com"># -ve**noninteger = NaN</span><span class="">
                </span><span class="com"># (-0)**noninteger = 0**noninteger</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                        </span><span class="str">&#39;x ** y with x negative and y not an integer&#39;</span><span class="pun">)</span><span class="">
            </span><span class="com"># negate self, without doing any unwanted rounding</span><span class="">
            </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_negate</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># 0**(+ve or Inf)= 0; 0**(-ve or -Inf) = Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">result_sign</span><span class="pun">]</span><span class="">

        </span><span class="com"># Inf**(+ve or Inf) = Inf; Inf**(-ve or -Inf) = 0</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">result_sign</span><span class="pun">]</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">

        </span><span class="com"># 1**other = 1, but the choice of exponent and the flags</span><span class="">
        </span><span class="com"># depend on the exponent of self, and on whether other is a</span><span class="">
        </span><span class="com"># positive integer, a negative integer, or neither</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">_One</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="com"># exp = max(self._exp*max(int(other), 0),</span><span class="">
                </span><span class="com"># 1-context.prec) but evaluating int(other) directly</span><span class="">
                </span><span class="com"># is dangerous until we know other is small (other</span><span class="">
                </span><span class="com"># could be 1e999999999)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="pln">multiplier</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
                </span><span class="kwd">elif</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
                    </span><span class="pln">multiplier</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">
                </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                    </span><span class="pln">multiplier</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

                </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">multiplier</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">1</span><span class="">-</span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
                    </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">-</span><span class="pln">context.prec</span><span class="">
                    </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
                </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">-</span><span class="pln">context.prec</span><span class="">

            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">+</span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="">-</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

        </span><span class="com"># compute adjusted exponent of self</span><span class="">
        </span><span class="pln">self_adj</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># self ** infinity is infinity if self &gt; 1, 0 if self &lt; 1</span><span class="">
        </span><span class="com"># self ** -infinity is infinity if self &lt; 1, 0 if self &gt; 1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">(</span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pun">(</span><span class="pln">self_adj</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_SignedInfinity</span><span class="pun">[</span><span class="pln">result_sign</span><span class="pun">]</span><span class="">

        </span><span class="com"># from here on, the result always goes through the call</span><span class="">
        </span><span class="com"># to _fix at the end of this function.</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">None</span><span class="">
        </span><span class="pln">exact</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">

        </span><span class="com"># crude test to catch cases of extreme overflow/underflow.  If</span><span class="">
        </span><span class="com"># log10(self)*other &gt;= 10**bound and bound &gt;= len(str(Emax))</span><span class="">
        </span><span class="com"># then 10**bound &gt;= 10**len(str(Emax)) &gt;= Emax+1 and hence</span><span class="">
        </span><span class="com"># self**other &gt;= 10**(Emax+1), so overflow occurs.  The test</span><span class="">
        </span><span class="com"># for underflow is similar.</span><span class="">
        </span><span class="pln">bound</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_log10_exp_bound</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">other.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">(</span><span class="pln">self_adj</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pun">(</span><span class="pln">other._sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># self &gt; 1 and other +ve, or self &lt; 1 and other -ve</span><span class="">
            </span><span class="com"># possibility of overflow</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">bound</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">context.Emax</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Emax</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># self &gt; 1 and other -ve, or self &lt; 1 and other +ve</span><span class="">
            </span><span class="com"># possibility of underflow to 0</span><span class="">
            </span><span class="pln">Etiny</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">bound</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="">-</span><span class="pln">Etiny</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">Etiny</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">

        </span><span class="com"># try for an exact result with precision +1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_power_exact</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">result_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="pln">ans._int</span><span class="pun">,</span><span class=""> </span><span class="pln">ans._exp</span><span class="pun">)</span><span class="">
                </span><span class="pln">exact</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="">

        </span><span class="com"># usual case: inexact result, x**y computed directly as exp(y*log(x))</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">p</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">
            </span><span class="pln">x</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">x.int</span><span class="pun">,</span><span class=""> </span><span class="pln">x.exp</span><span class="">
            </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
            </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">y.int</span><span class="pun">,</span><span class=""> </span><span class="pln">y.exp</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">y.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                </span><span class="pln">yc</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">yc</span><span class="">

            </span><span class="com"># compute correctly rounded result:  start with precision +3,</span><span class="">
            </span><span class="com"># then increase precision until result is unambiguously roundable</span><span class="">
            </span><span class="pln">extra</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dpower</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class="pun">,</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">+</span><span class="pln">extra</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="dec">5</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">break</span><span class="">
                </span><span class="pln">extra</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">

            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">result_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

        </span><span class="com"># unlike exp, ln and log10, the power function respects the</span><span class="">
        </span><span class="com"># rounding mode; no need to switch to ROUND_HALF_EVEN here</span><span class="">

        </span><span class="com"># There&#39;s a difficulty here when &#39;other&#39; is not an integer and</span><span class="">
        </span><span class="com"># the result is exact.  In this case, the specification</span><span class="">
        </span><span class="com"># requires that the Inexact flag be raised (in spite of</span><span class="">
        </span><span class="com"># exactness), but since the result is exact _fix won&#39;t do this</span><span class="">
        </span><span class="com"># for us.  (Correspondingly, the Underflow signal should also</span><span class="">
        </span><span class="com"># be raised for subnormal results.)  We can&#39;t directly raise</span><span class="">
        </span><span class="com"># these signals either before or after calling _fix, since</span><span class="">
        </span><span class="com"># that would violate the precedence for signals.  So we wrap</span><span class="">
        </span><span class="com"># the ._fix call in a temporary context, and reraise</span><span class="">
        </span><span class="com"># afterwards.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">exact</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._isinteger</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># pad with zeros up to length context.prec+1 if necessary; this</span><span class="">
            </span><span class="com"># ensures that the Rounded signal will be raised.</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">ans._int</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
                </span><span class="pln">expdiff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">ans._int</span><span class="pun">)</span><span class="">
                </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">ans._sign</span><span class="pun">,</span><span class=""> </span><span class="pln">ans._int</span><span class="pun">+</span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">expdiff</span><span class="pun">,</span><span class="">
                                       </span><span class="pln">ans._exp</span><span class="">-</span><span class="pln">expdiff</span><span class="pun">)</span><span class="">

            </span><span class="com"># create a copy of the current context, with cleared flags/traps</span><span class="">
            </span><span class="pln">newcontext</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">newcontext.clear_flags</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">for</span><span class=""> </span><span class="pln">exception</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">_signals</span><span class="pun">:</span><span class="">
                </span><span class="pln">newcontext.traps</span><span class="pun">[</span><span class="pln">exception</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

            </span><span class="com"># round in the new context</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">newcontext</span><span class="pun">)</span><span class="">

            </span><span class="com"># raise Inexact, and if necessary, Underflow</span><span class="">
            </span><span class="pln">newcontext._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">newcontext.flags</span><span class="pun">[</span><span class="pln">Subnormal</span><span class="pun">]</span><span class="pun">:</span><span class="">
                </span><span class="pln">newcontext._raise_error</span><span class="pun">(</span><span class="pln">Underflow</span><span class="pun">)</span><span class="">

            </span><span class="com"># propagate signals to the original context; _fix could</span><span class="">
            </span><span class="com"># have raised any of Overflow, Underflow, Subnormal,</span><span class="">
            </span><span class="com"># Inexact, Rounded, Clamped.  Overflow needs the correct</span><span class="">
            </span><span class="com"># arguments.  Note that the order of the exceptions is</span><span class="">
            </span><span class="com"># important here.</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">newcontext.flags</span><span class="pun">[</span><span class="pln">Overflow</span><span class="pun">]</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;above Emax&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">ans._sign</span><span class="pun">)</span><span class="">
            </span><span class="kwd">for</span><span class=""> </span><span class="pln">exception</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">Underflow</span><span class="pun">,</span><span class=""> </span><span class="pln">Subnormal</span><span class="pun">,</span><span class=""> </span><span class="pln">Inexact</span><span class="pun">,</span><span class=""> </span><span class="pln">Rounded</span><span class="pun">,</span><span class=""> </span><span class="pln">Clamped</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">newcontext.flags</span><span class="pun">[</span><span class="pln">exception</span><span class="pun">]</span><span class="pun">:</span><span class="">
                    </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">exception</span><span class="pun">)</span><span class="">

        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__rpow__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Swaps self/other and returns __pow__.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other.__pow__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">normalize</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Normalize- strip trailing 0s, change anything equal to 0 to 0e0&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="pln">dup</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">dup._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">dup</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">dup</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">dup._sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
        </span><span class="pln">exp_max</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pln">context.Emax</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etop</span><span class="pun">(</span><span class="pun">)</span><span class="pun">]</span><span class="pun">[</span><span class="pln">context._clamp</span><span class="pun">]</span><span class="">
        </span><span class="pln">end</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">dup._int</span><span class="pun">)</span><span class="">
        </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dup._exp</span><span class="">
        </span><span class="kwd">while</span><span class=""> </span><span class="pln">dup._int</span><span class="pun">[</span><span class="pln">end</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">exp_max</span><span class="pun">:</span><span class="">
            </span><span class="pln">exp</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
            </span><span class="pln">end</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">dup._sign</span><span class="pun">,</span><span class=""> </span><span class="pln">dup._int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">end</span><span class="pun">]</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">quantize</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">watchexp</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Quantize self so its exponent is the same as that of exp.

        Similar to self._rescale(exp._exp) but with error checking.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">rounding</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.rounding</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">exp._is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">  </span><span class="com"># if both are inf, it is OK</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;quantize with one INF&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># if we&#39;re not watching exponents, do a simple rescale</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">watchexp</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">exp._exp</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
            </span><span class="com"># raise Inexact and Rounded where appropriate</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans._exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                    </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># exp._exp should be between Etiny and Emax</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">exp._exp</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.Emax</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                   </span><span class="str">&#39;target exponent out of bounds in quantize&#39;</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp._exp</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.Emax</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;exponent of quantize result too large for current context&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_adjusted</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">exp._exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;quantize result has too many digits for current context&#39;</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">exp._exp</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.Emax</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;exponent of quantize result too large for current context&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">ans._int</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;quantize result has too many digits for current context&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># raise appropriate flags</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">ans.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">context.Emin</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Subnormal</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans._exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">

        </span><span class="com"># call to fix takes care of any necessary folddown, and</span><span class="">
        </span><span class="com"># signals Clamped if necessary</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">same_quantum</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self and other have the same exponent; otherwise
        return False.

        If either operand is a special value, the following rules are used:
           * return True if both operands are infinities
           * return True if both operands are NaNs
           * otherwise, return False.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">is_nan</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other.is_nan</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class="">
                    </span><span class="pln">self</span><span class="">.</span><span class="pln">is_infinite</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other.is_infinite</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">other._exp</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rescale self so that the exponent is exp, either by padding with zeros
        or by truncating digits, using the given rounding mode.

        Specials are returned without change.  This operation is
        quiet: it raises no flags, and uses no information from the
        context.

        exp = exp to scale to (an integer)
        rounding = rounding mode
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">exp</span><span class="pun">:</span><span class="">
            </span><span class="com"># pad answer with zeros if necessary</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class="">
                                        </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

        </span><span class="com"># too many digits; round and lose data.  If self.adjusted() &lt;</span><span class="">
        </span><span class="com"># exp-1, replace self by 10**(exp-1) before rounding</span><span class="">
        </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">exp</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">digits</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
            </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
        </span><span class="pln">this_function</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_pick_rounding_function</span><span class="pun">[</span><span class="pln">rounding</span><span class="pun">]</span><span class="">
        </span><span class="pln">changed</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">this_function</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">digits</span><span class="pun">)</span><span class="">
        </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">digits</span><span class="pun">]</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">changed</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_round</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">places</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Round a nonzero, nonspecial Decimal to a fixed number of
        significant figures, using the given rounding mode.

        Infinities, NaNs and zeros are returned unaltered.

        This operation is quiet: it raises no flags, and uses no
        information from the context.

        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">places</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;argument should be at least 1 in _round&#34;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="">-</span><span class="pln">places</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
        </span><span class="com"># it can happen that the rescale alters the adjusted exponent;</span><span class="">
        </span><span class="com"># for example when rounding 99.97 to 3 significant figures.</span><span class="">
        </span><span class="com"># When this happens we end up with an extra 0 at the end of</span><span class="">
        </span><span class="com"># the number; a second rescale fixes this.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._rescale</span><span class="pun">(</span><span class="pln">ans.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="">-</span><span class="pln">places</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_integral_exact</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds to a nearby integer.

        If no rounding mode is specified, take the rounding mode from
        the context.  This method raises the Rounded and Inexact flags
        when appropriate.

        See also: to_integral_value, which does exactly the same as
        this method except that it doesn&#39;t raise Inexact or Rounded.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">rounding</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.rounding</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
        </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_integral_value</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds to the nearest integer, without raising inexact, rounded.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">rounding</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.rounding</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">

    </span><span class="com"># the method name changed, but we provide also the old one, for compatibility</span><span class="">
    </span><span class="pln">to_integral</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">to_integral_value</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return the square root of self.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="com"># exponent = self._exp // 2.  sqrt(-0) = -0</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class=""> </span><span class="dec">2</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;sqrt(-x), x &gt; 0&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># At this point self represents a positive number.  Let p be</span><span class="">
        </span><span class="com"># the desired precision and express self in the form c*100**e</span><span class="">
        </span><span class="com"># with c a positive real number and e an integer, c and e</span><span class="">
        </span><span class="com"># being chosen so that 100**(p-1) &lt;= c &lt; 100**p.  Then the</span><span class="">
        </span><span class="com"># (exact) square root of self is sqrt(c)*10**e, and 10**(p-1)</span><span class="">
        </span><span class="com"># &lt;= sqrt(c) &lt; 10**p, so the closest representable Decimal at</span><span class="">
        </span><span class="com"># precision p is n*10**e where n = round_half_even(sqrt(c)),</span><span class="">
        </span><span class="com"># the closest integer to sqrt(c) with the even integer chosen</span><span class="">
        </span><span class="com"># in the case of a tie.</span><span class="">
        </span><span class="com">#</span><span class="">
        </span><span class="com"># To ensure correct rounding in all cases, we use the</span><span class="">
        </span><span class="com"># following trick: we compute the square root to an extra</span><span class="">
        </span><span class="com"># place (precision p+1 instead of precision p), rounding down.</span><span class="">
        </span><span class="com"># Then, if the result is inexact and its last digit is 0 or 5,</span><span class="">
        </span><span class="com"># we increase the last digit to 1 or 6 respectively; if it&#39;s</span><span class="">
        </span><span class="com"># exact we leave the last digit alone.  Now the final round to</span><span class="">
        </span><span class="com"># p places (or fewer in the case of underflow) will round</span><span class="">
        </span><span class="com"># correctly and raise the appropriate flags.</span><span class="">

        </span><span class="com"># use an extra digit of precision</span><span class="">
        </span><span class="pln">prec</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">+</span><span class="dec">1</span><span class="">

        </span><span class="com"># write argument in the form c*100**e where e = self._exp//2</span><span class="">
        </span><span class="com"># is the &#39;ideal&#39; exponent, to be used if the square root is</span><span class="">
        </span><span class="com"># exactly representable.  l is the number of &#39;digits&#39; of c in</span><span class="">
        </span><span class="com"># base 100, so that 100**(l-1) &lt;= c &lt; 100**l.</span><span class="">
        </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.exp</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">op.exp</span><span class=""> </span><span class="pun">&amp;</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="dec">10</span><span class="">
            </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="">
            </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="com"># rescale so that c has exactly prec base 100 &#39;digits&#39;</span><span class="">
        </span><span class="pln">shift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">prec</span><span class="">-</span><span class="pln">l</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">shift</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">100</span><span class="pun">*</span><span class="">*</span><span class="pln">shift</span><span class="">
            </span><span class="pln">exact</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">remainder</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="dec">100</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">shift</span><span class="pun">)</span><span class="">
            </span><span class="pln">exact</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">remainder</span><span class="">
        </span><span class="pln">e</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="pln">shift</span><span class="">

        </span><span class="com"># find n = floor(sqrt(c)) using Newton&#39;s method</span><span class="">
        </span><span class="pln">n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">prec</span><span class="">
        </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
            </span><span class="pln">q</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">c</span><span class="pun">/</span><span class="">/</span><span class="pln">n</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">q</span><span class="pun">:</span><span class="">
                </span><span class="kwd">break</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="pln">exact</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">exact</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">n</span><span class="">*</span><span class="pln">n</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">c</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">exact</span><span class="pun">:</span><span class="">
            </span><span class="com"># result is exact; rescale to use ideal exponent e</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">shift</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="com"># assert n % 10**shift == 0</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">shift</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">shift</span><span class="">
            </span><span class="pln">e</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="pln">shift</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># result is not exact; fix last digit as described above</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="dec">5</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                </span><span class="pln">n</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">)</span><span class="">

        </span><span class="com"># round, and fit to current context</span><span class="">
        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._shallow_copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the larger value.

        Like max(self, other) except if one is not a number, returns
        NaN (and signals if one is sNaN).  Also rounds.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="com"># If one operand is a quiet NaN and the other is number, then the</span><span class="">
            </span><span class="com"># number is always returned</span><span class="">
            </span><span class="pln">sn</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">on</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">on</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="com"># If both operands are finite and equal in numerical value</span><span class="">
            </span><span class="com"># then an ordering is applied:</span><span class="">
            </span><span class="com">#</span><span class="">
            </span><span class="com"># If the signs differ then max returns the operand with the</span><span class="">
            </span><span class="com"># positive sign and min returns the operand with the negative sign</span><span class="">
            </span><span class="com">#</span><span class="">
            </span><span class="com"># If the signs are the same then the exponent is used to select</span><span class="">
            </span><span class="com"># the result.  This is exactly the ordering used in compare_total.</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the smaller value.

        Like min(self, other) except if one is not a number, returns
        NaN (and signals if one is sNaN).  Also rounds.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="com"># If one operand is a quiet NaN and the other is number, then the</span><span class="">
            </span><span class="com"># number is always returned</span><span class="">
            </span><span class="pln">sn</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">on</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">on</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_isinteger</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns whether self is an integer&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">True</span><span class="">
        </span><span class="pln">rest</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">:</span><span class="pun">]</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">rest</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">len</span><span class="pun">(</span><span class="pln">rest</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_iseven</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns True if self is even.  Assumes self is an integer.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">True</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="">-</span><span class="dec">1</span><span class="">+</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;02468&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">adjusted</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return the adjusted exponent of self&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">try</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="com"># If NaN or Infinity, self._exp is string</span><span class="">
        </span><span class="kwd">except</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">canonical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the same Decimal object.

        As we do not have different encodings for the same number, the
        received object already is in its canonical form.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_signal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares self to the other operand numerically.

        It&#39;s pretty much like compare(), but all NaNs signal, with signaling
        NaNs taking precedence over quiet NaNs.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_compare_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">compare</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares self to other using the abstract representations.

        This is not like the standard compare, which use their numerical
        value. Note that a total ordering is defined for all possible abstract
        representations.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="com"># if one is negative and the other is positive, it&#39;s easy</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">other._sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
        </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="">

        </span><span class="com"># let&#39;s handle both NaN types</span><span class="">
        </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">other_nan</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other_nan</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">other_nan</span><span class="pun">:</span><span class="">
                </span><span class="com"># compare payloads as though they&#39;re integers</span><span class="">
                </span><span class="pln">self_key</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
                </span><span class="pln">other_key</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">other._int</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">other._int</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_key</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other_key</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class="pun">:</span><span class="">
                        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
                    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_key</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">other_key</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class="pun">:</span><span class="">
                        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
                    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Zero</span><span class="">

            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">self_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_nan</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">other</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">other._exp</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeOne</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Zero</span><span class="">


    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_total_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares self to other using abstract repr., ignoring sign.

        Like compare_total, but with operand&#39;s sign ignored and assumed to be 0.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="pln">s</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">o</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other.copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">s.compare_total</span><span class="pun">(</span><span class="pln">o</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy with the sign set to 0. &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_negate</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy with the sign inverted.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_sign</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns self with the sign of other.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">other._sign</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class="">
                                </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">exp</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns e ** self.&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># exp(NaN) = NaN</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># exp(-Infinity) = 0</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Zero</span><span class="">

        </span><span class="com"># exp(0) = 1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_One</span><span class="">

        </span><span class="com"># exp(Infinity) = Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="com"># the result is now guaranteed to be inexact (the true</span><span class="">
        </span><span class="com"># mathematical result is transcendental). There&#39;s no need to</span><span class="">
        </span><span class="com"># raise Rounded and Inexact here---they&#39;ll always be raised as</span><span class="">
        </span><span class="com"># a result of the call to _fix.</span><span class="">
        </span><span class="pln">p</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">
        </span><span class="pln">adj</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># we only need to do any computation for quite a small range</span><span class="">
        </span><span class="com"># of adjusted exponents---for example, -29 &lt;= adj &lt;= 10 for</span><span class="">
        </span><span class="com"># the default context.  For smaller exponent the result is</span><span class="">
        </span><span class="com"># indistinguishable from 1 at the given precision, while for</span><span class="">
        </span><span class="com"># larger exponent the result either overflows or underflows.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pun">(</span><span class="pln">context.Emax</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">*</span><span class="dec">3</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># overflow</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Emax</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pun">(</span><span class="">-</span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">*</span><span class="dec">3</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># underflow to 0</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&lt;</span><span class=""> -</span><span class="pln">p</span><span class="pun">:</span><span class="">
            </span><span class="com"># p+1 digits; final round will raise correct flags</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> -</span><span class="pln">p</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&lt;</span><span class=""> -</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="com"># p+1 digits; final round will raise correct flags</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">p</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="pun">,</span><span class=""> -</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="com"># general case</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">op.sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
                </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">c</span><span class="">

            </span><span class="com"># compute correctly rounded result: increase precision by</span><span class="">
            </span><span class="com"># 3 digits at a time until we get an unambiguously</span><span class="">
            </span><span class="com"># roundable result</span><span class="">
            </span><span class="pln">extra</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dexp</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">+</span><span class="pln">extra</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="dec">5</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">break</span><span class="">
                </span><span class="pln">extra</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">

            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">

        </span><span class="com"># at this stage, ans should round correctly with *any*</span><span class="">
        </span><span class="com"># rounding mode, not just with ROUND_HALF_EVEN</span><span class="">
        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._shallow_copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_canonical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is canonical; otherwise return False.

        Currently, the encoding of a Decimal instance is always
        canonical, so this method returns True for any Decimal.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">True</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_finite</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is finite; otherwise return False.

        A Decimal instance is considered finite if it is neither
        infinite nor a NaN.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_infinite</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is infinite; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;F&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_nan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a qNaN or sNaN; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pun">(</span><span class="str">&#39;n&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_normal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a normal number; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">context.Emin</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_qnan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a quiet NaN; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_signed</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is negative; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_snan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a signaling NaN; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;N&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_subnormal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is subnormal; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">context.Emin</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_zero</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a zero; otherwise return False.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_ln_exp_bound</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compute a lower bound for the adjusted exponent of self.ln().
        In other words, compute r such that self.ln() &gt;= 10**r.  Assumes
        that self is finite and positive and that self != 1.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="com"># for 0.1 &lt;= x &lt;= 10 we use the inequalities 1-1/x &lt;= ln(x) &lt;= x-1</span><span class="">
        </span><span class="pln">adj</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="com"># argument &gt;= 10; we use 23/10 = 2.3 as a lower bound for ln(10)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">adj</span><span class="">*</span><span class="dec">23</span><span class="pun">/</span><span class="">/</span><span class="dec">10</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="dec">2</span><span class="pun">:</span><span class="">
            </span><span class="com"># argument &lt;= 0.1</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="">-</span><span class="pln">adj</span><span class="pun">)</span><span class="">*</span><span class="dec">23</span><span class="pun">/</span><span class="">/</span><span class="dec">10</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="com"># 1 &lt; self &lt; 10</span><span class="">
            </span><span class="pln">num</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="">-</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">e</span><span class="pun">)</span><span class="">
            </span><span class="pln">den</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">num</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">den</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pun">(</span><span class="pln">num</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">den</span><span class="pun">)</span><span class="">
        </span><span class="com"># adj == -1, 0.1 &lt;= self &lt; 1</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">e</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">c</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">


    </span><span class="kwd">def</span><span class=""> </span><span class="pln">ln</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the natural (base e) logarithm of self.&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># ln(NaN) = NaN</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># ln(0.0) == -Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeInfinity</span><span class="">

        </span><span class="com"># ln(Infinity) = Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Infinity</span><span class="">

        </span><span class="com"># ln(1.0) == 0.0</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">_One</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Zero</span><span class="">

        </span><span class="com"># ln(negative) raises InvalidOperation</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;ln of a negative value&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># result is irrational, so necessarily inexact</span><span class="">
        </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="">
        </span><span class="pln">p</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">

        </span><span class="com"># correctly rounded result: repeatedly increase precision by 3</span><span class="">
        </span><span class="com"># until we get an unambiguously roundable result</span><span class="">
        </span><span class="pln">places</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_ln_exp_bound</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">2</span><span class=""> </span><span class="com"># at least p+3 places</span><span class="">
        </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
            </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dlog</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">places</span><span class="pun">)</span><span class="">
            </span><span class="com"># assert len(str(abs(coeff)))-p &gt;= 1</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="dec">5</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                </span><span class="kwd">break</span><span class="">
            </span><span class="pln">places</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">coeff</span><span class="">&lt;</span><span class="dec">0</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="pun">,</span><span class=""> -</span><span class="pln">places</span><span class="pun">)</span><span class="">

        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._shallow_copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_log10_exp_bound</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compute a lower bound for the adjusted exponent of self.log10().
        In other words, find r such that self.log10() &gt;= 10**r.
        Assumes that self is finite and positive and that self != 1.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="com"># For x &gt;= 10 or x &lt; 0.1 we only need a bound on the integer</span><span class="">
        </span><span class="com"># part of log10(self), and this comes directly from the</span><span class="">
        </span><span class="com"># exponent of x.  For 0.1 &lt;= x &lt;= 10 we use the inequalities</span><span class="">
        </span><span class="com"># 1-1/x &lt;= log(x) &lt;= x-1. If x &gt; 1 we have |log10(x)| &gt;</span><span class="">
        </span><span class="com"># (1-1/x)/2.31 &gt; 0.  If x &lt; 1 then |log10(x)| &gt; (1-x)/2.31 &gt; 0</span><span class="">

        </span><span class="pln">adj</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="com"># self &gt;= 10</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">adj</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> -</span><span class="dec">2</span><span class="pun">:</span><span class="">
            </span><span class="com"># self &lt; 0.1</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="">-</span><span class="pln">adj</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="">
        </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">adj</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="com"># 1 &lt; self &lt; 10</span><span class="">
            </span><span class="pln">num</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="">-</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">e</span><span class="pun">)</span><span class="">
            </span><span class="pln">den</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="dec">231</span><span class="">*</span><span class="pln">c</span><span class="pun">)</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">num</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">den</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pun">(</span><span class="pln">num</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">den</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">2</span><span class="">
        </span><span class="com"># adj == -1, 0.1 &lt;= self &lt; 1</span><span class="">
        </span><span class="pln">num</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">e</span><span class="">-</span><span class="pln">c</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">num</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pun">(</span><span class="pln">num</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="str">&#34;231&#34;</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">log10</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the base 10 logarithm of self.&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># log10(NaN) = NaN</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="com"># log10(0.0) == -Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeInfinity</span><span class="">

        </span><span class="com"># log10(Infinity) = Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Infinity</span><span class="">

        </span><span class="com"># log10(negative or -Infinity) raises InvalidOperation</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class="">
                                        </span><span class="str">&#39;log10 of a negative value&#39;</span><span class="pun">)</span><span class="">

        </span><span class="com"># log10(10**n) = n</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="dec">1</span><span class="pun">:</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># answer may need rounding</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># result is irrational, so necessarily inexact</span><span class="">
            </span><span class="pln">op</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">
            </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op.int</span><span class="pun">,</span><span class=""> </span><span class="pln">op.exp</span><span class="">
            </span><span class="pln">p</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="">

            </span><span class="com"># correctly rounded result: repeatedly increase precision</span><span class="">
            </span><span class="com"># until result is unambiguously roundable</span><span class="">
            </span><span class="pln">places</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">p</span><span class="">-</span><span class="pln">self</span><span class="">.</span><span class="pln">_log10_exp_bound</span><span class="pun">(</span><span class="pun">)</span><span class="">+</span><span class="dec">2</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
                </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dlog10</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">places</span><span class="pun">)</span><span class="">
                </span><span class="com"># assert len(str(abs(coeff)))-p &gt;= 1</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">coeff</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="dec">5</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">break</span><span class="">
                </span><span class="pln">places</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">coeff</span><span class="">&lt;</span><span class="dec">0</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">)</span><span class="pun">)</span><span class="pun">,</span><span class=""> -</span><span class="pln">places</span><span class="pun">)</span><span class="">

        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._shallow_copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">)</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="pln">context.rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logb</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34; Returns the exponent of the magnitude of self&#39;s MSD.

        The result is the integer which is the exponent of the magnitude
        of the most significant digit of self (as though it were truncated
        to a single digit while maintaining the value of that digit and
        without limiting the resulting exponent).
        &#34;&#34;&#34;</span><span class="">
        </span><span class="com"># logb(NaN) = NaN</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="com"># logb(+/-Inf) = +Inf</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Infinity</span><span class="">

        </span><span class="com"># logb(0) = -Inf, DivisionByZero</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;logb(0)&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">

        </span><span class="com"># otherwise, simply return the adjusted exponent of self, as a</span><span class="">
        </span><span class="com"># Decimal.  Note that no attempt is made to fit the result</span><span class="">
        </span><span class="com"># into the current context.</span><span class="">
        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">adjusted</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_islogical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if self is a logical operand.

        For being logical, it must be a finite number with a sign of 0,
        an exponent of 0, and a coefficient whose digits must all be
        either 0 or 1.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">for</span><span class=""> </span><span class="pln">dig</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">dig</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;01&#39;</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">False</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">True</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_fill_logical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">opa</span><span class="pun">,</span><span class=""> </span><span class="pln">opb</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">dif</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">opa</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">dif</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">opa</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">dif</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">opa</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">dif</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">opa</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">opa</span><span class="pun">[</span><span class="">-</span><span class="pln">context.prec</span><span class="pun">:</span><span class="pun">]</span><span class="">
        </span><span class="pln">dif</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">opb</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">dif</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">opb</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">dif</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">opb</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">dif</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">opb</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">opb</span><span class="pun">[</span><span class="">-</span><span class="pln">context.prec</span><span class="pun">:</span><span class="pun">]</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">opa</span><span class="pun">,</span><span class=""> </span><span class="pln">opb</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_and</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies an &#39;and&#39; operation between self and other&#39;s digits.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_islogical</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._islogical</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="com"># fill to context.prec</span><span class="">
        </span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class=""> </span><span class="pln">opb</span><span class="pun">)</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fill_logical</span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">other._int</span><span class="pun">)</span><span class="">

        </span><span class="com"># make the operation, and clean starting zeroes</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;&#34;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pun">[</span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="">&amp;</span><span class="pln">int</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">zip</span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class="pln">opb</span><span class="pun">)</span><span class="pun">]</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">result.lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_invert</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Invert all its digits.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">logical_xor</span><span class="pun">(</span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class="str">&#39;1&#39;</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">,</span><span class="dec">0</span><span class="pun">)</span><span class="pun">,</span><span class="">
                                </span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_or</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies an &#39;or&#39; operation between self and other&#39;s digits.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_islogical</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._islogical</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="com"># fill to context.prec</span><span class="">
        </span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class=""> </span><span class="pln">opb</span><span class="pun">)</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fill_logical</span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">other._int</span><span class="pun">)</span><span class="">

        </span><span class="com"># make the operation, and clean starting zeroes</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;&#34;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pun">[</span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="">|</span><span class="pln">int</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">zip</span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class="pln">opb</span><span class="pun">)</span><span class="pun">]</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">result.lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_xor</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies an &#39;xor&#39; operation between self and other&#39;s digits.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_islogical</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">other._islogical</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="com"># fill to context.prec</span><span class="">
        </span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class=""> </span><span class="pln">opb</span><span class="pun">)</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fill_logical</span><span class="pun">(</span><span class="pln">context</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">other._int</span><span class="pun">)</span><span class="">

        </span><span class="com"># make the operation, and clean starting zeroes</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;&#34;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pun">[</span><span class="pln">str</span><span class="pun">(</span><span class="pln">int</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="">^</span><span class="pln">int</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">zip</span><span class="pun">(</span><span class="pln">opa</span><span class="pun">,</span><span class="pln">opb</span><span class="pun">)</span><span class="pun">]</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">result.lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">max_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares the values numerically with their sign ignored.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="com"># If one operand is a quiet NaN and the other is number, then the</span><span class="">
            </span><span class="com"># number is always returned</span><span class="">
            </span><span class="pln">sn</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">on</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">on</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other.copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">min_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares the values numerically with their sign ignored.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">other._is_special</span><span class="pun">:</span><span class="">
            </span><span class="com"># If one operand is a quiet NaN and the other is number, then the</span><span class="">
            </span><span class="com"># number is always returned</span><span class="">
            </span><span class="pln">sn</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="pln">on</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other._isnan</span><span class="pun">(</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">on</span><span class="pun">:</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">sn</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">on</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">return</span><span class=""> </span><span class="pln">other._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other.copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_minus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the largest representable number smaller than itself.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_NegativeInfinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etop</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_FLOOR</span><span class="pun">)</span><span class="">
        </span><span class="pln">context._ignore_all_flags</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">new_self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">new_self</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">new_self</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__sub__</span><span class="pun">(</span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">,</span><span class="">
                            </span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_plus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the smallest representable number larger than itself.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_Infinity</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="">*</span><span class="pln">context.prec</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etop</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">

        </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">context._set_rounding</span><span class="pun">(</span><span class="pln">ROUND_CEILING</span><span class="pun">)</span><span class="">
        </span><span class="pln">context._ignore_all_flags</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">new_self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">new_self</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">self</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">new_self</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__add__</span><span class="pun">(</span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">context.Etiny</span><span class="pun">(</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">,</span><span class="">
                            </span><span class="pln">context</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_toward</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the number closest to self, in the direction towards other.

        The result is the closest representable number to self
        (excluding self) that is in the direction towards other,
        unless both have the same value.  If the two operands are
        numerically equal, then the result is a copy of self with the
        sign set to be the same as the sign of other.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="pln">comparison</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_cmp</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">comparison</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">copy_sign</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">comparison</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">next_plus</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class=""> </span><span class="com"># comparison == 1</span><span class="">
            </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">next_minus</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">

        </span><span class="com"># decide which flags to raise using value of ans</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans._isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Overflow</span><span class="pun">,</span><span class="">
                                 </span><span class="str">&#39;Infinite result from next_toward&#39;</span><span class="pun">,</span><span class="">
                                 </span><span class="pln">ans._sign</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">ans.adjusted</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">context.Emin</span><span class="pun">:</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Underflow</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Subnormal</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Inexact</span><span class="pun">)</span><span class="">
            </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Rounded</span><span class="pun">)</span><span class="">
            </span><span class="com"># if precision == 1 then we don&#39;t raise Clamped for a</span><span class="">
            </span><span class="com"># result 0E-Etiny.</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
                </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">Clamped</span><span class="pun">)</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">number_class</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns an indication of the class of self.

        The class is one of the following strings:
          sNaN
          NaN
          -Infinity
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Infinity
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;sNaN&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_qnan</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;NaN&#34;</span><span class="">
        </span><span class="pln">inf</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">inf</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;+Infinity&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">inf</span><span class=""> </span><span class="pun">==</span><span class=""> -</span><span class="dec">1</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;-Infinity&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_zero</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;-Zero&#34;</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;+Zero&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">is_subnormal</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">context</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;-Subnormal&#34;</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;+Subnormal&#34;</span><span class="">
        </span><span class="com"># just a normal, regular, boring number, :)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;-Normal&#34;</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;+Normal&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">radix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Just returns 10, as this is Decimal, :)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="dec">10</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">rotate</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a rotated copy of self, value-of-other times.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="pln">context.prec</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="com"># get values, pad if necessary</span><span class="">
        </span><span class="pln">torot</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
        </span><span class="pln">topad</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">rotdig</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">topad</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">topad</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">rotdig</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">topad</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rotdig</span><span class="pun">[</span><span class="">-</span><span class="pln">topad</span><span class="pun">:</span><span class="pun">]</span><span class="">

        </span><span class="com"># let&#39;s rotate!</span><span class="">
        </span><span class="pln">rotated</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rotdig</span><span class="pun">[</span><span class="pln">torot</span><span class="pun">:</span><span class="pun">]</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">rotdig</span><span class="pun">[</span><span class="pun">:</span><span class="pln">torot</span><span class="pun">]</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class="">
                                </span><span class="pln">rotated.lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">scaleb</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns self operand after adding the second value to its exp.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">
        </span><span class="pln">liminf</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="dec">2</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pun">(</span><span class="pln">context.Emax</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">)</span><span class="">
        </span><span class="pln">limsup</span><span class=""> </span><span class="pun">=</span><span class="">  </span><span class="dec">2</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pun">(</span><span class="pln">context.Emax</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="pln">liminf</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">limsup</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="pln">d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">d._fix</span><span class="pun">(</span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">d</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">shift</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a shifted copy of self, value-of-other times.&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">

        </span><span class="pln">ans</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_check_nans</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">ans</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">ans</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">other._exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pun">(</span><span class="">-</span><span class="pln">context.prec</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">context._raise_error</span><span class="pun">(</span><span class="pln">InvalidOperation</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_isinfinity</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

        </span><span class="com"># get values, pad if necessary</span><span class="">
        </span><span class="pln">torot</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
        </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
        </span><span class="pln">topad</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">rotdig</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">topad</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">topad</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">rotdig</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">topad</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rotdig</span><span class="pun">[</span><span class="">-</span><span class="pln">topad</span><span class="pun">:</span><span class="pun">]</span><span class="">

        </span><span class="com"># let&#39;s shift!</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">torot</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">shifted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rotdig</span><span class="pun">[</span><span class="pun">:</span><span class="pln">torot</span><span class="pun">]</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">shifted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rotdig</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">torot</span><span class="">
            </span><span class="pln">shifted</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">shifted</span><span class="pun">[</span><span class="">-</span><span class="pln">context.prec</span><span class="pun">:</span><span class="pun">]</span><span class="">

        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class="">
                                    </span><span class="pln">shifted.lstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="pun">)</span><span class="">

    </span><span class="com"># Support for pickling, copy, and deepcopy</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__reduce__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">__class__</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">,</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__copy__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">type</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">     </span><span class="com"># I&#39;m immutable; therefore I am my own clone</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__class__</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__deepcopy__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">memo</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">type</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">     </span><span class="com"># My components are also immutable</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">__class__</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="com"># PEP 3101 support.  the _localeconv keyword argument should be</span><span class="">
    </span><span class="com"># considered private: it&#39;s provided for ease of testing only.</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__format__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">specifier</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">_localeconv</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Format a Decimal instance according to the given specifier.

        The specifier should be a standard format specifier, with the
        form described in PEP 3101.  Formatting types &#39;e&#39;, &#39;E&#39;, &#39;f&#39;,
        &#39;F&#39;, &#39;g&#39;, &#39;G&#39;, &#39;n&#39; and &#39;%&#39; are supported.  If the formatting
        type is omitted it defaults to &#39;g&#39; or &#39;G&#39;, depending on the
        value of context.capitals.
        &#34;&#34;&#34;</span><span class="">

        </span><span class="com"># Note: PEP 3101 says that if the type is not present then</span><span class="">
        </span><span class="com"># there should be at least one digit after the decimal point.</span><span class="">
        </span><span class="com"># We take the liberty of ignoring this requirement for</span><span class="">
        </span><span class="com"># Decimal---it&#39;s presumably there to make sure that</span><span class="">
        </span><span class="com"># format(float, &#39;&#39;) behaves similarly to str(float).</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">context</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">

        </span><span class="pln">spec</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_parse_format_specifier</span><span class="pun">(</span><span class="pln">specifier</span><span class="pun">,</span><span class=""> </span><span class="pln">_localeconv</span><span class="">=</span><span class="pln">_localeconv</span><span class="pun">)</span><span class="">

        </span><span class="com"># special values don&#39;t care about the type or precision</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class="pun">:</span><span class="">
            </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_format_sign</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="">
            </span><span class="pln">body</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;%&#39;</span><span class="pun">:</span><span class="">
                </span><span class="pln">body</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="str">&#39;%&#39;</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">_format_align</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">body</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="">

        </span><span class="com"># a type of None defaults to &#39;g&#39; or &#39;G&#39;, depending on context</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="str">&#39;g&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;G&#39;</span><span class="pun">]</span><span class="pun">[</span><span class="pln">context.capitals</span><span class="pun">]</span><span class="">

        </span><span class="com"># if type is &#39;%&#39;, adjust exponent of self accordingly</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;%&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class="">+</span><span class="dec">2</span><span class="pun">)</span><span class="">

        </span><span class="com"># round if necessary, taking rounding mode from the context</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">context.rounding</span><span class="">
        </span><span class="pln">precision</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">precision</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;eE&#39;</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round</span><span class="pun">(</span><span class="pln">precision</span><span class="">+</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;fF%&#39;</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="">-</span><span class="pln">precision</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
            </span><span class="kwd">elif</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;gG&#39;</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">precision</span><span class="pun">:</span><span class="">
                </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_round</span><span class="pun">(</span><span class="pln">precision</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">
        </span><span class="com"># special case: zeros with a positive exponent can&#39;t be</span><span class="">
        </span><span class="com"># represented in fixed point; rescale them to 0e0.</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;fF%&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_rescale</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="pun">)</span><span class="">

        </span><span class="com"># figure out placement of the decimal point</span><span class="">
        </span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;eE&#39;</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">precision</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
                </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">precision</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;fF%&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">leftdigits</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;gG&#39;</span><span class="pun">:</span><span class="">
            </span><span class="kwd">if</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">leftdigits</span><span class=""> </span><span class="pun">&gt;</span><span class=""> -</span><span class="dec">6</span><span class="pun">:</span><span class="">
                </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">leftdigits</span><span class="">
            </span><span class="kwd">else</span><span class="pun">:</span><span class="">
                </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

        </span><span class="com"># find digits before and after decimal point, and get exponent</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="">-</span><span class="pln">dotplace</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">dotplace</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">dotplace</span><span class="">-</span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">)</span><span class="pun">)</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pun">:</span><span class="pln">dotplace</span><span class="pun">]</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">
            </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class="pun">[</span><span class="pln">dotplace</span><span class="pun">:</span><span class="pun">]</span><span class="">
        </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">leftdigits</span><span class="">-</span><span class="pln">dotplace</span><span class="">

        </span><span class="com"># done with the decimal-specific stuff;  hand over the rest</span><span class="">
        </span><span class="com"># of the formatting to the _format_number function</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">_format_number</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class="pun">,</span><span class=""> </span><span class="pln">intpart</span><span class="pun">,</span><span class=""> </span><span class="pln">fracpart</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_dec_from_triple</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">coefficient</span><span class="pun">,</span><span class=""> </span><span class="pln">exponent</span><span class="pun">,</span><span class=""> </span><span class="pln">special</span><span class="">=</span><span class="pln">False</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Create a decimal instance directly, without any validation,
    normalization (e.g. removal of leading zeros) or argument
    conversion.

    This function is for *internal use only*.
    &#34;&#34;&#34;</span><span class="">

    </span><span class="pln">self</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">object</span><span class="">.</span><span class="pln">__new__</span><span class="pun">(</span><span class="pln">Decimal</span><span class="pun">)</span><span class="">
    </span><span class="pln">self</span><span class="">.</span><span class="pln">_sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">sign</span><span class="">
    </span><span class="pln">self</span><span class="">.</span><span class="pln">_int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">coefficient</span><span class="">
    </span><span class="pln">self</span><span class="">.</span><span class="pln">_exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">exponent</span><span class="">
    </span><span class="pln">self</span><span class="">.</span><span class="pln">_is_special</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">special</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">

</span><span class="com"># Register Decimal as a kind of Number (an abstract base class).</span><span class="">
</span><span class="com"># However, do not register it as Real (because Decimals are not</span><span class="">
</span><span class="com"># interoperable with floats).</span><span class="">
</span><span class="pln">_numbers.Number.register</span><span class="pun">(</span><span class="pln">Decimal</span><span class="pun">)</span><span class="">


</span><span class="com">##### Context class #######################################################</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">_ContextManager</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Context manager class to support localcontext().

      Sets a copy of the supplied context in __enter__() and restores
      the previous decimal context in __exit__()
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">new_context</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">new_context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">new_context.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__enter__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">saved_context</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">getcontext</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="pln">setcontext</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">new_context</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">new_context</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__exit__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">t</span><span class="pun">,</span><span class=""> </span><span class="pln">v</span><span class="pun">,</span><span class=""> </span><span class="pln">tb</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">setcontext</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">saved_context</span><span class="pun">)</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Contains the context for a Decimal instance.

    Contains:
    prec - precision (for use in rounding, division, square roots..)
    rounding - rounding type (how you round)
    traps - If traps[exception] = 1, then the exception is
                    raised when it is caused.  Otherwise, a value is
                    substituted in.
    flags  - When an exception is caused, flags[exception] is set.
             (Whether or not the trap_enabler is set)
             Should be reset by user of Decimal instance.
    Emin -   Minimum exponent
    Emax -   Maximum exponent
    capitals -      If 1, 1*10^1 is printed as 1E+1.
                    If 0, printed as 1e1
    _clamp - If 1, change exponents if too high (Default 0)
    &#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class="">
                 </span><span class="pln">traps</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">flags</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class="">
                 </span><span class="pln">Emin</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">Emax</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class="">
                 </span><span class="pln">capitals</span><span class="">=</span><span class="pln">None</span><span class="pun">,</span><span class=""> </span><span class="pln">_clamp</span><span class="">=</span><span class="dec">0</span><span class="pun">,</span><span class="">
                 </span><span class="pln">_ignored_flags</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="com"># Set defaults; for everything except flags and _ignored_flags,</span><span class="">
        </span><span class="com"># inherit from DefaultContext.</span><span class="">
        </span><span class="kwd">try</span><span class="pun">:</span><span class="">
            </span><span class="pln">dc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">DefaultContext</span><span class="">
        </span><span class="kwd">except</span><span class=""> </span><span class="pln">NameError</span><span class="pun">:</span><span class="">
            </span><span class="kwd">pass</span><span class="">

        </span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">prec</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">prec</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc.prec</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">rounding</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">rounding</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc.rounding</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">Emin</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Emin</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">Emin</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc.Emin</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">Emax</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Emax</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">Emax</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc.Emax</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">capitals</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">capitals</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">capitals</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc.capitals</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">_clamp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_clamp</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">_clamp</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">dc._clamp</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_ignored_flags</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pun">]</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_ignored_flags</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">traps</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">traps</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dc.traps.copy</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">traps</span><span class="pun">,</span><span class=""> </span><span class="pln">dict</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">traps</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dict</span><span class="pun">(</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">s</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">traps</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">s</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">_signals</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">traps</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">traps</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">flags</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dict</span><span class="">.</span><span class="pln">fromkeys</span><span class="pun">(</span><span class="pln">_signals</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">flags</span><span class="pun">,</span><span class=""> </span><span class="pln">dict</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">dict</span><span class="pun">(</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">s</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">flags</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">s</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">_signals</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">flags</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__repr__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Show the current context.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">s</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pun">]</span><span class="">
        </span><span class="pln">s.append</span><span class="pun">(</span><span class="str">&#39;Context(prec=%(prec)d, rounding=%(rounding)s, &#39;</span><span class="">
                 </span><span class="str">&#39;Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d&#39;</span><span class="">
                 </span><span class="pun">%</span><span class=""> </span><span class="pln">vars</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">names</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pln">f.__name__</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">f</span><span class="pun">,</span><span class=""> </span><span class="pln">v</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">flags.items</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">v</span><span class="pun">]</span><span class="">
        </span><span class="pln">s.append</span><span class="pun">(</span><span class="str">&#39;flags=[&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;, &#39;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">names</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;]&#39;</span><span class="pun">)</span><span class="">
        </span><span class="pln">names</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pln">t.__name__</span><span class=""> </span><span class="kwd">for</span><span class=""> </span><span class="pln">t</span><span class="pun">,</span><span class=""> </span><span class="pln">v</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">traps.items</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">v</span><span class="pun">]</span><span class="">
        </span><span class="pln">s.append</span><span class="pun">(</span><span class="str">&#39;traps=[&#39;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;, &#39;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">names</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;]&#39;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="str">&#39;, &#39;</span><span class="">.</span><span class="pln">join</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="str">&#39;)&#39;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">clear_flags</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Reset all flags to zero&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">for</span><span class=""> </span><span class="pln">flag</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class="pun">[</span><span class="pln">flag</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_shallow_copy</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a shallow copy from self.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">nc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">rounding</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">traps</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">Emin</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">Emax</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">capitals</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_clamp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">nc</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a deep copy from self.&#34;&#34;&#34;</span><span class="">
        </span><span class="pln">nc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">rounding</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">traps.copy</span><span class="pun">(</span><span class="pun">)</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">flags.copy</span><span class="pun">(</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">Emin</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">Emax</span><span class="pun">,</span><span class="">
                     </span><span class="pln">self</span><span class="">.</span><span class="pln">capitals</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_clamp</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">nc</span><span class="">
    </span><span class="pln">__copy__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">copy</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_raise_error</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">condition</span><span class="pun">,</span><span class=""> </span><span class="pln">explanation</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">None</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Handles an error

        If the flag is in _ignored_flags, returns the default response.
        Otherwise, it sets the flag, then, if the corresponding
        trap_enabler is set, it reraises the exception.  Otherwise, it returns
        the default value after setting the flag.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">error</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_condition_map.get</span><span class="pun">(</span><span class="pln">condition</span><span class="pun">,</span><span class=""> </span><span class="pln">condition</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">error</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class="pun">:</span><span class="">
            </span><span class="com"># Don&#39;t touch the flag</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">error</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="">

        </span><span class="pln">self</span><span class="">.</span><span class="pln">flags</span><span class="pun">[</span><span class="pln">error</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">traps</span><span class="pun">[</span><span class="pln">error</span><span class="pun">]</span><span class="pun">:</span><span class="">
            </span><span class="com"># The errors define how to handle themselves.</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">condition</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">handle</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> *</span><span class="pln">args</span><span class="pun">)</span><span class="">

        </span><span class="com"># Errors should only be risked on copies of the context</span><span class="">
        </span><span class="com"># self._ignored_flags = []</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">error</span><span class="pun">(</span><span class="pln">explanation</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_ignore_all_flags</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Ignore all flags, if they are raised&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignore_flags</span><span class="pun">(</span><span class="">*</span><span class="pln">_signals</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_ignore_flags</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> *</span><span class="pln">flags</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Ignore the flags, if they are raised&#34;&#34;&#34;</span><span class="">
        </span><span class="com"># Do not mutate-- This way, copies of a context leave the original</span><span class="">
        </span><span class="com"># alone.</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">list</span><span class="pun">(</span><span class="pln">flags</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">list</span><span class="pun">(</span><span class="pln">flags</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_regard_flags</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> *</span><span class="pln">flags</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Stop ignoring the flags, if they are raised&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">flags</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">flags</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">tuple</span><span class="pun">,</span><span class="pln">list</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">flags</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">flags</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">
        </span><span class="kwd">for</span><span class=""> </span><span class="pln">flag</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">flags</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">_ignored_flags.remove</span><span class="pun">(</span><span class="pln">flag</span><span class="pun">)</span><span class="">

    </span><span class="com"># We inherit object.__hash__, so we must deny this explicitly</span><span class="">
    </span><span class="pln">__hash__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">None</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">Etiny</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns Etiny (= Emin - prec + 1)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">Emin</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">Etop</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns maximum exponent (= Emax - prec + 1)&#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">Emax</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_set_rounding</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">type</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Sets the rounding type.

        Sets the rounding type, and returns the current (previous)
        rounding type.  Often used like:

        context = context.copy()
        # so you don&#39;t change the calling context
        # if an error occurs in the middle.
        rounding = context._set_rounding(ROUND_UP)
        val = self.__sub__(other, context=context)
        context._set_rounding(rounding)

        This will make it round up for that operation.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">rounding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">rounding</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">rounding</span><span class="pun">=</span><span class=""> </span><span class="pln">type</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">rounding</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">create_decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">num</span><span class="pun">=</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Creates a new Decimal instance but using self as context.

        This method implements the to-number operation of the
        IBM Decimal specification.&#34;&#34;&#34;</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">num</span><span class="pun">,</span><span class=""> </span><span class="pln">basestring</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">num</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">num.strip</span><span class="pun">(</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_raise_error</span><span class="pun">(</span><span class="pln">ConversionSyntax</span><span class="pun">,</span><span class="">
                                     </span><span class="str">&#34;no trailing or leading whitespace is &#34;</span><span class="">
                                     </span><span class="str">&#34;permitted.&#34;</span><span class="pun">)</span><span class="">

        </span><span class="pln">d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">num</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">d._isnan</span><span class="pun">(</span><span class="pun">)</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">d._int</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_clamp</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">_raise_error</span><span class="pun">(</span><span class="pln">ConversionSyntax</span><span class="pun">,</span><span class="">
                                     </span><span class="str">&#34;diagnostic info too long in NaN&#34;</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">d._fix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">create_decimal_from_float</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">f</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Creates a new Decimal instance from a float but rounding using self
        as the context.

        &gt;&gt;&gt; context = Context(prec=5, rounding=ROUND_DOWN)
        &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)
        Decimal(&#39;3.1415&#39;)
        &gt;&gt;&gt; context = Context(prec=5, traps=[Inexact])
        &gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)
        Traceback (most recent call last):
            ...
        Inexact: None

        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal.from_float</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="">       </span><span class="com"># An exact conversion</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">d._fix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="">             </span><span class="com"># Apply the context rounding</span><span class="">

    </span><span class="com"># Methods</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">abs</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the absolute value of the operand.

        If the operand is negative, the result is the same as using the minus
        operation on the operand.  Otherwise, the result is the same as using
        the plus operation on the operand.

        &gt;&gt;&gt; ExtendedContext.abs(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2.1&#39;)
        &gt;&gt;&gt; ExtendedContext.abs(Decimal(&#39;-100&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.abs(Decimal(&#39;101.5&#39;))
        Decimal(&#39;101.5&#39;)
        &gt;&gt;&gt; ExtendedContext.abs(Decimal(&#39;-101.5&#39;))
        Decimal(&#39;101.5&#39;)
        &gt;&gt;&gt; ExtendedContext.abs(-1)
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.__abs__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">add</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return the sum of the two operands.

        &gt;&gt;&gt; ExtendedContext.add(Decimal(&#39;12&#39;), Decimal(&#39;7.00&#39;))
        Decimal(&#39;19.00&#39;)
        &gt;&gt;&gt; ExtendedContext.add(Decimal(&#39;1E+2&#39;), Decimal(&#39;1.01E+4&#39;))
        Decimal(&#39;1.02E+4&#39;)
        &gt;&gt;&gt; ExtendedContext.add(1, Decimal(2))
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.add(Decimal(8), 5)
        Decimal(&#39;13&#39;)
        &gt;&gt;&gt; ExtendedContext.add(5, 5)
        Decimal(&#39;10&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__add__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">_apply</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">a._fix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">canonical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the same Decimal object.

        As we do not have different encodings for the same number, the
        received object already is in its canonical form.

        &gt;&gt;&gt; ExtendedContext.canonical(Decimal(&#39;2.50&#39;))
        Decimal(&#39;2.50&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.canonical</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares values numerically.

        If the signs of the operands differ, a value representing each operand
        (&#39;-1&#39; if the operand is less than zero, &#39;0&#39; if the operand is zero or
        negative zero, or &#39;1&#39; if the operand is greater than zero) is used in
        place of that operand for the comparison instead of the actual
        operand.

        The comparison is then effected by subtracting the second operand from
        the first and then returning a value according to the result of the
        subtraction: &#39;-1&#39; if the result is less than zero, &#39;0&#39; if the result is
        zero or negative zero, or &#39;1&#39; if the result is greater than zero.

        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;2.1&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;2.1&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;2.1&#39;), Decimal(&#39;2.10&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;3&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;2.1&#39;), Decimal(&#39;-3&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(&#39;-3&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(1, 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(Decimal(1), 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare(1, Decimal(2))
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.compare</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_signal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares the values of the two operands numerically.

        It&#39;s pretty much like compare(), but all NaNs signal, with signaling
        NaNs taking precedence over quiet NaNs.

        &gt;&gt;&gt; c = ExtendedContext
        &gt;&gt;&gt; c.compare_signal(Decimal(&#39;2.1&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; c.compare_signal(Decimal(&#39;2.1&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; c.flags[InvalidOperation] = 0
        &gt;&gt;&gt; print c.flags[InvalidOperation]
        0
        &gt;&gt;&gt; c.compare_signal(Decimal(&#39;NaN&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; print c.flags[InvalidOperation]
        1
        &gt;&gt;&gt; c.flags[InvalidOperation] = 0
        &gt;&gt;&gt; print c.flags[InvalidOperation]
        0
        &gt;&gt;&gt; c.compare_signal(Decimal(&#39;sNaN&#39;), Decimal(&#39;2.1&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; print c.flags[InvalidOperation]
        1
        &gt;&gt;&gt; c.compare_signal(-1, 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; c.compare_signal(Decimal(-1), 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; c.compare_signal(-1, Decimal(2))
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.compare_signal</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_total</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares two operands using their abstract representation.

        This is not like the standard compare, which use their numerical
        value. Note that a total ordering is defined for all possible abstract
        representations.

        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;12.73&#39;), Decimal(&#39;127.9&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;-127&#39;),  Decimal(&#39;12&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;12.30&#39;), Decimal(&#39;12.3&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;12.30&#39;), Decimal(&#39;12.30&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;12.3&#39;),  Decimal(&#39;12.300&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(&#39;12.3&#39;),  Decimal(&#39;NaN&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(1, 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(Decimal(1), 2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.compare_total(1, Decimal(2))
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.compare_total</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">compare_total_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares two operands using their abstract representation ignoring sign.

        Like compare_total, but with operand&#39;s sign ignored and assumed to be 0.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.compare_total_mag</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_abs</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy of the operand with the sign set to 0.

        &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2.1&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_abs(Decimal(&#39;-100&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_abs(-1)
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.copy_abs</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_decimal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy of the decimal object.

        &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2.1&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal(&#39;-1.00&#39;))
        Decimal(&#39;-1.00&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_decimal(1)
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_negate</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a copy of the operand with the sign inverted.

        &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal(&#39;101.5&#39;))
        Decimal(&#39;-101.5&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_negate(Decimal(&#39;-101.5&#39;))
        Decimal(&#39;101.5&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_negate(1)
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.copy_negate</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">copy_sign</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Copies the second operand&#39;s sign to the first one.

        In detail, it returns a copy of the first operand with the sign
        equal to the sign of the second operand.

        &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( &#39;1.50&#39;), Decimal(&#39;7.33&#39;))
        Decimal(&#39;1.50&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(&#39;-1.50&#39;), Decimal(&#39;7.33&#39;))
        Decimal(&#39;1.50&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( &#39;1.50&#39;), Decimal(&#39;-7.33&#39;))
        Decimal(&#39;-1.50&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(&#39;-1.50&#39;), Decimal(&#39;-7.33&#39;))
        Decimal(&#39;-1.50&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(1, -2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(1), -2)
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.copy_sign(1, Decimal(-2))
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.copy_sign</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">divide</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Decimal division in a specified context.

        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;1&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;0.333333333&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;2&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;0.666666667&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;5&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;2.5&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;1&#39;), Decimal(&#39;10&#39;))
        Decimal(&#39;0.1&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;12&#39;), Decimal(&#39;12&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;8.00&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;4.00&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;2.400&#39;), Decimal(&#39;2.0&#39;))
        Decimal(&#39;1.20&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;1000&#39;), Decimal(&#39;100&#39;))
        Decimal(&#39;10&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;1000&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1000&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(&#39;2.40E+6&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;1.20E+6&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(5, 5)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(Decimal(5), 5)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.divide(5, Decimal(5))
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__div__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">divide_int</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Divides two numbers and returns the integer part of the result.

        &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(&#39;2&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(&#39;10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(&#39;1&#39;), Decimal(&#39;0.3&#39;))
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.divide_int(10, 3)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.divide_int(Decimal(10), 3)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.divide_int(10, Decimal(3))
        Decimal(&#39;3&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__floordiv__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return (a // b, a % b).

        &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(3))
        (Decimal(&#39;2&#39;), Decimal(&#39;2&#39;))
        &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(4))
        (Decimal(&#39;2&#39;), Decimal(&#39;0&#39;))
        &gt;&gt;&gt; ExtendedContext.divmod(8, 4)
        (Decimal(&#39;2&#39;), Decimal(&#39;0&#39;))
        &gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), 4)
        (Decimal(&#39;2&#39;), Decimal(&#39;0&#39;))
        &gt;&gt;&gt; ExtendedContext.divmod(8, Decimal(4))
        (Decimal(&#39;2&#39;), Decimal(&#39;0&#39;))
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__divmod__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">exp</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns e ** a.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.exp(Decimal(&#39;-Infinity&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; c.exp(Decimal(&#39;-1&#39;))
        Decimal(&#39;0.367879441&#39;)
        &gt;&gt;&gt; c.exp(Decimal(&#39;0&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; c.exp(Decimal(&#39;1&#39;))
        Decimal(&#39;2.71828183&#39;)
        &gt;&gt;&gt; c.exp(Decimal(&#39;0.693147181&#39;))
        Decimal(&#39;2.00000000&#39;)
        &gt;&gt;&gt; c.exp(Decimal(&#39;+Infinity&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; c.exp(10)
        Decimal(&#39;22026.4658&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> =</span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.exp</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">fma</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">c</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a multiplied by b, plus c.

        The first two operands are multiplied together, using multiply,
        the third operand is then added to the result of that
        multiplication, using add, all with only one final rounding.

        &gt;&gt;&gt; ExtendedContext.fma(Decimal(&#39;3&#39;), Decimal(&#39;5&#39;), Decimal(&#39;7&#39;))
        Decimal(&#39;22&#39;)
        &gt;&gt;&gt; ExtendedContext.fma(Decimal(&#39;3&#39;), Decimal(&#39;-5&#39;), Decimal(&#39;7&#39;))
        Decimal(&#39;-8&#39;)
        &gt;&gt;&gt; ExtendedContext.fma(Decimal(&#39;888565290&#39;), Decimal(&#39;1557.96930&#39;), Decimal(&#39;-86087.7578&#39;))
        Decimal(&#39;1.38435736E+12&#39;)
        &gt;&gt;&gt; ExtendedContext.fma(1, 3, 4)
        Decimal(&#39;7&#39;)
        &gt;&gt;&gt; ExtendedContext.fma(1, Decimal(3), 4)
        Decimal(&#39;7&#39;)
        &gt;&gt;&gt; ExtendedContext.fma(1, 3, Decimal(4))
        Decimal(&#39;7&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.fma</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_canonical</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is canonical; otherwise return False.

        Currently, the encoding of a Decimal instance is always
        canonical, so this method returns True for any Decimal.

        &gt;&gt;&gt; ExtendedContext.is_canonical(Decimal(&#39;2.50&#39;))
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_canonical</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_finite</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is finite; otherwise return False.

        A Decimal instance is considered finite if it is neither
        infinite nor a NaN.

        &gt;&gt;&gt; ExtendedContext.is_finite(Decimal(&#39;2.50&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_finite(Decimal(&#39;-0.3&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_finite(Decimal(&#39;0&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_finite(Decimal(&#39;Inf&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_finite(Decimal(&#39;NaN&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_finite(1)
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_finite</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_infinite</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is infinite; otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal(&#39;-Inf&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_infinite(Decimal(&#39;NaN&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_infinite(1)
        False
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_infinite</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_nan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is a qNaN or sNaN;
        otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_nan(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_nan(Decimal(&#39;NaN&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_nan(Decimal(&#39;-sNaN&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_nan(1)
        False
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_nan</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_normal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is a normal number;
        otherwise return False.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.is_normal(Decimal(&#39;2.50&#39;))
        True
        &gt;&gt;&gt; c.is_normal(Decimal(&#39;0.1E-999&#39;))
        False
        &gt;&gt;&gt; c.is_normal(Decimal(&#39;0.00&#39;))
        False
        &gt;&gt;&gt; c.is_normal(Decimal(&#39;-Inf&#39;))
        False
        &gt;&gt;&gt; c.is_normal(Decimal(&#39;NaN&#39;))
        False
        &gt;&gt;&gt; c.is_normal(1)
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_normal</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_qnan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is a quiet NaN; otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal(&#39;NaN&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_qnan(Decimal(&#39;sNaN&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_qnan(1)
        False
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_qnan</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_signed</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is negative; otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_signed(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_signed(Decimal(&#39;-12&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_signed(Decimal(&#39;-0&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_signed(8)
        False
        &gt;&gt;&gt; ExtendedContext.is_signed(-8)
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_signed</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_snan</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is a signaling NaN;
        otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_snan(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_snan(Decimal(&#39;NaN&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_snan(Decimal(&#39;sNaN&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_snan(1)
        False
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_snan</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_subnormal</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is subnormal; otherwise return False.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.is_subnormal(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; c.is_subnormal(Decimal(&#39;0.1E-999&#39;))
        True
        &gt;&gt;&gt; c.is_subnormal(Decimal(&#39;0.00&#39;))
        False
        &gt;&gt;&gt; c.is_subnormal(Decimal(&#39;-Inf&#39;))
        False
        &gt;&gt;&gt; c.is_subnormal(Decimal(&#39;NaN&#39;))
        False
        &gt;&gt;&gt; c.is_subnormal(1)
        False
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_subnormal</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">is_zero</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return True if the operand is a zero; otherwise return False.

        &gt;&gt;&gt; ExtendedContext.is_zero(Decimal(&#39;0&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_zero(Decimal(&#39;2.50&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.is_zero(Decimal(&#39;-0E+2&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.is_zero(1)
        False
        &gt;&gt;&gt; ExtendedContext.is_zero(0)
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.is_zero</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">ln</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the natural (base e) logarithm of the operand.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.ln(Decimal(&#39;0&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; c.ln(Decimal(&#39;1.000&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; c.ln(Decimal(&#39;2.71828183&#39;))
        Decimal(&#39;1.00000000&#39;)
        &gt;&gt;&gt; c.ln(Decimal(&#39;10&#39;))
        Decimal(&#39;2.30258509&#39;)
        &gt;&gt;&gt; c.ln(Decimal(&#39;+Infinity&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; c.ln(1)
        Decimal(&#39;0&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.ln</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">log10</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the base 10 logarithm of the operand.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.log10(Decimal(&#39;0&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;0.001&#39;))
        Decimal(&#39;-3&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;1.000&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;2&#39;))
        Decimal(&#39;0.301029996&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;10&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;70&#39;))
        Decimal(&#39;1.84509804&#39;)
        &gt;&gt;&gt; c.log10(Decimal(&#39;+Infinity&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; c.log10(0)
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; c.log10(1)
        Decimal(&#39;0&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.log10</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logb</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34; Returns the exponent of the magnitude of the operand&#39;s MSD.

        The result is the integer which is the exponent of the magnitude
        of the most significant digit of the operand (as though the
        operand were truncated to a single digit while maintaining the
        value of that digit and without limiting the resulting exponent).

        &gt;&gt;&gt; ExtendedContext.logb(Decimal(&#39;250&#39;))
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(Decimal(&#39;2.50&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(Decimal(&#39;0.03&#39;))
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(Decimal(&#39;0&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(1)
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(10)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logb(100)
        Decimal(&#39;2&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.logb</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_and</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies the logical operation &#39;and&#39; between each operand&#39;s digits.

        The operands must be both logical numbers.

        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;0&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;0&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;1&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;1&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;1100&#39;), Decimal(&#39;1010&#39;))
        Decimal(&#39;1000&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(&#39;1111&#39;), Decimal(&#39;10&#39;))
        Decimal(&#39;10&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(110, 1101)
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(Decimal(110), 1101)
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_and(110, Decimal(1101))
        Decimal(&#39;100&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.logical_and</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_invert</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Invert all the digits in the operand.

        The operand must be a logical number.

        &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal(&#39;0&#39;))
        Decimal(&#39;111111111&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal(&#39;1&#39;))
        Decimal(&#39;111111110&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal(&#39;111111111&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_invert(Decimal(&#39;101010101&#39;))
        Decimal(&#39;10101010&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_invert(1101)
        Decimal(&#39;111110010&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.logical_invert</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_or</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies the logical operation &#39;or&#39; between each operand&#39;s digits.

        The operands must be both logical numbers.

        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;0&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;0&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;1&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;1&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;1100&#39;), Decimal(&#39;1010&#39;))
        Decimal(&#39;1110&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(&#39;1110&#39;), Decimal(&#39;10&#39;))
        Decimal(&#39;1110&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(110, 1101)
        Decimal(&#39;1111&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(Decimal(110), 1101)
        Decimal(&#39;1111&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_or(110, Decimal(1101))
        Decimal(&#39;1111&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.logical_or</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">logical_xor</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Applies the logical operation &#39;xor&#39; between each operand&#39;s digits.

        The operands must be both logical numbers.

        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;0&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;0&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;1&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;1&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;1100&#39;), Decimal(&#39;1010&#39;))
        Decimal(&#39;110&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(&#39;1111&#39;), Decimal(&#39;10&#39;))
        Decimal(&#39;1101&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(110, 1101)
        Decimal(&#39;1011&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(110), 1101)
        Decimal(&#39;1011&#39;)
        &gt;&gt;&gt; ExtendedContext.logical_xor(110, Decimal(1101))
        Decimal(&#39;1011&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.logical_xor</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;max compares two values numerically and returns the maximum.

        If either operand is a NaN then the general rules apply.
        Otherwise, the operands are compared as though by the compare
        operation.  If they are numerically equal then the left-hand operand
        is chosen as the result.  Otherwise the maximum (closer to positive
        infinity) of the two operands is chosen as the result.

        &gt;&gt;&gt; ExtendedContext.max(Decimal(&#39;3&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.max(Decimal(&#39;-10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.max(Decimal(&#39;1.0&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.max(Decimal(&#39;7&#39;), Decimal(&#39;NaN&#39;))
        Decimal(&#39;7&#39;)
        &gt;&gt;&gt; ExtendedContext.max(1, 2)
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.max(Decimal(1), 2)
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.max(1, Decimal(2))
        Decimal(&#39;2&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.max</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">max_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares the values numerically with their sign ignored.

        &gt;&gt;&gt; ExtendedContext.max_mag(Decimal(&#39;7&#39;), Decimal(&#39;NaN&#39;))
        Decimal(&#39;7&#39;)
        &gt;&gt;&gt; ExtendedContext.max_mag(Decimal(&#39;7&#39;), Decimal(&#39;-10&#39;))
        Decimal(&#39;-10&#39;)
        &gt;&gt;&gt; ExtendedContext.max_mag(1, -2)
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.max_mag(Decimal(1), -2)
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.max_mag(1, Decimal(-2))
        Decimal(&#39;-2&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.max_mag</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;min compares two values numerically and returns the minimum.

        If either operand is a NaN then the general rules apply.
        Otherwise, the operands are compared as though by the compare
        operation.  If they are numerically equal then the left-hand operand
        is chosen as the result.  Otherwise the minimum (closer to negative
        infinity) of the two operands is chosen as the result.

        &gt;&gt;&gt; ExtendedContext.min(Decimal(&#39;3&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.min(Decimal(&#39;-10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-10&#39;)
        &gt;&gt;&gt; ExtendedContext.min(Decimal(&#39;1.0&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;1.0&#39;)
        &gt;&gt;&gt; ExtendedContext.min(Decimal(&#39;7&#39;), Decimal(&#39;NaN&#39;))
        Decimal(&#39;7&#39;)
        &gt;&gt;&gt; ExtendedContext.min(1, 2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.min(Decimal(1), 2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.min(1, Decimal(29))
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.min</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">min_mag</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Compares the values numerically with their sign ignored.

        &gt;&gt;&gt; ExtendedContext.min_mag(Decimal(&#39;3&#39;), Decimal(&#39;-2&#39;))
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.min_mag(Decimal(&#39;-3&#39;), Decimal(&#39;NaN&#39;))
        Decimal(&#39;-3&#39;)
        &gt;&gt;&gt; ExtendedContext.min_mag(1, -2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.min_mag(Decimal(1), -2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.min_mag(1, Decimal(-2))
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.min_mag</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">minus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Minus corresponds to unary prefix minus in Python.

        The operation is evaluated using the same rules as subtract; the
        operation minus(a) is calculated as subtract(&#39;0&#39;, a) where the &#39;0&#39;
        has the same exponent as the operand.

        &gt;&gt;&gt; ExtendedContext.minus(Decimal(&#39;1.3&#39;))
        Decimal(&#39;-1.3&#39;)
        &gt;&gt;&gt; ExtendedContext.minus(Decimal(&#39;-1.3&#39;))
        Decimal(&#39;1.3&#39;)
        &gt;&gt;&gt; ExtendedContext.minus(1)
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.__neg__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">multiply</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;multiply multiplies two operands.

        If either operand is a special value then the general rules apply.
        Otherwise, the operands are multiplied together
        (&#39;long multiplication&#39;), resulting in a number which may be as long as
        the sum of the lengths of the two operands.

        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(&#39;1.20&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;3.60&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(&#39;7&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;21&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(&#39;0.9&#39;), Decimal(&#39;0.8&#39;))
        Decimal(&#39;0.72&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(&#39;0.9&#39;), Decimal(&#39;-0&#39;))
        Decimal(&#39;-0.0&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(&#39;654321&#39;), Decimal(&#39;654321&#39;))
        Decimal(&#39;4.28135971E+11&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(7, 7)
        Decimal(&#39;49&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(Decimal(7), 7)
        Decimal(&#39;49&#39;)
        &gt;&gt;&gt; ExtendedContext.multiply(7, Decimal(7))
        Decimal(&#39;49&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__mul__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_minus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the largest representable number smaller than a.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; ExtendedContext.next_minus(Decimal(&#39;1&#39;))
        Decimal(&#39;0.999999999&#39;)
        &gt;&gt;&gt; c.next_minus(Decimal(&#39;1E-1007&#39;))
        Decimal(&#39;0E-1007&#39;)
        &gt;&gt;&gt; ExtendedContext.next_minus(Decimal(&#39;-1.00000003&#39;))
        Decimal(&#39;-1.00000004&#39;)
        &gt;&gt;&gt; c.next_minus(Decimal(&#39;Infinity&#39;))
        Decimal(&#39;9.99999999E+999&#39;)
        &gt;&gt;&gt; c.next_minus(1)
        Decimal(&#39;0.999999999&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.next_minus</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_plus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the smallest representable number larger than a.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; ExtendedContext.next_plus(Decimal(&#39;1&#39;))
        Decimal(&#39;1.00000001&#39;)
        &gt;&gt;&gt; c.next_plus(Decimal(&#39;-1E-1007&#39;))
        Decimal(&#39;-0E-1007&#39;)
        &gt;&gt;&gt; ExtendedContext.next_plus(Decimal(&#39;-1.00000003&#39;))
        Decimal(&#39;-1.00000002&#39;)
        &gt;&gt;&gt; c.next_plus(Decimal(&#39;-Infinity&#39;))
        Decimal(&#39;-9.99999999E+999&#39;)
        &gt;&gt;&gt; c.next_plus(1)
        Decimal(&#39;1.00000001&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.next_plus</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">next_toward</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the number closest to a, in direction towards b.

        The result is the closest representable number from the first
        operand (but not the first operand) that is in the direction
        towards the second operand, unless the operands have the same
        value.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;1&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;1.00000001&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;-1E-1007&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;-0E-1007&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;-1.00000003&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;-1.00000002&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;1&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;0.999999999&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;1E-1007&#39;), Decimal(&#39;-100&#39;))
        Decimal(&#39;0E-1007&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;-1.00000003&#39;), Decimal(&#39;-10&#39;))
        Decimal(&#39;-1.00000004&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(&#39;0.00&#39;), Decimal(&#39;-0.0000&#39;))
        Decimal(&#39;-0.00&#39;)
        &gt;&gt;&gt; c.next_toward(0, 1)
        Decimal(&#39;1E-1007&#39;)
        &gt;&gt;&gt; c.next_toward(Decimal(0), 1)
        Decimal(&#39;1E-1007&#39;)
        &gt;&gt;&gt; c.next_toward(0, Decimal(1))
        Decimal(&#39;1E-1007&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.next_toward</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">normalize</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;normalize reduces an operand to its simplest form.

        Essentially a plus operation with all trailing zeros removed from the
        result.

        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2.1&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;-2.0&#39;))
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;1.200&#39;))
        Decimal(&#39;1.2&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;-120&#39;))
        Decimal(&#39;-1.2E+2&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;120.00&#39;))
        Decimal(&#39;1.2E+2&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(Decimal(&#39;0.00&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.normalize(6)
        Decimal(&#39;6&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.normalize</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">number_class</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns an indication of the class of the operand.

        The class is one of the following strings:
          -sNaN
          -NaN
          -Infinity
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Infinity

        &gt;&gt;&gt; c = Context(ExtendedContext)
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.number_class(Decimal(&#39;Infinity&#39;))
        &#39;+Infinity&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;1E-10&#39;))
        &#39;+Normal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;2.50&#39;))
        &#39;+Normal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;0.1E-999&#39;))
        &#39;+Subnormal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;0&#39;))
        &#39;+Zero&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-0&#39;))
        &#39;-Zero&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-0.1E-999&#39;))
        &#39;-Subnormal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-1E-10&#39;))
        &#39;-Normal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-2.50&#39;))
        &#39;-Normal&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-Infinity&#39;))
        &#39;-Infinity&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;NaN&#39;))
        &#39;NaN&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;-NaN&#39;))
        &#39;NaN&#39;
        &gt;&gt;&gt; c.number_class(Decimal(&#39;sNaN&#39;))
        &#39;sNaN&#39;
        &gt;&gt;&gt; c.number_class(123)
        &#39;+Normal&#39;
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.number_class</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">plus</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Plus corresponds to unary prefix plus in Python.

        The operation is evaluated using the same rules as add; the
        operation plus(a) is calculated as add(&#39;0&#39;, a) where the &#39;0&#39;
        has the same exponent as the operand.

        &gt;&gt;&gt; ExtendedContext.plus(Decimal(&#39;1.3&#39;))
        Decimal(&#39;1.3&#39;)
        &gt;&gt;&gt; ExtendedContext.plus(Decimal(&#39;-1.3&#39;))
        Decimal(&#39;-1.3&#39;)
        &gt;&gt;&gt; ExtendedContext.plus(-1)
        Decimal(&#39;-1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.__pos__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">power</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Raises a to the power of b, to modulo if given.

        With two arguments, compute a**b.  If a is negative then b
        must be integral.  The result will be inexact unless b is
        integral and the result is finite and can be expressed exactly
        in &#39;precision&#39; digits.

        With three arguments, compute (a**b) % modulo.  For the
        three argument form, the following restrictions on the
        arguments hold:

         - all three arguments must be integral
         - b must be nonnegative
         - at least one of a or b must be nonzero
         - modulo must be nonzero and have at most &#39;precision&#39; digits

        The result of pow(a, b, modulo) is identical to the result
        that would be obtained by computing (a**b) % modulo with
        unbounded precision, but is computed more efficiently.  It is
        always exact.

        &gt;&gt;&gt; c = ExtendedContext.copy()
        &gt;&gt;&gt; c.Emin = -999
        &gt;&gt;&gt; c.Emax = 999
        &gt;&gt;&gt; c.power(Decimal(&#39;2&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;8&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-2&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-8&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;2&#39;), Decimal(&#39;-3&#39;))
        Decimal(&#39;0.125&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;1.7&#39;), Decimal(&#39;8&#39;))
        Decimal(&#39;69.7575744&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;10&#39;), Decimal(&#39;0.301029996&#39;))
        Decimal(&#39;2.00000000&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;Infinity&#39;), Decimal(&#39;-1&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;Infinity&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;Infinity&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-Infinity&#39;), Decimal(&#39;-1&#39;))
        Decimal(&#39;-0&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-Infinity&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-Infinity&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-Infinity&#39;), Decimal(&#39;2&#39;))
        Decimal(&#39;Infinity&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;0&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;NaN&#39;)

        &gt;&gt;&gt; c.power(Decimal(&#39;3&#39;), Decimal(&#39;7&#39;), Decimal(&#39;16&#39;))
        Decimal(&#39;11&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-3&#39;), Decimal(&#39;7&#39;), Decimal(&#39;16&#39;))
        Decimal(&#39;-11&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-3&#39;), Decimal(&#39;8&#39;), Decimal(&#39;16&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;3&#39;), Decimal(&#39;7&#39;), Decimal(&#39;-16&#39;))
        Decimal(&#39;11&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;23E12345&#39;), Decimal(&#39;67E189&#39;), Decimal(&#39;123456789&#39;))
        Decimal(&#39;11729830&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-0&#39;), Decimal(&#39;17&#39;), Decimal(&#39;1729&#39;))
        Decimal(&#39;-0&#39;)
        &gt;&gt;&gt; c.power(Decimal(&#39;-23&#39;), Decimal(&#39;0&#39;), Decimal(&#39;65537&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.power(7, 7)
        Decimal(&#39;823543&#39;)
        &gt;&gt;&gt; ExtendedContext.power(Decimal(7), 7)
        Decimal(&#39;823543&#39;)
        &gt;&gt;&gt; ExtendedContext.power(7, Decimal(7), 2)
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__pow__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">modulo</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">quantize</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a value equal to &#39;a&#39; (rounded), having the exponent of &#39;b&#39;.

        The coefficient of the result is derived from that of the left-hand
        operand.  It may be rounded using the current rounding setting (if the
        exponent is being increased), multiplied by a positive power of ten (if
        the exponent is being decreased), or is unchanged (if the exponent is
        already equal to that of the right-hand operand).

        Unlike other operations, if the length of the coefficient after the
        quantize operation would be greater than precision then an Invalid
        operation condition is raised.  This guarantees that, unless there is
        an error condition, the exponent of the result of a quantize is always
        equal to that of the right-hand operand.

        Also unlike other operations, quantize will never raise Underflow, even
        if the result is subnormal and inexact.

        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2.17&#39;), Decimal(&#39;0.001&#39;))
        Decimal(&#39;2.170&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2.17&#39;), Decimal(&#39;0.01&#39;))
        Decimal(&#39;2.17&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2.17&#39;), Decimal(&#39;0.1&#39;))
        Decimal(&#39;2.2&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2.17&#39;), Decimal(&#39;1e+0&#39;))
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2.17&#39;), Decimal(&#39;1e+1&#39;))
        Decimal(&#39;0E+1&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;-Inf&#39;), Decimal(&#39;Infinity&#39;))
        Decimal(&#39;-Infinity&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;2&#39;), Decimal(&#39;Infinity&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;-0.1&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;-0&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;-0&#39;), Decimal(&#39;1e+5&#39;))
        Decimal(&#39;-0E+5&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;+35236450.6&#39;), Decimal(&#39;1e-2&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;-35236450.6&#39;), Decimal(&#39;1e-2&#39;))
        Decimal(&#39;NaN&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;217&#39;), Decimal(&#39;1e-1&#39;))
        Decimal(&#39;217.0&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;217&#39;), Decimal(&#39;1e-0&#39;))
        Decimal(&#39;217&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;217&#39;), Decimal(&#39;1e+1&#39;))
        Decimal(&#39;2.2E+2&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(&#39;217&#39;), Decimal(&#39;1e+2&#39;))
        Decimal(&#39;2E+2&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(1, 2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(Decimal(1), 2)
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.quantize(1, Decimal(2))
        Decimal(&#39;1&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.quantize</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">radix</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Just returns 10, as this is Decimal, :)

        &gt;&gt;&gt; ExtendedContext.radix()
        Decimal(&#39;10&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="dec">10</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">remainder</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the remainder from integer division.

        The result is the residue of the dividend after the operation of
        calculating integer division as described for divide-integer, rounded
        to precision digits if necessary.  The sign of the result, if
        non-zero, is the same as that of the original dividend.

        This operation will fail under the same conditions as integer division
        (that is, if integer division on the same two operands would fail, the
        remainder cannot be calculated).

        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;2.1&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;2.1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;-10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;10.2&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;0.2&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;10&#39;), Decimal(&#39;0.3&#39;))
        Decimal(&#39;0.1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(&#39;3.6&#39;), Decimal(&#39;1.3&#39;))
        Decimal(&#39;1.0&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(22, 6)
        Decimal(&#39;4&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(Decimal(22), 6)
        Decimal(&#39;4&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder(22, Decimal(6))
        Decimal(&#39;4&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__mod__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">remainder_near</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns to be &#34;a - b * n&#34;, where n is the integer nearest the exact
        value of &#34;x / b&#34; (if two integers are equally near then the even one
        is chosen).  If the result is equal to 0 then its sign will be the
        sign of a.

        This operation will fail under the same conditions as integer division
        (that is, if integer division on the same two operands would fail, the
        remainder cannot be calculated).

        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;2.1&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-0.9&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;10&#39;), Decimal(&#39;6&#39;))
        Decimal(&#39;-2&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;-10&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;-1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;10.2&#39;), Decimal(&#39;1&#39;))
        Decimal(&#39;0.2&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;10&#39;), Decimal(&#39;0.3&#39;))
        Decimal(&#39;0.1&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(&#39;3.6&#39;), Decimal(&#39;1.3&#39;))
        Decimal(&#39;-0.3&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(3, 11)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(3), 11)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.remainder_near(3, Decimal(11))
        Decimal(&#39;3&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.remainder_near</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">rotate</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a rotated copy of a, b times.

        The coefficient of the result is a rotated copy of the digits in
        the coefficient of the first operand.  The number of places of
        rotation is taken from the absolute value of the second operand,
        with the rotation being to the left if the second operand is
        positive or to the right otherwise.

        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(&#39;34&#39;), Decimal(&#39;8&#39;))
        Decimal(&#39;400000003&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(&#39;12&#39;), Decimal(&#39;9&#39;))
        Decimal(&#39;12&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(&#39;123456789&#39;), Decimal(&#39;-2&#39;))
        Decimal(&#39;891234567&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(&#39;123456789&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;123456789&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(&#39;123456789&#39;), Decimal(&#39;+2&#39;))
        Decimal(&#39;345678912&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(1333333, 1)
        Decimal(&#39;13333330&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(Decimal(1333333), 1)
        Decimal(&#39;13333330&#39;)
        &gt;&gt;&gt; ExtendedContext.rotate(1333333, Decimal(1))
        Decimal(&#39;13333330&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.rotate</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">same_quantum</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns True if the two operands have the same exponent.

        The result is never affected by either the sign or the coefficient of
        either operand.

        &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(&#39;2.17&#39;), Decimal(&#39;0.001&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(&#39;2.17&#39;), Decimal(&#39;0.01&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(&#39;2.17&#39;), Decimal(&#39;1&#39;))
        False
        &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(&#39;Inf&#39;), Decimal(&#39;-Inf&#39;))
        True
        &gt;&gt;&gt; ExtendedContext.same_quantum(10000, -1)
        True
        &gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(10000), -1)
        True
        &gt;&gt;&gt; ExtendedContext.same_quantum(10000, Decimal(-1))
        True
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.same_quantum</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">scaleb</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns the first operand after adding the second value its exp.

        &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(&#39;7.50&#39;), Decimal(&#39;-2&#39;))
        Decimal(&#39;0.0750&#39;)
        &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(&#39;7.50&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;7.50&#39;)
        &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(&#39;7.50&#39;), Decimal(&#39;3&#39;))
        Decimal(&#39;7.50E+3&#39;)
        &gt;&gt;&gt; ExtendedContext.scaleb(1, 4)
        Decimal(&#39;1E+4&#39;)
        &gt;&gt;&gt; ExtendedContext.scaleb(Decimal(1), 4)
        Decimal(&#39;1E+4&#39;)
        &gt;&gt;&gt; ExtendedContext.scaleb(1, Decimal(4))
        Decimal(&#39;1E+4&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.scaleb</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">shift</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Returns a shifted copy of a, b times.

        The coefficient of the result is a shifted copy of the digits
        in the coefficient of the first operand.  The number of places
        to shift is taken from the absolute value of the second operand,
        with the shift being to the left if the second operand is
        positive or to the right otherwise.  Digits shifted into the
        coefficient are zeros.

        &gt;&gt;&gt; ExtendedContext.shift(Decimal(&#39;34&#39;), Decimal(&#39;8&#39;))
        Decimal(&#39;400000000&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(Decimal(&#39;12&#39;), Decimal(&#39;9&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(Decimal(&#39;123456789&#39;), Decimal(&#39;-2&#39;))
        Decimal(&#39;1234567&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(Decimal(&#39;123456789&#39;), Decimal(&#39;0&#39;))
        Decimal(&#39;123456789&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(Decimal(&#39;123456789&#39;), Decimal(&#39;+2&#39;))
        Decimal(&#39;345678900&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(88888888, 2)
        Decimal(&#39;888888800&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(Decimal(88888888), 2)
        Decimal(&#39;888888800&#39;)
        &gt;&gt;&gt; ExtendedContext.shift(88888888, Decimal(2))
        Decimal(&#39;888888800&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.shift</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Square root of a non-negative number to context precision.

        If the result must be inexact, it is rounded using the round-half-even
        algorithm.

        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;0&#39;))
        Decimal(&#39;0&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;-0&#39;))
        Decimal(&#39;-0&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;0.39&#39;))
        Decimal(&#39;0.624499800&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;100&#39;))
        Decimal(&#39;10&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;1&#39;))
        Decimal(&#39;1&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;1.0&#39;))
        Decimal(&#39;1.0&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;1.00&#39;))
        Decimal(&#39;1.0&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;7&#39;))
        Decimal(&#39;2.64575131&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(Decimal(&#39;10&#39;))
        Decimal(&#39;3.16227766&#39;)
        &gt;&gt;&gt; ExtendedContext.sqrt(2)
        Decimal(&#39;1.41421356&#39;)
        &gt;&gt;&gt; ExtendedContext.prec
        9
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.sqrt</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">subtract</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Return the difference between the two operands.

        &gt;&gt;&gt; ExtendedContext.subtract(Decimal(&#39;1.3&#39;), Decimal(&#39;1.07&#39;))
        Decimal(&#39;0.23&#39;)
        &gt;&gt;&gt; ExtendedContext.subtract(Decimal(&#39;1.3&#39;), Decimal(&#39;1.30&#39;))
        Decimal(&#39;0.00&#39;)
        &gt;&gt;&gt; ExtendedContext.subtract(Decimal(&#39;1.3&#39;), Decimal(&#39;2.07&#39;))
        Decimal(&#39;-0.77&#39;)
        &gt;&gt;&gt; ExtendedContext.subtract(8, 5)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.subtract(Decimal(8), 5)
        Decimal(&#39;3&#39;)
        &gt;&gt;&gt; ExtendedContext.subtract(8, Decimal(5))
        Decimal(&#39;3&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a.__sub__</span><span class="pun">(</span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">NotImplemented</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="kwd">return</span><span class=""> </span><span class="pln">r</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_eng_string</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Converts a number to a string, using scientific notation.

        The operation is not affected by the context.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.to_eng_string</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_sci_string</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Converts a number to a string, using scientific notation.

        The operation is not affected by the context.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.__str__</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_integral_exact</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds to an integer.

        When the operand has a negative exponent, the result is the same
        as using the quantize() operation using the given operand as the
        left-hand-operand, 1E+0 as the right-hand-operand, and the precision
        of the operand as the precision setting; Inexact and Rounded flags
        are allowed in this operation.  The rounding mode is taken from the
        context.

        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;100&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;100.0&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;101.5&#39;))
        Decimal(&#39;102&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;-101.5&#39;))
        Decimal(&#39;-102&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;10E+5&#39;))
        Decimal(&#39;1.0E+6&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;7.89E+77&#39;))
        Decimal(&#39;7.89E+77&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal(&#39;-Inf&#39;))
        Decimal(&#39;-Infinity&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.to_integral_exact</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">to_integral_value</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Rounds to an integer.

        When the operand has a negative exponent, the result is the same
        as using the quantize() operation using the given operand as the
        left-hand-operand, 1E+0 as the right-hand-operand, and the precision
        of the operand as the precision setting, except that no flags will
        be set.  The rounding mode is taken from the context.

        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;2.1&#39;))
        Decimal(&#39;2&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;100&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;100.0&#39;))
        Decimal(&#39;100&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;101.5&#39;))
        Decimal(&#39;102&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;-101.5&#39;))
        Decimal(&#39;-102&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;10E+5&#39;))
        Decimal(&#39;1.0E+6&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;7.89E+77&#39;))
        Decimal(&#39;7.89E+77&#39;)
        &gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal(&#39;-Inf&#39;))
        Decimal(&#39;-Infinity&#39;)
        &#34;&#34;&#34;</span><span class="">
        </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">True</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">a.to_integral_value</span><span class="pun">(</span><span class="pln">context</span><span class="">=</span><span class="pln">self</span><span class="pun">)</span><span class="">

    </span><span class="com"># the method name changed, but we provide also the old one, for compatibility</span><span class="">
    </span><span class="pln">to_integral</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">to_integral_value</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">_WorkRep</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="pln">__slots__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="str">&#39;sign&#39;</span><span class="pun">,</span><span class="str">&#39;int&#39;</span><span class="pun">,</span><span class="str">&#39;exp&#39;</span><span class="pun">)</span><span class="">
    </span><span class="com"># sign: 0 or 1</span><span class="">
    </span><span class="com"># int:  int or long</span><span class="">
    </span><span class="com"># exp:  None, int, or string</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">value</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">value</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">None</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">None</span><span class="">
        </span><span class="kwd">elif</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">value</span><span class="pun">,</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value._sign</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">value._int</span><span class="pun">)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value._exp</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="com"># assert isinstance(value, tuple)</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">1</span><span class="pun">]</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">value</span><span class="pun">[</span><span class="dec">2</span><span class="pun">]</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__repr__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="str">&#34;(%r, %r, %r)&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">self</span><span class="">.</span><span class="pln">exp</span><span class="pun">)</span><span class="">

    </span><span class="pln">__str__</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">__repr__</span><span class="">



</span><span class="kwd">def</span><span class=""> </span><span class="pln">_normalize</span><span class="pun">(</span><span class="pln">op1</span><span class="pun">,</span><span class=""> </span><span class="pln">op2</span><span class="pun">,</span><span class=""> </span><span class="pln">prec</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Normalizes op1, op2 to have the same exp and length of coefficient.

    Done during addition.
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">op1.exp</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">op2.exp</span><span class="pun">:</span><span class="">
        </span><span class="pln">tmp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op2</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op1</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">tmp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op1</span><span class="">
        </span><span class="pln">other</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">op2</span><span class="">

    </span><span class="com"># Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).</span><span class="">
    </span><span class="com"># Then adding 10**exp to tmp has the same effect (after rounding)</span><span class="">
    </span><span class="com"># as adding any positive quantity smaller than 10**exp; similarly</span><span class="">
    </span><span class="com"># for subtraction.  So if other is smaller than 10**exp we replace</span><span class="">
    </span><span class="com"># it with 10**exp.  This avoids tmp.exp - other.exp getting too large.</span><span class="">
    </span><span class="pln">tmp_len</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">tmp.int</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">other_len</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">other.int</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">tmp.exp</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="pln">tmp_len</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">prec</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">2</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">other_len</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">other.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="pln">exp</span><span class="pun">:</span><span class="">
        </span><span class="pln">other.int</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">
        </span><span class="pln">other.exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">exp</span><span class="">

    </span><span class="pln">tmp.int</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class=""> </span><span class="pun">*</span><span class="pun">*</span><span class=""> </span><span class="pun">(</span><span class="pln">tmp.exp</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">other.exp</span><span class="pun">)</span><span class="">
    </span><span class="pln">tmp.exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">other.exp</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">op1</span><span class="pun">,</span><span class=""> </span><span class="pln">op2</span><span class="">

</span><span class="com">##### Integer arithmetic functions used by ln, log10, exp and __pow__ #####</span><span class="">

</span><span class="com"># This function from Tim Peters was taken from here:</span><span class="">
</span><span class="com"># http://mail.python.org/pipermail/python-list/1999-July/007758.html</span><span class="">
</span><span class="com"># The correction being in the function definition is for speed, and</span><span class="">
</span><span class="com"># the whole function is not resolved with math.log because of avoiding</span><span class="">
</span><span class="com"># the use of floats.</span><span class="">
</span><span class="kwd">def</span><span class=""> </span><span class="pln">_nbits</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class=""> </span><span class="pln">correction</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">{</span><span class="">
        </span><span class="str">&#39;0&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">4</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;1&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">3</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;2&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">2</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;3&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">2</span><span class="pun">,</span><span class="">
        </span><span class="str">&#39;4&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;5&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;6&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;7&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">1</span><span class="pun">,</span><span class="">
        </span><span class="str">&#39;8&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;a&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;b&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class="">
        </span><span class="str">&#39;c&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;d&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;e&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;f&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">0</span><span class="pun">}</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Number of bits in binary representation of the positive integer n,
    or 0 if n == 0.
    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;The argument to _nbits should be nonnegative.&#34;</span><span class="pun">)</span><span class="">
    </span><span class="pln">hex_n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;%x&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">n</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="dec">4</span><span class="">*</span><span class="pln">len</span><span class="pun">(</span><span class="pln">hex_n</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">correction</span><span class="pun">[</span><span class="pln">hex_n</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="pun">]</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_decimal_lshift_exact</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34; Given integers n and e, return n * 10**e if it&#39;s an integer, else None.

    The computation is designed to avoid computing large powers of 10
    unnecessarily.

    &gt;&gt;&gt; _decimal_lshift_exact(3, 4)
    30000
    &gt;&gt;&gt; _decimal_lshift_exact(300, -999999999)  # returns None

    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="dec">0</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">e</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="com"># val_n = largest power of 10 dividing n.</span><span class="">
        </span><span class="pln">str_n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">val_n</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str_n</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str_n.rstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="kwd">if</span><span class=""> </span><span class="pln">val_n</span><span class=""> </span><span class="pun">&lt;</span><span class=""> -</span><span class="pln">e</span><span class=""> </span><span class="kwd">else</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">/</span><span class="pun">/</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">e</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_sqrt_nearest</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Closest integer to the square root of the positive integer n.  a is
    an initial approximation to the square root.  Any positive integer
    will do for a, but the closer a is to the square root of n the
    faster convergence will be.

    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">n</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">a</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Both arguments to _sqrt_nearest should be positive.&#34;</span><span class="pun">)</span><span class="">

    </span><span class="pln">b</span><span class="">=</span><span class="dec">0</span><span class="">
    </span><span class="kwd">while</span><span class=""> </span><span class="pln">a</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="pln">b</span><span class="pun">:</span><span class="">
        </span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">a</span><span class="pun">-</span><span class="">-</span><span class="pln">n</span><span class="pun">/</span><span class="">/</span><span class="pln">a</span><span class="pun">&gt;</span><span class="">&gt;</span><span class="dec">1</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">a</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_rshift_nearest</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class=""> </span><span class="pln">shift</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given an integer x and a nonnegative integer shift, return closest
    integer to x / 2**shift; use round-to-even in case of a tie.

    &#34;&#34;&#34;</span><span class="">
    </span><span class="pln">b</span><span class="pun">,</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1L</span><span class=""> </span><span class="pun">&lt;&lt;</span><span class=""> </span><span class="pln">shift</span><span class="pun">,</span><span class=""> </span><span class="pln">x</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="pln">shift</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pun">(</span><span class="dec">2</span><span class="pun">*</span><span class="pun">(</span><span class="pln">x</span><span class=""> </span><span class="pun">&amp;</span><span class=""> </span><span class="pun">(</span><span class="pln">b</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pun">(</span><span class="pln">q</span><span class="">&amp;</span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Closest integer to a/b, a and b positive integers; rounds to even
    in the case of a tie.

    &#34;&#34;&#34;</span><span class="">
    </span><span class="pln">q</span><span class="pun">,</span><span class=""> </span><span class="pln">r</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">q</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pun">(</span><span class="dec">2</span><span class="">*</span><span class="pln">r</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pun">(</span><span class="pln">q</span><span class="">&amp;</span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">b</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_ilog</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">L</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">8</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Integer approximation to M*log(x/M), with absolute error boundable
    in terms only of x/M.

    Given positive integers x and M, return an integer approximation to
    M * log(x/M).  For L = 8 and 0.1 &lt;= x/M &lt;= 10 the difference
    between the approximation and the exact result is at most 22.  For
    L = 8 and 1.0 &lt;= x/M &lt;= 10.0 the difference is at most 15.  In
    both cases these are upper bounds on the error; it will usually be
    much smaller.&#34;&#34;&#34;</span><span class="">

    </span><span class="com"># The basic algorithm is the following: let log1p be the function</span><span class="">
    </span><span class="com"># log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use</span><span class="">
    </span><span class="com"># the reduction</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># repeatedly until the argument to log1p is small (&lt; 2**-L in</span><span class="">
    </span><span class="com"># absolute value).  For small y we can use the Taylor series</span><span class="">
    </span><span class="com"># expansion</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># truncating at T such that y**T is small enough.  The whole</span><span class="">
    </span><span class="com"># computation is carried out in a form of fixed-point arithmetic,</span><span class="">
    </span><span class="com"># with a real number z being represented by an integer</span><span class="">
    </span><span class="com"># approximation to z*M.  To avoid loss of precision, the y below</span><span class="">
    </span><span class="com"># is actually an integer approximation to 2**R*y*M, where R is the</span><span class="">
    </span><span class="com"># number of reductions performed so far.</span><span class="">

    </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">x</span><span class="">-</span><span class="pln">M</span><span class="">
    </span><span class="com"># argument reduction; R = number of reductions performed</span><span class="">
    </span><span class="pln">R</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
    </span><span class="kwd">while</span><span class=""> </span><span class="pun">(</span><span class="pln">R</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="pln">L</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">long</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">y</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;&lt;</span><span class=""> </span><span class="pln">L</span><span class="">-</span><span class="pln">R</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">M</span><span class=""> </span><span class="pun">or</span><span class="">
           </span><span class="pln">R</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="pln">L</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">abs</span><span class="pun">(</span><span class="pln">y</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;&gt;</span><span class=""> </span><span class="pln">R</span><span class="">-</span><span class="pln">L</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">long</span><span class="pun">(</span><span class="pln">M</span><span class="">*</span><span class="pln">y</span><span class="pun">)</span><span class=""> </span><span class="pun">&lt;&lt;</span><span class=""> </span><span class="dec">1</span><span class="pun">,</span><span class="">
                         </span><span class="pln">M</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">_sqrt_nearest</span><span class="pun">(</span><span class="pln">M</span><span class="pun">*</span><span class="pun">(</span><span class="pln">M</span><span class="">+</span><span class="pln">_rshift_nearest</span><span class="pun">(</span><span class="pln">y</span><span class="pun">,</span><span class=""> </span><span class="pln">R</span><span class="pun">)</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class="pun">)</span><span class="">
        </span><span class="pln">R</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

    </span><span class="com"># Taylor series with T terms</span><span class="">
    </span><span class="pln">T</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">int</span><span class="pun">(</span><span class="">-</span><span class="dec">10</span><span class="">*</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">M</span><span class="pun">)</span><span class="pun">)</span><span class="pun">/</span><span class="pun">/</span><span class="pun">(</span><span class="dec">3</span><span class="">*</span><span class="pln">L</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">yshift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_rshift_nearest</span><span class="pun">(</span><span class="pln">y</span><span class="pun">,</span><span class=""> </span><span class="pln">R</span><span class="pun">)</span><span class="">
    </span><span class="pln">w</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">T</span><span class="pun">)</span><span class="">
    </span><span class="kwd">for</span><span class=""> </span><span class="pln">k</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">xrange</span><span class="pun">(</span><span class="pln">T</span><span class="">-</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> -</span><span class="dec">1</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">w</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">k</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">yshift</span><span class="">*</span><span class="pln">w</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">w</span><span class="">*</span><span class="pln">y</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_dlog10</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given integers c, e and p with c &gt; 0, p &gt;= 0, compute an integer
    approximation to 10**p * log10(c*10**e), with an absolute error of
    at most 1.  Assumes that c*10**e is not exactly 1.&#34;&#34;&#34;</span><span class="">

    </span><span class="com"># increase precision by 2; compensate for this by dividing</span><span class="">
    </span><span class="com"># final result by 100</span><span class="">
    </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="">

    </span><span class="com"># write c*10**e as d*10**f with either:</span><span class="">
    </span><span class="com">#   f &gt;= 0 and 1 &lt;= d &lt;= 10, or</span><span class="">
    </span><span class="com">#   f &lt;= 0 and 0.1 &lt;= d &lt;= 1.</span><span class="">
    </span><span class="com"># Thus for c*10**e close to 1, f = 0</span><span class="">
    </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">f</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">e</span><span class="">+</span><span class="pln">l</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pun">(</span><span class="pln">e</span><span class="">+</span><span class="pln">l</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="pln">M</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="">
        </span><span class="pln">k</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">e</span><span class="">+</span><span class="pln">p</span><span class="">-</span><span class="pln">f</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">k</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">k</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">k</span><span class="pun">)</span><span class="">

        </span><span class="pln">log_d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_ilog</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class=""> </span><span class="com"># error &lt; 5 + 22 = 27</span><span class="">
        </span><span class="pln">log_10</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_log10_digits</span><span class="pun">(</span><span class="pln">p</span><span class="pun">)</span><span class=""> </span><span class="com"># error &lt; 1</span><span class="">
        </span><span class="pln">log_d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">log_d</span><span class="">*</span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">log_10</span><span class="pun">)</span><span class="">
        </span><span class="pln">log_tenpower</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">f</span><span class="">*</span><span class="pln">M</span><span class=""> </span><span class="com"># exact</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">log_d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">  </span><span class="com"># error &lt; 2.31</span><span class="">
        </span><span class="pln">log_tenpower</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">f</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">p</span><span class="pun">)</span><span class=""> </span><span class="com"># error &lt; 0.5</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">log_tenpower</span><span class="">+</span><span class="pln">log_d</span><span class="pun">,</span><span class=""> </span><span class="dec">100</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_dlog</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given integers c, e and p with c &gt; 0, compute an integer
    approximation to 10**p * log(c*10**e), with an absolute error of
    at most 1.  Assumes that c*10**e is not exactly 1.&#34;&#34;&#34;</span><span class="">

    </span><span class="com"># Increase precision by 2. The precision increase is compensated</span><span class="">
    </span><span class="com"># for at the end with a division by 100.</span><span class="">
    </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="">

    </span><span class="com"># rewrite c*10**e as d*10**f with either f &gt;= 0 and 1 &lt;= d &lt;= 10,</span><span class="">
    </span><span class="com"># or f &lt;= 0 and 0.1 &lt;= d &lt;= 1.  Then we can compute 10**p * log(c*10**e)</span><span class="">
    </span><span class="com"># as 10**p * log(d) + 10**p*f * log(10).</span><span class="">
    </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">f</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">e</span><span class="">+</span><span class="pln">l</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pun">(</span><span class="pln">e</span><span class="">+</span><span class="pln">l</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">

    </span><span class="com"># compute approximation to 10**p*log(d), with error &lt; 27</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="pln">k</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">e</span><span class="">+</span><span class="pln">p</span><span class="">-</span><span class="pln">f</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">k</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">*</span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">k</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">k</span><span class="pun">)</span><span class="">  </span><span class="com"># error of &lt;= 0.5 in c</span><span class="">

        </span><span class="com"># _ilog magnifies existing error in c by a factor of at most 10</span><span class="">
        </span><span class="pln">log_d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_ilog</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="pun">)</span><span class=""> </span><span class="com"># error &lt; 5 + 22 = 27</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="com"># p &lt;= 0: just approximate the whole thing by 0; error &lt; 2.31</span><span class="">
        </span><span class="pln">log_d</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="com"># compute approximation to f*10**p*log(10), with error &lt; 11.</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">f</span><span class="pun">:</span><span class="">
        </span><span class="pln">extra</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">f</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class="">-</span><span class="dec">1</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">extra</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="com"># error in f * _log10_digits(p+extra) &lt; |f| * 1 = |f|</span><span class="">
            </span><span class="com"># after division, error &lt; |f|/10**extra + 0.5 &lt; 10 + 0.5 &lt; 11</span><span class="">
            </span><span class="pln">f_log_ten</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">f</span><span class="">*</span><span class="pln">_log10_digits</span><span class="pun">(</span><span class="pln">p</span><span class="">+</span><span class="pln">extra</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">extra</span><span class="pun">)</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">f_log_ten</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">f_log_ten</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">

    </span><span class="com"># error in sum &lt; 11+27 = 38; error after division &lt; 0.38 + 0.5 &lt; 1</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">f_log_ten</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">log_d</span><span class="pun">,</span><span class=""> </span><span class="dec">100</span><span class="pun">)</span><span class="">

</span><span class="kwd">class</span><span class=""> </span><span class="pln">_Log10Memoize</span><span class="pun">(</span><span class="pln">object</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Class to compute, store, and allow retrieval of, digits of the
    constant log(10) = 2.302585....  This constant is needed by
    Decimal.ln, Decimal.log10, Decimal.exp and Decimal.__pow__.&#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">def</span><span class=""> </span><span class="pln">__init__</span><span class="pun">(</span><span class="pln">self</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">self</span><span class="">.</span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#34;23025850929940456840179914546843642076011014886&#34;</span><span class="">

    </span><span class="kwd">def</span><span class=""> </span><span class="pln">getdigits</span><span class="pun">(</span><span class="pln">self</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="str">&#34;&#34;&#34;Given an integer p &gt;= 0, return floor(10**p)*log(10).

        For example, self.getdigits(3) returns 2302.
        &#34;&#34;&#34;</span><span class="">
        </span><span class="com"># digits are stored as a string, for quick conversion to</span><span class="">
        </span><span class="com"># integer in the case that we&#39;ve already computed enough</span><span class="">
        </span><span class="com"># digits; the stored digits should always be correct</span><span class="">
        </span><span class="com"># (truncated, not rounded to nearest).</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">&lt;</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;p should be nonnegative&#34;</span><span class="pun">)</span><span class="">

        </span><span class="kwd">if</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">digits</span><span class="pun">)</span><span class="pun">:</span><span class="">
            </span><span class="com"># compute p+3, p+6, p+9, ... digits; continue until at</span><span class="">
            </span><span class="com"># least one of the extra digits is nonzero</span><span class="">
            </span><span class="pln">extra</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
            </span><span class="kwd">while</span><span class=""> </span><span class="pln">True</span><span class="pun">:</span><span class="">
                </span><span class="com"># compute p+extra digits, correct to within 1ulp</span><span class="">
                </span><span class="pln">M</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">p</span><span class="">+</span><span class="pln">extra</span><span class="">+</span><span class="dec">2</span><span class="pun">)</span><span class="">
                </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">_ilog</span><span class="pun">(</span><span class="dec">10</span><span class="">*</span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="dec">100</span><span class="pun">)</span><span class="pun">)</span><span class="">
                </span><span class="kwd">if</span><span class=""> </span><span class="pln">digits</span><span class="pun">[</span><span class="">-</span><span class="pln">extra</span><span class="pun">:</span><span class="pun">]</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="">*</span><span class="pln">extra</span><span class="pun">:</span><span class="">
                    </span><span class="kwd">break</span><span class="">
                </span><span class="pln">extra</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">3</span><span class="">
            </span><span class="com"># keep all reliable digits so far; remove trailing zeros</span><span class="">
            </span><span class="com"># and next nonzero digit</span><span class="">
            </span><span class="pln">self</span><span class="">.</span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">digits.rstrip</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="pun">[</span><span class="pun">:</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">self</span><span class="">.</span><span class="pln">digits</span><span class="pun">[</span><span class="pun">:</span><span class="pln">p</span><span class="">+</span><span class="dec">1</span><span class="pun">]</span><span class="pun">)</span><span class="">

</span><span class="pln">_log10_digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_Log10Memoize</span><span class="pun">(</span><span class="pun">)</span><span class="">.</span><span class="pln">getdigits</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_iexp</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class=""> </span><span class="pln">M</span><span class="pun">,</span><span class=""> </span><span class="pln">L</span><span class="">=</span><span class="dec">8</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given integers x and M, M &gt; 0, such that x/M is small in absolute
    value, compute an integer approximation to M*exp(x/M).  For 0 &lt;=
    x/M &lt;= 2.4, the absolute error in the result is bounded by 60 (and
    is usually much smaller).&#34;&#34;&#34;</span><span class="">

    </span><span class="com"># Algorithm: to compute exp(z) for a real number z, first divide z</span><span class="">
    </span><span class="com"># by a suitable power R of 2 so that |z/2**R| &lt; 2**-L.  Then</span><span class="">
    </span><span class="com"># compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor</span><span class="">
    </span><span class="com"># series</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#     expm1(x) = x + x**2/2! + x**3/3! + ...</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># Now use the identity</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#     expm1(2x) = expm1(x)*(expm1(x)+2)</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com"># R times to compute the sequence expm1(z/2**R),</span><span class="">
    </span><span class="com"># expm1(z/2**(R-1)), ... , exp(z/2), exp(z).</span><span class="">

    </span><span class="com"># Find R such that x/2**R/M &lt;= 2**-L</span><span class="">
    </span><span class="pln">R</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_nbits</span><span class="pun">(</span><span class="pun">(</span><span class="pln">long</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pun">&lt;</span><span class="">&lt;</span><span class="pln">L</span><span class="pun">)</span><span class="pun">/</span><span class="">/</span><span class="pln">M</span><span class="pun">)</span><span class="">

    </span><span class="com"># Taylor series.  (2**L)**T &gt; M</span><span class="">
    </span><span class="pln">T</span><span class=""> </span><span class="pun">=</span><span class=""> -</span><span class="pln">int</span><span class="pun">(</span><span class="">-</span><span class="dec">10</span><span class="">*</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">M</span><span class="pun">)</span><span class="pun">)</span><span class="pun">/</span><span class="pun">/</span><span class="pun">(</span><span class="dec">3</span><span class="">*</span><span class="pln">L</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class=""> </span><span class="pln">T</span><span class="pun">)</span><span class="">
    </span><span class="pln">Mshift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">long</span><span class="pun">(</span><span class="pln">M</span><span class="pun">)</span><span class="pun">&lt;</span><span class="">&lt;</span><span class="pln">R</span><span class="">
    </span><span class="kwd">for</span><span class=""> </span><span class="pln">i</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">xrange</span><span class="pun">(</span><span class="pln">T</span><span class="">-</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">,</span><span class=""> -</span><span class="dec">1</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">x</span><span class="pun">*</span><span class="pun">(</span><span class="pln">Mshift</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">y</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">Mshift</span><span class=""> </span><span class="pun">*</span><span class=""> </span><span class="pln">i</span><span class="pun">)</span><span class="">

    </span><span class="com"># Expansion</span><span class="">
    </span><span class="kwd">for</span><span class=""> </span><span class="pln">k</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">xrange</span><span class="pun">(</span><span class="pln">R</span><span class="">-</span><span class="dec">1</span><span class="pun">,</span><span class=""> -</span><span class="dec">1</span><span class="pun">,</span><span class=""> -</span><span class="dec">1</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="pln">Mshift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">long</span><span class="pun">(</span><span class="pln">M</span><span class="pun">)</span><span class="pun">&lt;&lt;</span><span class="pun">(</span><span class="pln">k</span><span class="">+</span><span class="dec">2</span><span class="pun">)</span><span class="">
        </span><span class="pln">y</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">y</span><span class="pun">*</span><span class="pun">(</span><span class="pln">y</span><span class="">+</span><span class="pln">Mshift</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">Mshift</span><span class="pun">)</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">M</span><span class="">+</span><span class="pln">y</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_dexp</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Compute an approximation to exp(c*10**e), with p decimal places of
    precision.

    Returns integers d, f such that:

      10**(p-1) &lt;= d &lt;= 10**p, and
      (d-1)*10**f &lt; exp(c*10**e) &lt; (d+1)*10**f

    In other words, d*10**f is an approximation to exp(c*10**e) with p
    digits of precision, and with an error in d of at most 1.  This is
    almost, but not quite, the same as the error being &lt; 1ulp: when d
    = 10**(p-1) the error could be up to 10 ulp.&#34;&#34;&#34;</span><span class="">

    </span><span class="com"># we&#39;ll call iexp with M = 10**(p+2), giving p+3 digits of precision</span><span class="">
    </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="">

    </span><span class="com"># compute log(10) with extra precision = adjusted exponent of c*10**e</span><span class="">
    </span><span class="pln">extra</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="dec">0</span><span class="pun">,</span><span class=""> </span><span class="pln">e</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">
    </span><span class="pln">q</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">extra</span><span class="">

    </span><span class="com"># compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),</span><span class="">
    </span><span class="com"># rounding down</span><span class="">
    </span><span class="pln">shift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">e</span><span class="">+</span><span class="pln">q</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">shift</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="pln">cshift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">c</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">shift</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">cshift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">c</span><span class="pun">/</span><span class="">/</span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">shift</span><span class="">
    </span><span class="pln">quot</span><span class="pun">,</span><span class=""> </span><span class="pln">rem</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">divmod</span><span class="pun">(</span><span class="pln">cshift</span><span class="pun">,</span><span class=""> </span><span class="pln">_log10_digits</span><span class="pun">(</span><span class="pln">q</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="com"># reduce remainder back to original precision</span><span class="">
    </span><span class="pln">rem</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">rem</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">extra</span><span class="pun">)</span><span class="">

    </span><span class="com"># error in result of _iexp &lt; 120;  error after division &lt; 0.62</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">_iexp</span><span class="pun">(</span><span class="pln">rem</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="dec">1000</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">quot</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">p</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="dec">3</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_dpower</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class="pun">,</span><span class=""> </span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="pln">ye</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given integers xc, xe, yc and ye representing Decimals x = xc*10**xe and
    y = yc*10**ye, compute x**y.  Returns a pair of integers (c, e) such that:

      10**(p-1) &lt;= c &lt;= 10**p, and
      (c-1)*10**e &lt; x**y &lt; (c+1)*10**e

    in other words, c*10**e is an approximation to x**y with p digits
    of precision, and with an error in c of at most 1.  (This is
    almost, but not quite, the same as the error being &lt; 1ulp: when c
    == 10**(p-1) we can only guarantee error &lt; 10ulp.)

    We assume that: x is positive and not equal to 1, and y is nonzero.
    &#34;&#34;&#34;</span><span class="">

    </span><span class="com"># Find b such that 10**(b-1) &lt;= |y| &lt;= 10**b</span><span class="">
    </span><span class="pln">b</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">yc</span><span class="pun">)</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">ye</span><span class="">

    </span><span class="com"># log(x) = lxc*10**(-p-b-1), to p+b+1 places after the decimal point</span><span class="">
    </span><span class="pln">lxc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dlog</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">,</span><span class=""> </span><span class="pln">xe</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">+</span><span class="pln">b</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">

    </span><span class="com"># compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)</span><span class="">
    </span><span class="pln">shift</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">ye</span><span class="">-</span><span class="pln">b</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">shift</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="pln">pc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">lxc</span><span class="">*</span><span class="pln">yc</span><span class="">*</span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">shift</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">pc</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">lxc</span><span class="">*</span><span class="pln">yc</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="">-</span><span class="pln">shift</span><span class="pun">)</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">pc</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="com"># we prefer a result that isn&#39;t exactly 1; this makes it</span><span class="">
        </span><span class="com"># easier to compute a correctly rounded result in __pow__</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">(</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str</span><span class="pun">(</span><span class="pln">xc</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">xe</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pun">(</span><span class="pln">yc</span><span class=""> </span><span class="pun">&gt;</span><span class=""> </span><span class="dec">0</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class=""> </span><span class="com"># if x**y &gt; 1:</span><span class="">
            </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="pun">*</span><span class="pun">(</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">+</span><span class="dec">1</span><span class="pun">,</span><span class=""> </span><span class="dec">1</span><span class="">-</span><span class="pln">p</span><span class="">
        </span><span class="kwd">else</span><span class="pun">:</span><span class="">
            </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">10</span><span class="pun">*</span><span class="">*</span><span class="pln">p</span><span class="">-</span><span class="dec">1</span><span class="pun">,</span><span class=""> -</span><span class="pln">p</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_dexp</span><span class="pun">(</span><span class="pln">pc</span><span class="pun">,</span><span class=""> </span><span class="pun">-</span><span class="pun">(</span><span class="pln">p</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">p</span><span class="">+</span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="pln">coeff</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_div_nearest</span><span class="pun">(</span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="dec">10</span><span class="pun">)</span><span class="">
        </span><span class="pln">exp</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">coeff</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_log10_lb</span><span class="pun">(</span><span class="pln">c</span><span class="pun">,</span><span class=""> </span><span class="pln">correction</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">{</span><span class="">
        </span><span class="str">&#39;1&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">100</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;2&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">70</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;3&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">53</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;4&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">40</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;5&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">31</span><span class="pun">,</span><span class="">
        </span><span class="str">&#39;6&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">23</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;7&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">16</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;8&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">10</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;9&#39;</span><span class="pun">:</span><span class=""> </span><span class="dec">5</span><span class="pun">}</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Compute a lower bound for 100*log10(c) for a positive integer c.&#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">c</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;The argument to _log10_lb should be nonnegative.&#34;</span><span class="pun">)</span><span class="">
    </span><span class="pln">str_c</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">str</span><span class="pun">(</span><span class="pln">c</span><span class="pun">)</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="dec">100</span><span class="">*</span><span class="pln">len</span><span class="pun">(</span><span class="pln">str_c</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">correction</span><span class="pun">[</span><span class="pln">str_c</span><span class="pun">[</span><span class="dec">0</span><span class="pun">]</span><span class="pun">]</span><span class="">

</span><span class="com">##### Helper Functions ####################################################</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_convert_other</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">raiseit</span><span class="">=</span><span class="pln">False</span><span class="pun">,</span><span class=""> </span><span class="pln">allow_float</span><span class="">=</span><span class="pln">False</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Convert other to Decimal.

    Verifies that it&#39;s ok to use in an implicit construction.
    If allow_float is true, allow conversion from float;  this
    is used in the comparison methods (__eq__ and friends).

    &#34;&#34;&#34;</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">other</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pun">(</span><span class="pln">int</span><span class="pun">,</span><span class=""> </span><span class="pln">long</span><span class="pun">)</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">allow_float</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">other</span><span class="pun">,</span><span class=""> </span><span class="pln">float</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">Decimal.from_float</span><span class="pun">(</span><span class="pln">other</span><span class="pun">)</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">raiseit</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">TypeError</span><span class="pun">(</span><span class="str">&#34;Unable to convert %s to Decimal&#34;</span><span class=""> </span><span class="pun">%</span><span class=""> </span><span class="pln">other</span><span class="pun">)</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">NotImplemented</span><span class="">

</span><span class="com">##### Setup Specific Contexts ############################################</span><span class="">

</span><span class="com"># The default context prototype used by Context()</span><span class="">
</span><span class="com"># Is mutable, so that new contexts can have different default values</span><span class="">

</span><span class="pln">DefaultContext</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="">
        </span><span class="pln">prec</span><span class="">=</span><span class="dec">28</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">,</span><span class="">
        </span><span class="pln">traps</span><span class="pun">=</span><span class="pun">[</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="pln">InvalidOperation</span><span class="pun">]</span><span class="pun">,</span><span class="">
        </span><span class="pln">flags</span><span class="pun">=</span><span class="pun">[</span><span class="pun">]</span><span class="pun">,</span><span class="">
        </span><span class="pln">Emax</span><span class="">=</span><span class="dec">999999999</span><span class="pun">,</span><span class="">
        </span><span class="pln">Emin</span><span class="pun">=</span><span class="">-</span><span class="dec">999999999</span><span class="pun">,</span><span class="">
        </span><span class="pln">capitals</span><span class="">=</span><span class="dec">1</span><span class="">
</span><span class="pun">)</span><span class="">

</span><span class="com"># Pre-made alternate contexts offered by the specification</span><span class="">
</span><span class="com"># Don&#39;t change these; the user should be able to select these</span><span class="">
</span><span class="com"># contexts and be able to reproduce results from other implementations</span><span class="">
</span><span class="com"># of the spec.</span><span class="">

</span><span class="pln">BasicContext</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="">
        </span><span class="pln">prec</span><span class="">=</span><span class="dec">9</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">ROUND_HALF_UP</span><span class="pun">,</span><span class="">
        </span><span class="pln">traps</span><span class="pun">=</span><span class="pun">[</span><span class="pln">DivisionByZero</span><span class="pun">,</span><span class=""> </span><span class="pln">Overflow</span><span class="pun">,</span><span class=""> </span><span class="pln">InvalidOperation</span><span class="pun">,</span><span class=""> </span><span class="pln">Clamped</span><span class="pun">,</span><span class=""> </span><span class="pln">Underflow</span><span class="pun">]</span><span class="pun">,</span><span class="">
        </span><span class="pln">flags</span><span class="pun">=</span><span class="pun">[</span><span class="pun">]</span><span class="pun">,</span><span class="">
</span><span class="pun">)</span><span class="">

</span><span class="pln">ExtendedContext</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Context</span><span class="pun">(</span><span class="">
        </span><span class="pln">prec</span><span class="">=</span><span class="dec">9</span><span class="pun">,</span><span class=""> </span><span class="pln">rounding</span><span class="">=</span><span class="pln">ROUND_HALF_EVEN</span><span class="pun">,</span><span class="">
        </span><span class="pln">traps</span><span class="pun">=</span><span class="pun">[</span><span class="pun">]</span><span class="pun">,</span><span class="">
        </span><span class="pln">flags</span><span class="pun">=</span><span class="pun">[</span><span class="pun">]</span><span class="pun">,</span><span class="">
</span><span class="pun">)</span><span class="">


</span><span class="com">##### crud for parsing strings #############################################</span><span class="">
</span><span class="com">#</span><span class="">
</span><span class="com"># Regular expression used for parsing numeric strings.  Additional</span><span class="">
</span><span class="com"># comments:</span><span class="">
</span><span class="com">#</span><span class="">
</span><span class="com"># 1. Uncomment the two &#39;\s*&#39; lines to allow leading and/or trailing</span><span class="">
</span><span class="com"># whitespace.  But note that the specification disallows whitespace in</span><span class="">
</span><span class="com"># a numeric string.</span><span class="">
</span><span class="com">#</span><span class="">
</span><span class="com"># 2. For finite numbers (not infinities and NaNs) the body of the</span><span class="">
</span><span class="com"># number between the optional sign and the optional exponent must have</span><span class="">
</span><span class="com"># at least one decimal digit, possibly after the decimal point.  The</span><span class="">
</span><span class="com"># lookahead expression &#39;(?=\d|\.\d)&#39; checks this.</span><span class="">

</span><span class="kwd">import</span><span class=""> </span><span class="pln">re</span><span class="">
</span><span class="pln">_parser</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">re.compile</span><span class="pun">(</span><span class="str">r&#34;&#34;&#34;        # A numeric string consists of:
#    \s*
    (?P&lt;sign&gt;[-+])?              # an optional sign, followed by either...
    (
        (?=\d|\.\d)              # ...a number (with at least one digit)
        (?P&lt;int&gt;\d*)             # having a (possibly empty) integer part
        (\.(?P&lt;frac&gt;\d*))?       # followed by an optional fractional part
        (E(?P&lt;exp&gt;[-+]?\d+))?    # followed by an optional exponent, or...
    |
        Inf(inity)?              # ...an infinity, or...
    |
        (?P&lt;signal&gt;s)?           # ...an (optionally signaling)
        NaN                      # NaN
        (?P&lt;diag&gt;\d*)            # with (possibly empty) diagnostic info.
    )
#    \s*
    \Z
&#34;&#34;&#34;</span><span class="pun">,</span><span class=""> </span><span class="pln">re.VERBOSE</span><span class=""> </span><span class="pun">|</span><span class=""> </span><span class="pln">re.IGNORECASE</span><span class=""> </span><span class="pun">|</span><span class=""> </span><span class="pln">re.UNICODE</span><span class="pun">)</span><span class="">.</span><span class="pln">match</span><span class="">

</span><span class="pln">_all_zeros</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">re.compile</span><span class="pun">(</span><span class="str">&#39;0*$&#39;</span><span class="pun">)</span><span class="">.</span><span class="pln">match</span><span class="">
</span><span class="pln">_exact_half</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">re.compile</span><span class="pun">(</span><span class="str">&#39;50*$&#39;</span><span class="pun">)</span><span class="">.</span><span class="pln">match</span><span class="">

</span><span class="com">##### PEP3101 support functions ##############################################</span><span class="">
</span><span class="com"># The functions in this section have little to do with the Decimal</span><span class="">
</span><span class="com"># class, and could potentially be reused or adapted for other pure</span><span class="">
</span><span class="com"># Python numeric classes that want to implement __format__</span><span class="">
</span><span class="com">#</span><span class="">
</span><span class="com"># A format specifier for Decimal looks like:</span><span class="">
</span><span class="com">#</span><span class="">
</span><span class="com">#   [[fill]align][sign][0][minimumwidth][,][.precision][type]</span><span class="">

</span><span class="pln">_parse_format_specifier_regex</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">re.compile</span><span class="pun">(</span><span class="str">r&#34;&#34;&#34;\A
(?:
   (?P&lt;fill&gt;.)?
   (?P&lt;align&gt;[&lt;&gt;=^])
)?
(?P&lt;sign&gt;[-+ ])?
(?P&lt;zeropad&gt;0)?
(?P&lt;minimumwidth&gt;(?!0)\d+)?
(?P&lt;thousands_sep&gt;,)?
(?:\.(?P&lt;precision&gt;0|(?!0)\d+))?
(?P&lt;type&gt;[eEfFgGn%])?
\Z
&#34;&#34;&#34;</span><span class="pun">,</span><span class=""> </span><span class="pln">re.VERBOSE</span><span class="pun">)</span><span class="">

</span><span class="kwd">del</span><span class=""> </span><span class="pln">re</span><span class="">

</span><span class="com"># The locale module is only needed for the &#39;n&#39; format specifier.  The</span><span class="">
</span><span class="com"># rest of the PEP 3101 code functions quite happily without it, so we</span><span class="">
</span><span class="com"># don&#39;t care too much if locale isn&#39;t present.</span><span class="">
</span><span class="kwd">try</span><span class="pun">:</span><span class="">
    </span><span class="kwd">import</span><span class=""> </span><span class="pln">locale</span><span class=""> </span><span class="kwd">as</span><span class=""> </span><span class="pln">_locale</span><span class="">
</span><span class="kwd">except</span><span class=""> </span><span class="pln">ImportError</span><span class="pun">:</span><span class="">
    </span><span class="kwd">pass</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_parse_format_specifier</span><span class="pun">(</span><span class="pln">format_spec</span><span class="pun">,</span><span class=""> </span><span class="pln">_localeconv</span><span class="">=</span><span class="pln">None</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Parse and validate a format specifier.

    Turns a standard numeric format specifier into a dict, with the
    following entries:

      fill: fill character to pad field to minimum width
      align: alignment type, either &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;=&#39; or &#39;^&#39;
      sign: either &#39;+&#39;, &#39;-&#39; or &#39; &#39;
      minimumwidth: nonnegative integer giving minimum width
      zeropad: boolean, indicating whether to pad with zeros
      thousands_sep: string to use as thousands separator, or &#39;&#39;
      grouping: grouping for thousands separators, in format
        used by localeconv
      decimal_point: string to use for decimal point
      precision: nonnegative integer giving precision, or None
      type: one of the characters &#39;eEfFgG%&#39;, or None
      unicode: boolean (always True for Python 3.x)

    &#34;&#34;&#34;</span><span class="">
    </span><span class="pln">m</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_parse_format_specifier_regex.match</span><span class="pun">(</span><span class="pln">format_spec</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">m</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Invalid format specifier: &#34;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">format_spec</span><span class="pun">)</span><span class="">

    </span><span class="com"># get the dictionary</span><span class="">
    </span><span class="pln">format_dict</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">m.groupdict</span><span class="pun">(</span><span class="pun">)</span><span class="">

    </span><span class="com"># zeropad; defaults for fill and alignment.  If zero padding</span><span class="">
    </span><span class="com"># is requested, the fill and align fields should be absent.</span><span class="">
    </span><span class="pln">fill</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;fill&#39;</span><span class="pun">]</span><span class="">
    </span><span class="pln">align</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;align&#39;</span><span class="pun">]</span><span class="">
    </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;zeropad&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;zeropad&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;zeropad&#39;</span><span class="pun">]</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">fill</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Fill character conflicts with &#39;0&#39;&#34;</span><span class="">
                             </span><span class="str">&#34; in format specifier: &#34;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">format_spec</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Alignment conflicts with &#39;0&#39; in &#34;</span><span class="">
                             </span><span class="str">&#34;format specifier: &#34;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">format_spec</span><span class="pun">)</span><span class="">
    </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;fill&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">fill</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39; &#39;</span><span class="">
    </span><span class="com"># PEP 3101 originally specified that the default alignment should</span><span class="">
    </span><span class="com"># be left;  it was later agreed that right-aligned makes more sense</span><span class="">
    </span><span class="com"># for numeric types.  See http://bugs.python.org/issue6857.</span><span class="">
    </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;align&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;&gt;&#39;</span><span class="">

    </span><span class="com"># default sign handling: &#39;-&#39; for negative, &#39;&#39; for positive</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;sign&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;sign&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;-&#39;</span><span class="">

    </span><span class="com"># minimumwidth defaults to 0; precision remains None if not given</span><span class="">
    </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;minimumwidth&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;minimumwidth&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="str">&#39;0&#39;</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">int</span><span class="pun">(</span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class="pun">)</span><span class="">

    </span><span class="com"># if format type is &#39;g&#39; or &#39;G&#39; then a precision of 0 makes little</span><span class="">
    </span><span class="com"># sense; convert it to 1.  Same if format type is unspecified.</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;gG&#39;</span><span class="pun">:</span><span class="">
            </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;precision&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">1</span><span class="">

    </span><span class="com"># determine thousands separator, grouping, and decimal separator, and</span><span class="">
    </span><span class="com"># add appropriate entries to format_dict</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;n&#39;</span><span class="pun">:</span><span class="">
        </span><span class="com"># apart from separators, &#39;n&#39; behaves just like &#39;g&#39;</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;g&#39;</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">_localeconv</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">_localeconv</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_locale.localeconv</span><span class="pun">(</span><span class="pun">)</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;Explicit thousands separator conflicts with &#34;</span><span class="">
                             </span><span class="str">&#34;&#39;n&#39; type in format specifier: &#34;</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">format_spec</span><span class="pun">)</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_localeconv</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;grouping&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_localeconv</span><span class="pun">[</span><span class="str">&#39;grouping&#39;</span><span class="pun">]</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;decimal_point&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_localeconv</span><span class="pun">[</span><span class="str">&#39;decimal_point&#39;</span><span class="pun">]</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">is</span><span class=""> </span><span class="pln">None</span><span class="pun">:</span><span class="">
            </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;grouping&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="dec">3</span><span class="pun">,</span><span class=""> </span><span class="dec">0</span><span class="pun">]</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;decimal_point&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="str">&#39;.&#39;</span><span class="">

    </span><span class="com"># record whether return type should be str or unicode</span><span class="">
    </span><span class="kwd">try</span><span class="pun">:</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;unicode&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">isinstance</span><span class="pun">(</span><span class="pln">format_spec</span><span class="pun">,</span><span class=""> </span><span class="pln">unicode</span><span class="pun">)</span><span class="">
    </span><span class="kwd">except</span><span class=""> </span><span class="pln">NameError</span><span class="pun">:</span><span class="">
        </span><span class="pln">format_dict</span><span class="pun">[</span><span class="str">&#39;unicode&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">False</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">format_dict</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_format_align</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">body</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Given an unpadded, non-aligned numeric string &#39;body&#39; and sign
    string &#39;sign&#39;, add padding and alignment conforming to the given
    format specifier dictionary &#39;spec&#39; (as produced by
    parse_format_specifier).

    Also converts result to unicode if necessary.

    &#34;&#34;&#34;</span><span class="">
    </span><span class="com"># how much extra space do we have to play with?</span><span class="">
    </span><span class="pln">minimumwidth</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;minimumwidth&#39;</span><span class="pun">]</span><span class="">
    </span><span class="pln">fill</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;fill&#39;</span><span class="pun">]</span><span class="">
    </span><span class="pln">padding</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">fill</span><span class="pun">*</span><span class="pun">(</span><span class="pln">minimumwidth</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">body</span><span class="pun">)</span><span class="pun">)</span><span class="">

    </span><span class="pln">align</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;align&#39;</span><span class="pun">]</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;&lt;&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">body</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">padding</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;&gt;&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">padding</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">body</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;=&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">padding</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">body</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">align</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;^&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">half</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">padding</span><span class="pun">)</span><span class="pun">/</span><span class="">/</span><span class="dec">2</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">padding</span><span class="pun">[</span><span class="pun">:</span><span class="pln">half</span><span class="pun">]</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">sign</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">body</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">padding</span><span class="pun">[</span><span class="pln">half</span><span class="pun">:</span><span class="pun">]</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#39;Unrecognised alignment field&#39;</span><span class="pun">)</span><span class="">

    </span><span class="com"># make sure that result is unicode if necessary</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;unicode&#39;</span><span class="pun">]</span><span class="pun">:</span><span class="">
        </span><span class="pln">result</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">unicode</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">result</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_group_lengths</span><span class="pun">(</span><span class="pln">grouping</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Convert a localeconv-style grouping into a (possibly infinite)
    iterable of integers representing group lengths.

    &#34;&#34;&#34;</span><span class="">
    </span><span class="com"># The result from localeconv()[&#39;grouping&#39;], and the input to this</span><span class="">
    </span><span class="com"># function, should be a list of integers in one of the</span><span class="">
    </span><span class="com"># following three forms:</span><span class="">
    </span><span class="com">#</span><span class="">
    </span><span class="com">#   (1) an empty list, or</span><span class="">
    </span><span class="com">#   (2) nonempty list of positive integers + [0]</span><span class="">
    </span><span class="com">#   (3) list of positive integers + [locale.CHAR_MAX], or</span><span class="">

    </span><span class="kwd">from</span><span class=""> </span><span class="pln">itertools</span><span class=""> </span><span class="kwd">import</span><span class=""> </span><span class="pln">chain</span><span class="pun">,</span><span class=""> </span><span class="pln">repeat</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">grouping</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pun">[</span><span class="pun">]</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">grouping</span><span class="pun">[</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">grouping</span><span class="pun">)</span><span class=""> </span><span class="pun">&gt;</span><span class="pun">=</span><span class=""> </span><span class="dec">2</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">chain</span><span class="pun">(</span><span class="pln">grouping</span><span class="pun">[</span><span class="pun">:</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class="pun">,</span><span class=""> </span><span class="pln">repeat</span><span class="pun">(</span><span class="pln">grouping</span><span class="pun">[</span><span class="">-</span><span class="dec">2</span><span class="pun">]</span><span class="pun">)</span><span class="pun">)</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">grouping</span><span class="pun">[</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="pln">_locale.CHAR_MAX</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">grouping</span><span class="pun">[</span><span class="pun">:</span><span class="">-</span><span class="dec">1</span><span class="pun">]</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#39;unrecognised format for grouping&#39;</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_insert_thousands_sep</span><span class="pun">(</span><span class="pln">digits</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">,</span><span class=""> </span><span class="pln">min_width</span><span class="">=</span><span class="dec">1</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Insert thousands separators into a digit string.

    spec is a dictionary whose keys should include &#39;thousands_sep&#39; and
    &#39;grouping&#39;; typically it&#39;s the result of parsing the format
    specifier using _parse_format_specifier.

    The min_width keyword argument gives the minimum length of the
    result, which will be padded on the left with zeros if necessary.

    If necessary, the zero padding adds an extra &#39;0&#39; on the left to
    avoid a leading thousands separator.  For example, inserting
    commas every three digits in &#39;123456&#39;, with min_width=8, gives
    &#39;0,123,456&#39;, even though that has length 9.

    &#34;&#34;&#34;</span><span class="">

    </span><span class="pln">sep</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;thousands_sep&#39;</span><span class="pun">]</span><span class="">
    </span><span class="pln">grouping</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;grouping&#39;</span><span class="pun">]</span><span class="">

    </span><span class="pln">groups</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">[</span><span class="pun">]</span><span class="">
    </span><span class="kwd">for</span><span class=""> </span><span class="pln">l</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="pln">_group_lengths</span><span class="pun">(</span><span class="pln">grouping</span><span class="pun">)</span><span class="pun">:</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pln">l</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">raise</span><span class=""> </span><span class="pln">ValueError</span><span class="pun">(</span><span class="str">&#34;group length should be positive&#34;</span><span class="pun">)</span><span class="">
        </span><span class="com"># max(..., 1) forces at least 1 digit to the left of a separator</span><span class="">
        </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">min</span><span class="pun">(</span><span class="pln">max</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">digits</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">min_width</span><span class="pun">,</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">l</span><span class="pun">)</span><span class="">
        </span><span class="pln">groups.append</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">l</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">digits</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">digits</span><span class="pun">[</span><span class="">-</span><span class="pln">l</span><span class="pun">:</span><span class="pun">]</span><span class="pun">)</span><span class="">
        </span><span class="pln">digits</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">digits</span><span class="pun">[</span><span class="pun">:</span><span class="">-</span><span class="pln">l</span><span class="pun">]</span><span class="">
        </span><span class="pln">min_width</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="pln">l</span><span class="">
        </span><span class="kwd">if</span><span class=""> </span><span class="pun">not</span><span class=""> </span><span class="pln">digits</span><span class=""> </span><span class="pun">and</span><span class=""> </span><span class="pln">min_width</span><span class=""> </span><span class="pun">&lt;</span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="pun">:</span><span class="">
            </span><span class="kwd">break</span><span class="">
        </span><span class="pln">min_width</span><span class=""> </span><span class="pun">-</span><span class="pun">=</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">sep</span><span class="pun">)</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">l</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">max</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">digits</span><span class="pun">)</span><span class="pun">,</span><span class=""> </span><span class="pln">min_width</span><span class="pun">,</span><span class=""> </span><span class="dec">1</span><span class="pun">)</span><span class="">
        </span><span class="pln">groups.append</span><span class="pun">(</span><span class="str">&#39;0&#39;</span><span class="pun">*</span><span class="pun">(</span><span class="pln">l</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">digits</span><span class="pun">)</span><span class="pun">)</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">digits</span><span class="pun">[</span><span class="">-</span><span class="pln">l</span><span class="pun">:</span><span class="pun">]</span><span class="pun">)</span><span class="">
    </span><span class="kwd">return</span><span class=""> </span><span class="pln">sep.join</span><span class="pun">(</span><span class="pln">reversed</span><span class="pun">(</span><span class="pln">groups</span><span class="pun">)</span><span class="pun">)</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_format_sign</span><span class="pun">(</span><span class="pln">is_negative</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Determine sign character.&#34;&#34;&#34;</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">is_negative</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="str">&#39;-&#39;</span><span class="">
    </span><span class="kwd">elif</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;sign&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39; +&#39;</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;sign&#39;</span><span class="pun">]</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="kwd">return</span><span class=""> </span><span class="str">&#39;&#39;</span><span class="">

</span><span class="kwd">def</span><span class=""> </span><span class="pln">_format_number</span><span class="pun">(</span><span class="pln">is_negative</span><span class="pun">,</span><span class=""> </span><span class="pln">intpart</span><span class="pun">,</span><span class=""> </span><span class="pln">fracpart</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="pun">:</span><span class="">
    </span><span class="str">&#34;&#34;&#34;Format a number, given the following data:

    is_negative: true if the number is negative, else false
    intpart: string of digits that must appear before the decimal point
    fracpart: string of digits that must come after the point
    exp: exponent, as an integer
    spec: dictionary resulting from parsing the format specifier

    This function uses the information in spec to:
      insert separators (decimal separator and thousands separators)
      format the sign
      format the exponent
      add trailing &#39;%&#39; for the &#39;%&#39; type
      zero-pad if necessary
      fill and align if necessary
    &#34;&#34;&#34;</span><span class="">

    </span><span class="pln">sign</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_format_sign</span><span class="pun">(</span><span class="pln">is_negative</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">fracpart</span><span class="pun">:</span><span class="">
        </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;decimal_point&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">+</span><span class=""> </span><span class="pln">fracpart</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">exp</span><span class=""> </span><span class="pun">!=</span><span class=""> </span><span class="dec">0</span><span class=""> </span><span class="pun">or</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">in</span><span class=""> </span><span class="str">&#39;eE&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">echar</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">{</span><span class="str">&#39;E&#39;</span><span class="pun">:</span><span class=""> </span><span class="str">&#39;E&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;e&#39;</span><span class="pun">:</span><span class=""> </span><span class="str">&#39;e&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;G&#39;</span><span class="pun">:</span><span class=""> </span><span class="str">&#39;E&#39;</span><span class="pun">,</span><span class=""> </span><span class="str">&#39;g&#39;</span><span class="pun">:</span><span class=""> </span><span class="str">&#39;e&#39;</span><span class="pun">}</span><span class="pun">[</span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class="pun">]</span><span class="">
        </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="str">&#34;{0}{1:+}&#34;</span><span class="">.</span><span class="pln">format</span><span class="pun">(</span><span class="pln">echar</span><span class="pun">,</span><span class=""> </span><span class="pln">exp</span><span class="pun">)</span><span class="">
    </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;type&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;%&#39;</span><span class="pun">:</span><span class="">
        </span><span class="pln">fracpart</span><span class=""> </span><span class="pun">+</span><span class="pun">=</span><span class=""> </span><span class="str">&#39;%&#39;</span><span class="">

    </span><span class="kwd">if</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;zeropad&#39;</span><span class="pun">]</span><span class="pun">:</span><span class="">
        </span><span class="pln">min_width</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">spec</span><span class="pun">[</span><span class="str">&#39;minimumwidth&#39;</span><span class="pun">]</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">fracpart</span><span class="pun">)</span><span class=""> </span><span class="pun">-</span><span class=""> </span><span class="pln">len</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">)</span><span class="">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="">
        </span><span class="pln">min_width</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="dec">0</span><span class="">
    </span><span class="pln">intpart</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">_insert_thousands_sep</span><span class="pun">(</span><span class="pln">intpart</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">,</span><span class=""> </span><span class="pln">min_width</span><span class="pun">)</span><span class="">

    </span><span class="kwd">return</span><span class=""> </span><span class="pln">_format_align</span><span class="pun">(</span><span class="pln">sign</span><span class="pun">,</span><span class=""> </span><span class="pln">intpart</span><span class="">+</span><span class="pln">fracpart</span><span class="pun">,</span><span class=""> </span><span class="pln">spec</span><span class="pun">)</span><span class="">


</span><span class="com">##### Useful Constants (internal use only) ################################</span><span class="">

</span><span class="com"># Reusable defaults</span><span class="">
</span><span class="pln">_Infinity</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="str">&#39;Inf&#39;</span><span class="pun">)</span><span class="">
</span><span class="pln">_NegativeInfinity</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="str">&#39;-Inf&#39;</span><span class="pun">)</span><span class="">
</span><span class="pln">_NaN</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="str">&#39;NaN&#39;</span><span class="pun">)</span><span class="">
</span><span class="pln">_Zero</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="dec">0</span><span class="pun">)</span><span class="">
</span><span class="pln">_One</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="dec">1</span><span class="pun">)</span><span class="">
</span><span class="pln">_NegativeOne</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pln">Decimal</span><span class="pun">(</span><span class="">-</span><span class="dec">1</span><span class="pun">)</span><span class="">

</span><span class="com"># _SignedInfinity[sign] is infinity w/ that sign</span><span class="">
</span><span class="pln">_SignedInfinity</span><span class=""> </span><span class="pun">=</span><span class=""> </span><span class="pun">(</span><span class="pln">_Infinity</span><span class="pun">,</span><span class=""> </span><span class="pln">_NegativeInfinity</span><span class="pun">)</span><span class="">



</span><span class="kwd">if</span><span class=""> </span><span class="pln">__name__</span><span class=""> </span><span class="pun">==</span><span class=""> </span><span class="str">&#39;__main__&#39;</span><span class="pun">:</span><span class="">
    </span><span class="kwd">import</span><span class=""> </span><span class="pln">doctest</span><span class="pun">,</span><span class=""> </span><span class="pln">sys</span><span class="">
    </span><span class="pln">doctest.testmod</span><span class="pun">(</span><span class="pln">sys.modules</span><span class="pun">[</span><span class="pln">__name__</span><span class="pun">]</span><span class="pun">)</span>

