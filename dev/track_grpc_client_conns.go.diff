diff --git a/Godeps/_workspace/src/google.golang.org/grpc/clientconn.go b/Godeps/_workspace/src/google.golang.org/grpc/clientconn.go
index 99c2d0c..1db1a99 100644
--- a/Godeps/_workspace/src/google.golang.org/grpc/clientconn.go
+++ b/Godeps/_workspace/src/google.golang.org/grpc/clientconn.go
@@ -35,7 +35,10 @@ package grpc
 
 import (
 	"errors"
+	"log"
 	"net"
+	"os"
+	"runtime/debug"
 	"strings"
 	"sync"
 	"time"
@@ -141,9 +144,55 @@ func Dial(target string, opts ...DialOption) (*ClientConn, error) {
 	cc.shutdownChan = make(chan struct{})
 	// Start to monitor the error status of transport.
 	go cc.transportMonitor()
+
+	ccountMu.Lock()
+	ccount++
+	ccountMu.Unlock()
+	trackClientConn(cc, true)
+
 	return cc, nil
 }
 
+var (
+	ccount   int
+	ccmap    = map[*ClientConn]string{}
+	ccountMu sync.Mutex
+)
+
+func trackClientConn(cc *ClientConn, create bool) {
+	ccountMu.Lock()
+	defer ccountMu.Unlock()
+
+	if create {
+		ccmap[cc] = string(debug.Stack())
+	} else {
+		delete(ccmap, cc)
+	}
+}
+
+func init() {
+	go func() {
+		for {
+			time.Sleep(time.Second * 5)
+			ccountMu.Lock()
+			log.Printf("gRPC client connection count: %d", ccount)
+
+			if os.Getenv("GRPC_CONN_STACKTRACES") != "" {
+				for _, stack := range ccmap {
+					log.Println()
+					log.Println("======================================")
+					log.Println(stack)
+					log.Println()
+					log.Println("======================================")
+					log.Println()
+				}
+			}
+
+			ccountMu.Unlock()
+		}
+	}()
+}
+
 // ClientConn represents a client connection to an RPC service.
 type ClientConn struct {
 	target       string
@@ -283,6 +332,11 @@ func (cc *ClientConn) wait(ctx context.Context, ts int) (transport.ClientTranspo
 // some edge cases (e.g., the caller opens and closes many ClientConn's in a
 // tight loop.
 func (cc *ClientConn) Close() error {
+	ccountMu.Lock()
+	ccount--
+	ccountMu.Unlock()
+	trackClientConn(cc, false)
+
 	cc.mu.Lock()
 	defer cc.mu.Unlock()
 	if cc.closing {
